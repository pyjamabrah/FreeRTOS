
main.elf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <_stext>:
       0:	20002000 	andcs	r2, r0, r0
       4:	000001d1 	ldrdeq	r0, [r0], -r1
       8:	000001fb 	strdeq	r0, [r0], -fp
       c:	000001fd 	strdeq	r0, [r0], -sp
      10:	000001ff 	strdeq	r0, [r0], -pc	@ <UNPREDICTABLE>
      14:	00000201 	andeq	r0, r0, r1, lsl #4
      18:	00000203 	andeq	r0, r0, r3, lsl #4
	...
      2c:	000022e3 	andeq	r2, r0, r3, ror #5
      30:	00000205 	andeq	r0, r0, r5, lsl #4
      34:	00000000 	andeq	r0, r0, r0
      38:	000023f9 	strdeq	r2, [r0], -r9
      3c:	0000243f 	andeq	r2, r0, pc, lsr r4
	...

000001d0 <reset_handler>:

.section .text
.thumb_func
.type reset_handler, %function
reset_handler:
    ldr r0, =_sidata            /* Address of init values in flash */
     1d0:	480d      	ldr	r0, [pc, #52]	@ (208 <default+0x2>)
    ldr r1, =_sdata             /* Start of .data in RAM */
     1d2:	490e      	ldr	r1, [pc, #56]	@ (20c <default+0x6>)
    ldr r2, =_edata             /* End of .data in RAM */
     1d4:	4a0e      	ldr	r2, [pc, #56]	@ (210 <default+0xa>)

000001d6 <copy_data>:

copy_data:
    cmp r1, r2
     1d6:	4291      	cmp	r1, r2
    bcs zero_bss
     1d8:	d204      	bcs.n	1e4 <zero_bss>
    ldr r3, [r0], #4
     1da:	f850 3b04 	ldr.w	r3, [r0], #4
    str r3, [r1], #4
     1de:	f841 3b04 	str.w	r3, [r1], #4
    b copy_data
     1e2:	e7f8      	b.n	1d6 <copy_data>

000001e4 <zero_bss>:

zero_bss:
    ldr r0, =_sbss              /* Start of .bss */
     1e4:	480b      	ldr	r0, [pc, #44]	@ (214 <default+0xe>)
    ldr r1, =_ebss              /* End of .bss */
     1e6:	490c      	ldr	r1, [pc, #48]	@ (218 <default+0x12>)

000001e8 <zero_loop>:

zero_loop:
    cmp r0, r1
     1e8:	4288      	cmp	r0, r1
    bcs call_main
     1ea:	d203      	bcs.n	1f4 <call_main>
    movs r2, #0
     1ec:	2200      	movs	r2, #0
    str r2, [r0], #4
     1ee:	f840 2b04 	str.w	r2, [r0], #4
    b zero_loop
     1f2:	e7f9      	b.n	1e8 <zero_loop>

000001f4 <call_main>:

call_main:
    .thumb_func
    bl start                    /* Call main/start function */
     1f4:	f000 f826 	bl	244 <start>

000001f8 <hang>:
hang:
    b hang                      /* If it returns, hang forever */
     1f8:	e7fe      	b.n	1f8 <hang>

000001fa <NMI_Handler>:
/* Default weak interrupt handlers */

.thumb_func
.global NMI_Handler
NMI_Handler:
    b .
     1fa:	e7fe      	b.n	1fa <NMI_Handler>

000001fc <HardFault_Handler>:

.thumb_func
.global HardFault_Handler
HardFault_Handler:
    b .
     1fc:	e7fe      	b.n	1fc <HardFault_Handler>

000001fe <MemManage_Handler>:

.thumb_func
.global MemManage_Handler
MemManage_Handler:
    b .
     1fe:	e7fe      	b.n	1fe <MemManage_Handler>

00000200 <BusFault_Handler>:

.thumb_func
.global BusFault_Handler
BusFault_Handler:
    b .
     200:	e7fe      	b.n	200 <BusFault_Handler>

00000202 <UsageFault_Handler>:

.thumb_func
.global UsageFault_Handler
UsageFault_Handler:
    b .
     202:	e7fe      	b.n	202 <UsageFault_Handler>

00000204 <DebugMon_Handler>:

.thumb_func
.global DebugMon_Handler
DebugMon_Handler:
    b .
     204:	e7fe      	b.n	204 <DebugMon_Handler>

00000206 <default>:

.thumb_func
default:
    b .
     206:	e7fe      	b.n	206 <default>
    ldr r0, =_sidata            /* Address of init values in flash */
     208:	000024d0 	ldrdeq	r2, [r0], -r0
    ldr r1, =_sdata             /* Start of .data in RAM */
     20c:	20000000 	andcs	r0, r0, r0
    ldr r2, =_edata             /* End of .data in RAM */
     210:	20000004 	andcs	r0, r0, r4
    ldr r0, =_sbss              /* Start of .bss */
     214:	20000004 	andcs	r0, r0, r4
    ldr r1, =_ebss              /* End of .bss */
     218:	200010f8 	strdcs	r1, [r0], -r8

0000021c <vTask1>:
#include "FreeRTOS.h"
#include "task.h"
void start(void);

static void vTask1(void *pvParameters){
     21c:	b480      	push	{r7}
     21e:	b085      	sub	sp, #20
     220:	af00      	add	r7, sp, #0
     222:	6078      	str	r0, [r7, #4]
    volatile int a =0;
     224:	2300      	movs	r3, #0
     226:	60fb      	str	r3, [r7, #12]
    while(1)
    {
        a++;
     228:	68fb      	ldr	r3, [r7, #12]
     22a:	3301      	adds	r3, #1
     22c:	60fb      	str	r3, [r7, #12]
     22e:	e7fb      	b.n	228 <vTask1+0xc>

00000230 <vTask2>:
    }
}

static void vTask2(void *pvParameters){
     230:	b480      	push	{r7}
     232:	b085      	sub	sp, #20
     234:	af00      	add	r7, sp, #0
     236:	6078      	str	r0, [r7, #4]
    volatile int b =0;
     238:	2300      	movs	r3, #0
     23a:	60fb      	str	r3, [r7, #12]
    while(1)
    {
        b++;
     23c:	68fb      	ldr	r3, [r7, #12]
     23e:	3301      	adds	r3, #1
     240:	60fb      	str	r3, [r7, #12]
     242:	e7fb      	b.n	23c <vTask2+0xc>

00000244 <start>:





void start(){
     244:	b580      	push	{r7, lr}
     246:	b086      	sub	sp, #24
     248:	af02      	add	r7, sp, #8
    BaseType_t xReturn;
    //Initialize .data section (copy from flash to RAM)
    uint32_t *src = &_sidata;//Source flash
     24a:	4b1d      	ldr	r3, [pc, #116]	@ (2c0 <start+0x7c>)
     24c:	60fb      	str	r3, [r7, #12]
    uint32_t *dst = &_sdata;//Destination RAM
     24e:	4b1d      	ldr	r3, [pc, #116]	@ (2c4 <start+0x80>)
     250:	60bb      	str	r3, [r7, #8]
    while(dst < &_edata){
     252:	e007      	b.n	264 <start+0x20>
        *dst++ = *src++; //copy word and increment pointer
     254:	68fa      	ldr	r2, [r7, #12]
     256:	1d13      	adds	r3, r2, #4
     258:	60fb      	str	r3, [r7, #12]
     25a:	68bb      	ldr	r3, [r7, #8]
     25c:	1d19      	adds	r1, r3, #4
     25e:	60b9      	str	r1, [r7, #8]
     260:	6812      	ldr	r2, [r2, #0]
     262:	601a      	str	r2, [r3, #0]
    while(dst < &_edata){
     264:	68bb      	ldr	r3, [r7, #8]
     266:	4a18      	ldr	r2, [pc, #96]	@ (2c8 <start+0x84>)
     268:	4293      	cmp	r3, r2
     26a:	d3f3      	bcc.n	254 <start+0x10>
    }

    //Initialize .bss section (zero out)
    dst = &_sbss;
     26c:	4b17      	ldr	r3, [pc, #92]	@ (2cc <start+0x88>)
     26e:	60bb      	str	r3, [r7, #8]
    while(dst < &_ebss){
     270:	e004      	b.n	27c <start+0x38>
        *dst++ = 0; //zero word and increment pointer
     272:	68bb      	ldr	r3, [r7, #8]
     274:	1d1a      	adds	r2, r3, #4
     276:	60ba      	str	r2, [r7, #8]
     278:	2200      	movs	r2, #0
     27a:	601a      	str	r2, [r3, #0]
    while(dst < &_ebss){
     27c:	68bb      	ldr	r3, [r7, #8]
     27e:	4a14      	ldr	r2, [pc, #80]	@ (2d0 <start+0x8c>)
     280:	4293      	cmp	r3, r2
     282:	d3f6      	bcc.n	272 <start+0x2e>
    }
    xReturn = xTaskCreate(vTask1,"T1",configMINIMAL_STACK_SIZE,NULL,1,NULL);  // 256*4 = 1k stack size
     284:	2300      	movs	r3, #0
     286:	9301      	str	r3, [sp, #4]
     288:	2301      	movs	r3, #1
     28a:	9300      	str	r3, [sp, #0]
     28c:	2300      	movs	r3, #0
     28e:	f44f 7280 	mov.w	r2, #256	@ 0x100
     292:	4910      	ldr	r1, [pc, #64]	@ (2d4 <start+0x90>)
     294:	4810      	ldr	r0, [pc, #64]	@ (2d8 <start+0x94>)
     296:	f000 f881 	bl	39c <xTaskCreate>
     29a:	6078      	str	r0, [r7, #4]
    xReturn = xTaskCreate(vTask2,"T2",configMINIMAL_STACK_SIZE,NULL,1,NULL);
     29c:	2300      	movs	r3, #0
     29e:	9301      	str	r3, [sp, #4]
     2a0:	2301      	movs	r3, #1
     2a2:	9300      	str	r3, [sp, #0]
     2a4:	2300      	movs	r3, #0
     2a6:	f44f 7280 	mov.w	r2, #256	@ 0x100
     2aa:	490c      	ldr	r1, [pc, #48]	@ (2dc <start+0x98>)
     2ac:	480c      	ldr	r0, [pc, #48]	@ (2e0 <start+0x9c>)
     2ae:	f000 f875 	bl	39c <xTaskCreate>
     2b2:	6078      	str	r0, [r7, #4]

    xPortStartScheduler();
     2b4:	f002 f839 	bl	232a <xPortStartScheduler>
    return;
     2b8:	bf00      	nop
     2ba:	3710      	adds	r7, #16
     2bc:	46bd      	mov	sp, r7
     2be:	bd80      	pop	{r7, pc}
     2c0:	000024d0 	ldrdeq	r2, [r0], -r0
     2c4:	20000000 	andcs	r0, r0, r0
     2c8:	20000004 	andcs	r0, r0, r4
     2cc:	20000004 	andcs	r0, r0, r4
     2d0:	200010f8 	strdcs	r1, [r0], -r8
     2d4:	000024b8 			@ <UNDEFINED> instruction: 0x000024b8
     2d8:	0000021d 	andeq	r0, r0, sp, lsl r2
     2dc:	000024bc 			@ <UNDEFINED> instruction: 0x000024bc
     2e0:	00000231 	andeq	r0, r0, r1, lsr r2

000002e4 <memset>:
#include <stddef.h>
void *memset(void *dest, int c, size_t count) {
     2e4:	b480      	push	{r7}
     2e6:	b089      	sub	sp, #36	@ 0x24
     2e8:	af00      	add	r7, sp, #0
     2ea:	60f8      	str	r0, [r7, #12]
     2ec:	60b9      	str	r1, [r7, #8]
     2ee:	607a      	str	r2, [r7, #4]
    // Cast the destination pointer to an unsigned char pointer
    // This allows byte-level manipulation of the memory
    unsigned char *ptr = (unsigned char *)dest;
     2f0:	68fb      	ldr	r3, [r7, #12]
     2f2:	61bb      	str	r3, [r7, #24]

    // Convert the integer 'c' to an unsigned char
    // Only the low-order byte of 'c' is used
    unsigned char value = (unsigned char)c;
     2f4:	68bb      	ldr	r3, [r7, #8]
     2f6:	75fb      	strb	r3, [r7, #23]

    // Loop through 'count' bytes
    for (size_t i = 0; i < count; i++) {
     2f8:	2300      	movs	r3, #0
     2fa:	61fb      	str	r3, [r7, #28]
     2fc:	e007      	b.n	30e <memset+0x2a>
        // Assign the 'value' to each byte in the memory block
        ptr[i] = value;
     2fe:	69ba      	ldr	r2, [r7, #24]
     300:	69fb      	ldr	r3, [r7, #28]
     302:	4413      	add	r3, r2
     304:	7dfa      	ldrb	r2, [r7, #23]
     306:	701a      	strb	r2, [r3, #0]
    for (size_t i = 0; i < count; i++) {
     308:	69fb      	ldr	r3, [r7, #28]
     30a:	3301      	adds	r3, #1
     30c:	61fb      	str	r3, [r7, #28]
     30e:	69fa      	ldr	r2, [r7, #28]
     310:	687b      	ldr	r3, [r7, #4]
     312:	429a      	cmp	r2, r3
     314:	d3f3      	bcc.n	2fe <memset+0x1a>
    }

    // Return the original destination pointer
    return dest;
     316:	68fb      	ldr	r3, [r7, #12]
     318:	4618      	mov	r0, r3
     31a:	3724      	adds	r7, #36	@ 0x24
     31c:	46bd      	mov	sp, r7
     31e:	bc80      	pop	{r7}
     320:	4770      	bx	lr
	...

00000324 <prvCreateTask>:
                                  const char * const pcName,
                                  const configSTACK_DEPTH_TYPE uxStackDepth,
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask )
    {
     324:	b580      	push	{r7, lr}
     326:	b08a      	sub	sp, #40	@ 0x28
     328:	af04      	add	r7, sp, #16
     32a:	60f8      	str	r0, [r7, #12]
     32c:	60b9      	str	r1, [r7, #8]
     32e:	607a      	str	r2, [r7, #4]
     330:	603b      	str	r3, [r7, #0]

            /* Allocate space for the stack used by the task being created. */
            /* MISRA Ref 11.5.1 [Malloc memory assignment] */
            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
            /* coverity[misra_c_2012_rule_11_5_violation] */
            pxStack = pvPortMallocStack( ( ( ( size_t ) uxStackDepth ) * sizeof( StackType_t ) ) );
     332:	687b      	ldr	r3, [r7, #4]
     334:	009b      	lsls	r3, r3, #2
     336:	4618      	mov	r0, r3
     338:	f001 fd1a 	bl	1d70 <pvPortMalloc>
     33c:	6138      	str	r0, [r7, #16]

            if( pxStack != NULL )
     33e:	693b      	ldr	r3, [r7, #16]
     340:	2b00      	cmp	r3, #0
     342:	d013      	beq.n	36c <prvCreateTask+0x48>
            {
                /* Allocate space for the TCB. */
                /* MISRA Ref 11.5.1 [Malloc memory assignment] */
                /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
                /* coverity[misra_c_2012_rule_11_5_violation] */
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
     344:	204c      	movs	r0, #76	@ 0x4c
     346:	f001 fd13 	bl	1d70 <pvPortMalloc>
     34a:	6178      	str	r0, [r7, #20]

                if( pxNewTCB != NULL )
     34c:	697b      	ldr	r3, [r7, #20]
     34e:	2b00      	cmp	r3, #0
     350:	d008      	beq.n	364 <prvCreateTask+0x40>
                {
                    ( void ) memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
     352:	224c      	movs	r2, #76	@ 0x4c
     354:	2100      	movs	r1, #0
     356:	6978      	ldr	r0, [r7, #20]
     358:	f7ff ffc4 	bl	2e4 <memset>

                    /* Store the stack location in the TCB. */
                    pxNewTCB->pxStack = pxStack;
     35c:	697b      	ldr	r3, [r7, #20]
     35e:	693a      	ldr	r2, [r7, #16]
     360:	631a      	str	r2, [r3, #48]	@ 0x30
     362:	e005      	b.n	370 <prvCreateTask+0x4c>
                }
                else
                {
                    /* The stack cannot be used as the TCB was not created.  Free
                     * it again. */
                    vPortFreeStack( pxStack );
     364:	6938      	ldr	r0, [r7, #16]
     366:	f001 fdb5 	bl	1ed4 <vPortFree>
     36a:	e001      	b.n	370 <prvCreateTask+0x4c>
                }
            }
            else
            {
                pxNewTCB = NULL;
     36c:	2300      	movs	r3, #0
     36e:	617b      	str	r3, [r7, #20]
            }
        }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
     370:	697b      	ldr	r3, [r7, #20]
     372:	2b00      	cmp	r3, #0
     374:	d00d      	beq.n	392 <prvCreateTask+0x6e>
                 * task was created dynamically in case it is later deleted. */
                pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
            }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
     376:	2300      	movs	r3, #0
     378:	9303      	str	r3, [sp, #12]
     37a:	697b      	ldr	r3, [r7, #20]
     37c:	9302      	str	r3, [sp, #8]
     37e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
     380:	9301      	str	r3, [sp, #4]
     382:	6a3b      	ldr	r3, [r7, #32]
     384:	9300      	str	r3, [sp, #0]
     386:	683b      	ldr	r3, [r7, #0]
     388:	687a      	ldr	r2, [r7, #4]
     38a:	68b9      	ldr	r1, [r7, #8]
     38c:	68f8      	ldr	r0, [r7, #12]
     38e:	f000 f828 	bl	3e2 <prvInitialiseNewTask>
        }

        return pxNewTCB;
     392:	697b      	ldr	r3, [r7, #20]
    }
     394:	4618      	mov	r0, r3
     396:	3718      	adds	r7, #24
     398:	46bd      	mov	sp, r7
     39a:	bd80      	pop	{r7, pc}

0000039c <xTaskCreate>:
                            const char * const pcName,
                            const configSTACK_DEPTH_TYPE uxStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
     39c:	b580      	push	{r7, lr}
     39e:	b088      	sub	sp, #32
     3a0:	af02      	add	r7, sp, #8
     3a2:	60f8      	str	r0, [r7, #12]
     3a4:	60b9      	str	r1, [r7, #8]
     3a6:	607a      	str	r2, [r7, #4]
     3a8:	603b      	str	r3, [r7, #0]
        TCB_t * pxNewTCB;
        BaseType_t xReturn;

        traceENTER_xTaskCreate( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask );

        pxNewTCB = prvCreateTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask );
     3aa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
     3ac:	9301      	str	r3, [sp, #4]
     3ae:	6a3b      	ldr	r3, [r7, #32]
     3b0:	9300      	str	r3, [sp, #0]
     3b2:	683b      	ldr	r3, [r7, #0]
     3b4:	687a      	ldr	r2, [r7, #4]
     3b6:	68b9      	ldr	r1, [r7, #8]
     3b8:	68f8      	ldr	r0, [r7, #12]
     3ba:	f7ff ffb3 	bl	324 <prvCreateTask>
     3be:	6138      	str	r0, [r7, #16]

        if( pxNewTCB != NULL )
     3c0:	693b      	ldr	r3, [r7, #16]
     3c2:	2b00      	cmp	r3, #0
     3c4:	d005      	beq.n	3d2 <xTaskCreate+0x36>
                /* Set the task's affinity before scheduling it. */
                pxNewTCB->uxCoreAffinityMask = configTASK_DEFAULT_CORE_AFFINITY;
            }
            #endif

            prvAddNewTaskToReadyList( pxNewTCB );
     3c6:	6938      	ldr	r0, [r7, #16]
     3c8:	f000 f870 	bl	4ac <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
     3cc:	2301      	movs	r3, #1
     3ce:	617b      	str	r3, [r7, #20]
     3d0:	e002      	b.n	3d8 <xTaskCreate+0x3c>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     3d2:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
     3d6:	617b      	str	r3, [r7, #20]
        }

        traceRETURN_xTaskCreate( xReturn );

        return xReturn;
     3d8:	697b      	ldr	r3, [r7, #20]
    }
     3da:	4618      	mov	r0, r3
     3dc:	3718      	adds	r7, #24
     3de:	46bd      	mov	sp, r7
     3e0:	bd80      	pop	{r7, pc}

000003e2 <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
     3e2:	b580      	push	{r7, lr}
     3e4:	b086      	sub	sp, #24
     3e6:	af00      	add	r7, sp, #0
     3e8:	60f8      	str	r0, [r7, #12]
     3ea:	60b9      	str	r1, [r7, #8]
     3ec:	607a      	str	r2, [r7, #4]
     3ee:	603b      	str	r3, [r7, #0]
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
    {
        pxTopOfStack = &( pxNewTCB->pxStack[ uxStackDepth - ( configSTACK_DEPTH_TYPE ) 1 ] );
     3f0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
     3f2:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
     3f4:	687b      	ldr	r3, [r7, #4]
     3f6:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
     3fa:	3b01      	subs	r3, #1
     3fc:	009b      	lsls	r3, r3, #2
     3fe:	4413      	add	r3, r2
     400:	613b      	str	r3, [r7, #16]
        pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     402:	693b      	ldr	r3, [r7, #16]
     404:	f023 0307 	bic.w	r3, r3, #7
     408:	613b      	str	r3, [r7, #16]
        pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( uxStackDepth - ( configSTACK_DEPTH_TYPE ) 1 );
    }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
     40a:	68bb      	ldr	r3, [r7, #8]
     40c:	2b00      	cmp	r3, #0
     40e:	d01e      	beq.n	44e <prvInitialiseNewTask+0x6c>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     410:	2300      	movs	r3, #0
     412:	617b      	str	r3, [r7, #20]
     414:	e012      	b.n	43c <prvInitialiseNewTask+0x5a>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     416:	68ba      	ldr	r2, [r7, #8]
     418:	697b      	ldr	r3, [r7, #20]
     41a:	4413      	add	r3, r2
     41c:	7819      	ldrb	r1, [r3, #0]
     41e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
     420:	697b      	ldr	r3, [r7, #20]
     422:	4413      	add	r3, r2
     424:	3334      	adds	r3, #52	@ 0x34
     426:	460a      	mov	r2, r1
     428:	701a      	strb	r2, [r3, #0]

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
     42a:	68ba      	ldr	r2, [r7, #8]
     42c:	697b      	ldr	r3, [r7, #20]
     42e:	4413      	add	r3, r2
     430:	781b      	ldrb	r3, [r3, #0]
     432:	2b00      	cmp	r3, #0
     434:	d006      	beq.n	444 <prvInitialiseNewTask+0x62>
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     436:	697b      	ldr	r3, [r7, #20]
     438:	3301      	adds	r3, #1
     43a:	617b      	str	r3, [r7, #20]
     43c:	697b      	ldr	r3, [r7, #20]
     43e:	2b0f      	cmp	r3, #15
     440:	d9e9      	bls.n	416 <prvInitialiseNewTask+0x34>
     442:	e000      	b.n	446 <prvInitialiseNewTask+0x64>
            {
                break;
     444:	bf00      	nop
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1U ] = '\0';
     446:	6abb      	ldr	r3, [r7, #40]	@ 0x28
     448:	2200      	movs	r2, #0
     44a:	f883 2043 	strb.w	r2, [r3, #67]	@ 0x43
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
     44e:	6a3b      	ldr	r3, [r7, #32]
     450:	2b04      	cmp	r3, #4
     452:	d901      	bls.n	458 <prvInitialiseNewTask+0x76>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
     454:	2304      	movs	r3, #4
     456:	623b      	str	r3, [r7, #32]
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
     458:	6abb      	ldr	r3, [r7, #40]	@ 0x28
     45a:	6a3a      	ldr	r2, [r7, #32]
     45c:	62da      	str	r2, [r3, #44]	@ 0x2c
    {
        pxNewTCB->uxBasePriority = uxPriority;
    }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     45e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
     460:	3304      	adds	r3, #4
     462:	4618      	mov	r0, r3
     464:	f001 fbf3 	bl	1c4e <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     468:	6abb      	ldr	r3, [r7, #40]	@ 0x28
     46a:	3318      	adds	r3, #24
     46c:	4618      	mov	r0, r3
     46e:	f001 fbee 	bl	1c4e <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     472:	6abb      	ldr	r3, [r7, #40]	@ 0x28
     474:	6aba      	ldr	r2, [r7, #40]	@ 0x28
     476:	611a      	str	r2, [r3, #16]

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority );
     478:	6a3b      	ldr	r3, [r7, #32]
     47a:	f1c3 0205 	rsb	r2, r3, #5
     47e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
     480:	619a      	str	r2, [r3, #24]
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     482:	6abb      	ldr	r3, [r7, #40]	@ 0x28
     484:	6aba      	ldr	r2, [r7, #40]	@ 0x28
     486:	625a      	str	r2, [r3, #36]	@ 0x24
            }
            #endif /* portSTACK_GROWTH */
        }
        #else /* portHAS_STACK_OVERFLOW_CHECKING */
        {
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     488:	683a      	ldr	r2, [r7, #0]
     48a:	68f9      	ldr	r1, [r7, #12]
     48c:	6938      	ldr	r0, [r7, #16]
     48e:	f001 fee3 	bl	2258 <pxPortInitialiseStack>
     492:	4602      	mov	r2, r0
     494:	6abb      	ldr	r3, [r7, #40]	@ 0x28
     496:	601a      	str	r2, [r3, #0]
            pxNewTCB->uxTaskAttributes |= taskATTRIBUTE_IS_IDLE;
        }
    }
    #endif /* #if ( configNUMBER_OF_CORES > 1 ) */

    if( pxCreatedTask != NULL )
     498:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
     49a:	2b00      	cmp	r3, #0
     49c:	d002      	beq.n	4a4 <prvInitialiseNewTask+0xc2>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     49e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
     4a0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
     4a2:	601a      	str	r2, [r3, #0]
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
     4a4:	bf00      	nop
     4a6:	3718      	adds	r7, #24
     4a8:	46bd      	mov	sp, r7
     4aa:	bd80      	pop	{r7, pc}

000004ac <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

#if ( configNUMBER_OF_CORES == 1 )

    static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
    {
     4ac:	b580      	push	{r7, lr}
     4ae:	b084      	sub	sp, #16
     4b0:	af00      	add	r7, sp, #0
     4b2:	6078      	str	r0, [r7, #4]
        /* Ensure interrupts don't access the task lists while the lists are being
         * updated. */
        taskENTER_CRITICAL();
     4b4:	f001 ff6c 	bl	2390 <vPortEnterCritical>
        {
            uxCurrentNumberOfTasks = ( UBaseType_t ) ( uxCurrentNumberOfTasks + 1U );
     4b8:	4b3f      	ldr	r3, [pc, #252]	@ (5b8 <prvAddNewTaskToReadyList+0x10c>)
     4ba:	681b      	ldr	r3, [r3, #0]
     4bc:	3301      	adds	r3, #1
     4be:	4a3e      	ldr	r2, [pc, #248]	@ (5b8 <prvAddNewTaskToReadyList+0x10c>)
     4c0:	6013      	str	r3, [r2, #0]

            if( pxCurrentTCB == NULL )
     4c2:	4b3e      	ldr	r3, [pc, #248]	@ (5bc <prvAddNewTaskToReadyList+0x110>)
     4c4:	681b      	ldr	r3, [r3, #0]
     4c6:	2b00      	cmp	r3, #0
     4c8:	d109      	bne.n	4de <prvAddNewTaskToReadyList+0x32>
            {
                /* There are no other tasks, or all the other tasks are in
                 * the suspended state - make this the current task. */
                pxCurrentTCB = pxNewTCB;
     4ca:	4a3c      	ldr	r2, [pc, #240]	@ (5bc <prvAddNewTaskToReadyList+0x110>)
     4cc:	687b      	ldr	r3, [r7, #4]
     4ce:	6013      	str	r3, [r2, #0]

                if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     4d0:	4b39      	ldr	r3, [pc, #228]	@ (5b8 <prvAddNewTaskToReadyList+0x10c>)
     4d2:	681b      	ldr	r3, [r3, #0]
     4d4:	2b01      	cmp	r3, #1
     4d6:	d110      	bne.n	4fa <prvAddNewTaskToReadyList+0x4e>
                {
                    /* This is the first task to be created so do the preliminary
                     * initialisation required.  We will not recover if this call
                     * fails, but we will report the failure. */
                    prvInitialiseTaskLists();
     4d8:	f000 fe12 	bl	1100 <prvInitialiseTaskLists>
     4dc:	e00d      	b.n	4fa <prvAddNewTaskToReadyList+0x4e>
            else
            {
                /* If the scheduler is not already running, make this task the
                 * current task if it is the highest priority task to be created
                 * so far. */
                if( xSchedulerRunning == pdFALSE )
     4de:	4b38      	ldr	r3, [pc, #224]	@ (5c0 <prvAddNewTaskToReadyList+0x114>)
     4e0:	681b      	ldr	r3, [r3, #0]
     4e2:	2b00      	cmp	r3, #0
     4e4:	d109      	bne.n	4fa <prvAddNewTaskToReadyList+0x4e>
                {
                    if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     4e6:	4b35      	ldr	r3, [pc, #212]	@ (5bc <prvAddNewTaskToReadyList+0x110>)
     4e8:	681b      	ldr	r3, [r3, #0]
     4ea:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     4ec:	687b      	ldr	r3, [r7, #4]
     4ee:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
     4f0:	429a      	cmp	r2, r3
     4f2:	d802      	bhi.n	4fa <prvAddNewTaskToReadyList+0x4e>
                    {
                        pxCurrentTCB = pxNewTCB;
     4f4:	4a31      	ldr	r2, [pc, #196]	@ (5bc <prvAddNewTaskToReadyList+0x110>)
     4f6:	687b      	ldr	r3, [r7, #4]
     4f8:	6013      	str	r3, [r2, #0]
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            uxTaskNumber++;
     4fa:	4b32      	ldr	r3, [pc, #200]	@ (5c4 <prvAddNewTaskToReadyList+0x118>)
     4fc:	681b      	ldr	r3, [r3, #0]
     4fe:	3301      	adds	r3, #1
     500:	4a30      	ldr	r2, [pc, #192]	@ (5c4 <prvAddNewTaskToReadyList+0x118>)
     502:	6013      	str	r3, [r2, #0]
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
            #endif /* configUSE_TRACE_FACILITY */
            traceTASK_CREATE( pxNewTCB );

            prvAddTaskToReadyList( pxNewTCB );
     504:	687b      	ldr	r3, [r7, #4]
     506:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
     508:	2201      	movs	r2, #1
     50a:	409a      	lsls	r2, r3
     50c:	4b2e      	ldr	r3, [pc, #184]	@ (5c8 <prvAddNewTaskToReadyList+0x11c>)
     50e:	681b      	ldr	r3, [r3, #0]
     510:	4313      	orrs	r3, r2
     512:	4a2d      	ldr	r2, [pc, #180]	@ (5c8 <prvAddNewTaskToReadyList+0x11c>)
     514:	6013      	str	r3, [r2, #0]
     516:	687b      	ldr	r3, [r7, #4]
     518:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     51a:	492c      	ldr	r1, [pc, #176]	@ (5cc <prvAddNewTaskToReadyList+0x120>)
     51c:	4613      	mov	r3, r2
     51e:	009b      	lsls	r3, r3, #2
     520:	4413      	add	r3, r2
     522:	009b      	lsls	r3, r3, #2
     524:	440b      	add	r3, r1
     526:	3304      	adds	r3, #4
     528:	681b      	ldr	r3, [r3, #0]
     52a:	60fb      	str	r3, [r7, #12]
     52c:	687b      	ldr	r3, [r7, #4]
     52e:	68fa      	ldr	r2, [r7, #12]
     530:	609a      	str	r2, [r3, #8]
     532:	68fb      	ldr	r3, [r7, #12]
     534:	689a      	ldr	r2, [r3, #8]
     536:	687b      	ldr	r3, [r7, #4]
     538:	60da      	str	r2, [r3, #12]
     53a:	68fb      	ldr	r3, [r7, #12]
     53c:	689b      	ldr	r3, [r3, #8]
     53e:	687a      	ldr	r2, [r7, #4]
     540:	3204      	adds	r2, #4
     542:	605a      	str	r2, [r3, #4]
     544:	687b      	ldr	r3, [r7, #4]
     546:	1d1a      	adds	r2, r3, #4
     548:	68fb      	ldr	r3, [r7, #12]
     54a:	609a      	str	r2, [r3, #8]
     54c:	687b      	ldr	r3, [r7, #4]
     54e:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     550:	4613      	mov	r3, r2
     552:	009b      	lsls	r3, r3, #2
     554:	4413      	add	r3, r2
     556:	009b      	lsls	r3, r3, #2
     558:	4a1c      	ldr	r2, [pc, #112]	@ (5cc <prvAddNewTaskToReadyList+0x120>)
     55a:	441a      	add	r2, r3
     55c:	687b      	ldr	r3, [r7, #4]
     55e:	615a      	str	r2, [r3, #20]
     560:	687b      	ldr	r3, [r7, #4]
     562:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     564:	4919      	ldr	r1, [pc, #100]	@ (5cc <prvAddNewTaskToReadyList+0x120>)
     566:	4613      	mov	r3, r2
     568:	009b      	lsls	r3, r3, #2
     56a:	4413      	add	r3, r2
     56c:	009b      	lsls	r3, r3, #2
     56e:	440b      	add	r3, r1
     570:	681b      	ldr	r3, [r3, #0]
     572:	687a      	ldr	r2, [r7, #4]
     574:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
     576:	1c59      	adds	r1, r3, #1
     578:	4814      	ldr	r0, [pc, #80]	@ (5cc <prvAddNewTaskToReadyList+0x120>)
     57a:	4613      	mov	r3, r2
     57c:	009b      	lsls	r3, r3, #2
     57e:	4413      	add	r3, r2
     580:	009b      	lsls	r3, r3, #2
     582:	4403      	add	r3, r0
     584:	6019      	str	r1, [r3, #0]

            portSETUP_TCB( pxNewTCB );
        }
        taskEXIT_CRITICAL();
     586:	f001 ff1d 	bl	23c4 <vPortExitCritical>

        if( xSchedulerRunning != pdFALSE )
     58a:	4b0d      	ldr	r3, [pc, #52]	@ (5c0 <prvAddNewTaskToReadyList+0x114>)
     58c:	681b      	ldr	r3, [r3, #0]
     58e:	2b00      	cmp	r3, #0
     590:	d00e      	beq.n	5b0 <prvAddNewTaskToReadyList+0x104>
        {
            /* If the created task is of a higher priority than the current task
             * then it should run now. */
            taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxNewTCB );
     592:	4b0a      	ldr	r3, [pc, #40]	@ (5bc <prvAddNewTaskToReadyList+0x110>)
     594:	681b      	ldr	r3, [r3, #0]
     596:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     598:	687b      	ldr	r3, [r7, #4]
     59a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
     59c:	429a      	cmp	r2, r3
     59e:	d207      	bcs.n	5b0 <prvAddNewTaskToReadyList+0x104>
     5a0:	4b0b      	ldr	r3, [pc, #44]	@ (5d0 <prvAddNewTaskToReadyList+0x124>)
     5a2:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
     5a6:	601a      	str	r2, [r3, #0]
     5a8:	f3bf 8f4f 	dsb	sy
     5ac:	f3bf 8f6f 	isb	sy
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
     5b0:	bf00      	nop
     5b2:	3710      	adds	r7, #16
     5b4:	46bd      	mov	sp, r7
     5b6:	bd80      	pop	{r7, pc}
     5b8:	200000b0 	strhcs	r0, [r0], -r0	@ <UNPREDICTABLE>
     5bc:	20000004 	andcs	r0, r0, r4
     5c0:	200000bc 	strhcs	r0, [r0], -ip
     5c4:	200000cc 	andcs	r0, r0, ip, asr #1
     5c8:	200000b8 	strhcs	r0, [r0], -r8
     5cc:	20000008 	andcs	r0, r0, r8
     5d0:	e000ed04 	and	lr, r0, r4, lsl #26

000005d4 <prvCreateIdleTasks>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

static BaseType_t prvCreateIdleTasks( void )
{
     5d4:	b580      	push	{r7, lr}
     5d6:	b08a      	sub	sp, #40	@ 0x28
     5d8:	af02      	add	r7, sp, #8
    BaseType_t xReturn = pdPASS;
     5da:	2301      	movs	r3, #1
     5dc:	61fb      	str	r3, [r7, #28]
    BaseType_t xCoreID;
    char cIdleName[ configMAX_TASK_NAME_LEN ] = { 0 };
     5de:	463b      	mov	r3, r7
     5e0:	2200      	movs	r2, #0
     5e2:	601a      	str	r2, [r3, #0]
     5e4:	605a      	str	r2, [r3, #4]
     5e6:	609a      	str	r2, [r3, #8]
     5e8:	60da      	str	r2, [r3, #12]
    TaskFunction_t pxIdleTaskFunction = NULL;
     5ea:	2300      	movs	r3, #0
     5ec:	613b      	str	r3, [r7, #16]
    UBaseType_t xIdleTaskNameIndex;

    /* MISRA Ref 14.3.1 [Configuration dependent invariant] */
    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-143. */
    /* coverity[misra_c_2012_rule_14_3_violation] */
    for( xIdleTaskNameIndex = 0U; xIdleTaskNameIndex < ( configMAX_TASK_NAME_LEN - taskRESERVED_TASK_NAME_LENGTH ); xIdleTaskNameIndex++ )
     5ee:	2300      	movs	r3, #0
     5f0:	617b      	str	r3, [r7, #20]
     5f2:	e011      	b.n	618 <prvCreateIdleTasks+0x44>
    {
        /* MISRA Ref 18.1.1 [Configuration dependent bounds checking] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-181. */
        /* coverity[misra_c_2012_rule_18_1_violation] */
        cIdleName[ xIdleTaskNameIndex ] = configIDLE_TASK_NAME[ xIdleTaskNameIndex ];
     5f4:	4a1f      	ldr	r2, [pc, #124]	@ (674 <prvCreateIdleTasks+0xa0>)
     5f6:	697b      	ldr	r3, [r7, #20]
     5f8:	4413      	add	r3, r2
     5fa:	7819      	ldrb	r1, [r3, #0]
     5fc:	463a      	mov	r2, r7
     5fe:	697b      	ldr	r3, [r7, #20]
     600:	4413      	add	r3, r2
     602:	460a      	mov	r2, r1
     604:	701a      	strb	r2, [r3, #0]

        if( cIdleName[ xIdleTaskNameIndex ] == ( char ) 0x00 )
     606:	463a      	mov	r2, r7
     608:	697b      	ldr	r3, [r7, #20]
     60a:	4413      	add	r3, r2
     60c:	781b      	ldrb	r3, [r3, #0]
     60e:	2b00      	cmp	r3, #0
     610:	d006      	beq.n	620 <prvCreateIdleTasks+0x4c>
    for( xIdleTaskNameIndex = 0U; xIdleTaskNameIndex < ( configMAX_TASK_NAME_LEN - taskRESERVED_TASK_NAME_LENGTH ); xIdleTaskNameIndex++ )
     612:	697b      	ldr	r3, [r7, #20]
     614:	3301      	adds	r3, #1
     616:	617b      	str	r3, [r7, #20]
     618:	697b      	ldr	r3, [r7, #20]
     61a:	2b0e      	cmp	r3, #14
     61c:	d9ea      	bls.n	5f4 <prvCreateIdleTasks+0x20>
     61e:	e000      	b.n	622 <prvCreateIdleTasks+0x4e>
        {
            break;
     620:	bf00      	nop
            mtCOVERAGE_TEST_MARKER();
        }
    }

    /* Ensure null termination. */
    cIdleName[ xIdleTaskNameIndex ] = '\0';
     622:	463a      	mov	r2, r7
     624:	697b      	ldr	r3, [r7, #20]
     626:	4413      	add	r3, r2
     628:	2200      	movs	r2, #0
     62a:	701a      	strb	r2, [r3, #0]

    /* Add each idle task at the lowest priority. */
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
     62c:	2300      	movs	r3, #0
     62e:	61bb      	str	r3, [r7, #24]
     630:	e016      	b.n	660 <prvCreateIdleTasks+0x8c>
    {
        #if ( configNUMBER_OF_CORES == 1 )
        {
            pxIdleTaskFunction = &prvIdleTask;
     632:	4b11      	ldr	r3, [pc, #68]	@ (678 <prvCreateIdleTasks+0xa4>)
     634:	613b      	str	r3, [r7, #16]
            }
        }
        #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( pxIdleTaskFunction,
     636:	69bb      	ldr	r3, [r7, #24]
     638:	009b      	lsls	r3, r3, #2
     63a:	4a10      	ldr	r2, [pc, #64]	@ (67c <prvCreateIdleTasks+0xa8>)
     63c:	4413      	add	r3, r2
     63e:	4639      	mov	r1, r7
     640:	9301      	str	r3, [sp, #4]
     642:	2300      	movs	r3, #0
     644:	9300      	str	r3, [sp, #0]
     646:	2300      	movs	r3, #0
     648:	f44f 7280 	mov.w	r2, #256	@ 0x100
     64c:	6938      	ldr	r0, [r7, #16]
     64e:	f7ff fea5 	bl	39c <xTaskCreate>
     652:	61f8      	str	r0, [r7, #28]
                                   &xIdleTaskHandles[ xCoreID ] );
        }
        #endif /* configSUPPORT_STATIC_ALLOCATION */

        /* Break the loop if any of the idle task is failed to be created. */
        if( xReturn != pdPASS )
     654:	69fb      	ldr	r3, [r7, #28]
     656:	2b01      	cmp	r3, #1
     658:	d106      	bne.n	668 <prvCreateIdleTasks+0x94>
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
     65a:	69bb      	ldr	r3, [r7, #24]
     65c:	3301      	adds	r3, #1
     65e:	61bb      	str	r3, [r7, #24]
     660:	69bb      	ldr	r3, [r7, #24]
     662:	2b00      	cmp	r3, #0
     664:	dde5      	ble.n	632 <prvCreateIdleTasks+0x5e>
     666:	e000      	b.n	66a <prvCreateIdleTasks+0x96>
        {
            break;
     668:	bf00      	nop
            }
            #endif
        }
    }

    return xReturn;
     66a:	69fb      	ldr	r3, [r7, #28]
}
     66c:	4618      	mov	r0, r3
     66e:	3720      	adds	r7, #32
     670:	46bd      	mov	sp, r7
     672:	bd80      	pop	{r7, pc}
     674:	000024c4 	andeq	r2, r0, r4, asr #9
     678:	000010d1 	ldrdeq	r1, [r0], -r1	@ <UNPREDICTABLE>
     67c:	200000d4 	ldrdcs	r0, [r0], -r4

00000680 <vTaskStartScheduler>:

/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     680:	b580      	push	{r7, lr}
     682:	b082      	sub	sp, #8
     684:	af00      	add	r7, sp, #0
         * the number of bits as confNUMBER_OF_CORES. */
        configASSERT( ( sizeof( UBaseType_t ) * taskBITS_PER_BYTE ) >= configNUMBER_OF_CORES );
    }
    #endif /* #if ( configUSE_CORE_AFFINITY == 1 ) && ( configNUMBER_OF_CORES > 1 ) */

    xReturn = prvCreateIdleTasks();
     686:	f7ff ffa5 	bl	5d4 <prvCreateIdleTasks>
     68a:	6078      	str	r0, [r7, #4]
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
     68c:	687b      	ldr	r3, [r7, #4]
     68e:	2b01      	cmp	r3, #1
     690:	d115      	bne.n	6be <vTaskStartScheduler+0x3e>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
    uint32_t ulNewBASEPRI;

    __asm volatile
     692:	f04f 0301 	mov.w	r3, #1
     696:	f383 8811 	msr	BASEPRI, r3
     69a:	f3bf 8f6f 	isb	sy
     69e:	f3bf 8f4f 	dsb	sy
     6a2:	603b      	str	r3, [r7, #0]
        "   msr basepri, %0                                         \n" \
        "   isb                                                     \n" \
        "   dsb                                                     \n" \
        : "=r" ( ulNewBASEPRI ) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
    );
}
     6a4:	bf00      	nop
             * block specific to the task that will run first. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif

        xNextTaskUnblockTime = portMAX_DELAY;
     6a6:	4b09      	ldr	r3, [pc, #36]	@ (6cc <vTaskStartScheduler+0x4c>)
     6a8:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
     6ac:	601a      	str	r2, [r3, #0]
        xSchedulerRunning = pdTRUE;
     6ae:	4b08      	ldr	r3, [pc, #32]	@ (6d0 <vTaskStartScheduler+0x50>)
     6b0:	2201      	movs	r2, #1
     6b2:	601a      	str	r2, [r3, #0]
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
     6b4:	4b07      	ldr	r3, [pc, #28]	@ (6d4 <vTaskStartScheduler+0x54>)
     6b6:	2200      	movs	r2, #0
     6b8:	601a      	str	r2, [r3, #0]
        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */

        /* The return value for xPortStartScheduler is not required
         * hence using a void datatype. */
        ( void ) xPortStartScheduler();
     6ba:	f001 fe36 	bl	232a <xPortStartScheduler>
     * meaning xIdleTaskHandles are not used anywhere else. */
    ( void ) xIdleTaskHandles;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
     6be:	4b06      	ldr	r3, [pc, #24]	@ (6d8 <vTaskStartScheduler+0x58>)
     6c0:	681b      	ldr	r3, [r3, #0]

    traceRETURN_vTaskStartScheduler();
}
     6c2:	bf00      	nop
     6c4:	3708      	adds	r7, #8
     6c6:	46bd      	mov	sp, r7
     6c8:	bd80      	pop	{r7, pc}
     6ca:	bf00      	nop
     6cc:	200000d0 	ldrdcs	r0, [r0], -r0	@ <UNPREDICTABLE>
     6d0:	200000bc 	strhcs	r0, [r0], -ip
     6d4:	200000b4 	strhcs	r0, [r0], -r4
     6d8:	000024c0 	andeq	r2, r0, r0, asr #9

000006dc <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
     6dc:	b580      	push	{r7, lr}
     6de:	b082      	sub	sp, #8
     6e0:	af00      	add	r7, sp, #0
    __asm volatile
     6e2:	f04f 0301 	mov.w	r3, #1
     6e6:	f383 8811 	msr	BASEPRI, r3
     6ea:	f3bf 8f6f 	isb	sy
     6ee:	f3bf 8f4f 	dsb	sy
     6f2:	607b      	str	r3, [r7, #4]
}
     6f4:	bf00      	nop

    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    xSchedulerRunning = pdFALSE;
     6f6:	4b04      	ldr	r3, [pc, #16]	@ (708 <vTaskEndScheduler+0x2c>)
     6f8:	2200      	movs	r2, #0
     6fa:	601a      	str	r2, [r3, #0]

    /* This function must be called from a task and the application is
     * responsible for deleting that task after the scheduler is stopped. */
    vPortEndScheduler();
     6fc:	f001 fe42 	bl	2384 <vPortEndScheduler>

    traceRETURN_vTaskEndScheduler();
}
     700:	bf00      	nop
     702:	3708      	adds	r7, #8
     704:	46bd      	mov	sp, r7
     706:	bd80      	pop	{r7, pc}
     708:	200000bc 	strhcs	r0, [r0], -ip

0000070c <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
     70c:	b480      	push	{r7}
     70e:	af00      	add	r7, sp, #0
         * do not otherwise exhibit real time behaviour. */
        portSOFTWARE_BARRIER();

        /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
         * is used to allow calls to vTaskSuspendAll() to nest. */
        uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended + 1U );
     710:	4b04      	ldr	r3, [pc, #16]	@ (724 <vTaskSuspendAll+0x18>)
     712:	681b      	ldr	r3, [r3, #0]
     714:	3301      	adds	r3, #1
     716:	4a03      	ldr	r2, [pc, #12]	@ (724 <vTaskSuspendAll+0x18>)
     718:	6013      	str	r3, [r2, #0]
        }
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    traceRETURN_vTaskSuspendAll();
}
     71a:	bf00      	nop
     71c:	46bd      	mov	sp, r7
     71e:	bc80      	pop	{r7}
     720:	4770      	bx	lr
     722:	bf00      	nop
     724:	200000d8 	ldrdcs	r0, [r0], -r8

00000728 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     728:	b580      	push	{r7, lr}
     72a:	b088      	sub	sp, #32
     72c:	af00      	add	r7, sp, #0
    TCB_t * pxTCB = NULL;
     72e:	2300      	movs	r3, #0
     730:	61fb      	str	r3, [r7, #28]
    BaseType_t xAlreadyYielded = pdFALSE;
     732:	2300      	movs	r3, #0
     734:	61bb      	str	r3, [r7, #24]
        /* It is possible that an ISR caused a task to be removed from an event
         * list while the scheduler was suspended.  If this was the case then the
         * removed task will have been added to the xPendingReadyList.  Once the
         * scheduler has been resumed it is safe to move all the pending ready
         * tasks from this list into their appropriate ready list. */
        taskENTER_CRITICAL();
     736:	f001 fe2b 	bl	2390 <vPortEnterCritical>
        {
            const BaseType_t xCoreID = ( BaseType_t ) portGET_CORE_ID();
     73a:	2300      	movs	r3, #0
     73c:	613b      	str	r3, [r7, #16]

            /* If uxSchedulerSuspended is zero then this function does not match a
             * previous call to vTaskSuspendAll(). */
            configASSERT( uxSchedulerSuspended != 0U );

            uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended - 1U );
     73e:	4b6d      	ldr	r3, [pc, #436]	@ (8f4 <xTaskResumeAll+0x1cc>)
     740:	681b      	ldr	r3, [r3, #0]
     742:	3b01      	subs	r3, #1
     744:	4a6b      	ldr	r2, [pc, #428]	@ (8f4 <xTaskResumeAll+0x1cc>)
     746:	6013      	str	r3, [r2, #0]
            portRELEASE_TASK_LOCK( xCoreID );

            if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
     748:	4b6a      	ldr	r3, [pc, #424]	@ (8f4 <xTaskResumeAll+0x1cc>)
     74a:	681b      	ldr	r3, [r3, #0]
     74c:	2b00      	cmp	r3, #0
     74e:	f040 80ca 	bne.w	8e6 <xTaskResumeAll+0x1be>
            {
                if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     752:	4b69      	ldr	r3, [pc, #420]	@ (8f8 <xTaskResumeAll+0x1d0>)
     754:	681b      	ldr	r3, [r3, #0]
     756:	2b00      	cmp	r3, #0
     758:	f000 80c5 	beq.w	8e6 <xTaskResumeAll+0x1be>
                {
                    /* Move any readied tasks from the pending list into the
                     * appropriate ready list. */
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     75c:	e08e      	b.n	87c <xTaskResumeAll+0x154>
                    {
                        /* MISRA Ref 11.5.3 [Void pointer assignment] */
                        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
                        /* coverity[misra_c_2012_rule_11_5_violation] */
                        pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     75e:	4b67      	ldr	r3, [pc, #412]	@ (8fc <xTaskResumeAll+0x1d4>)
     760:	68db      	ldr	r3, [r3, #12]
     762:	68db      	ldr	r3, [r3, #12]
     764:	61fb      	str	r3, [r7, #28]
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
     766:	69fb      	ldr	r3, [r7, #28]
     768:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
     76a:	60fb      	str	r3, [r7, #12]
     76c:	69fb      	ldr	r3, [r7, #28]
     76e:	69db      	ldr	r3, [r3, #28]
     770:	69fa      	ldr	r2, [r7, #28]
     772:	6a12      	ldr	r2, [r2, #32]
     774:	609a      	str	r2, [r3, #8]
     776:	69fb      	ldr	r3, [r7, #28]
     778:	6a1b      	ldr	r3, [r3, #32]
     77a:	69fa      	ldr	r2, [r7, #28]
     77c:	69d2      	ldr	r2, [r2, #28]
     77e:	605a      	str	r2, [r3, #4]
     780:	68fb      	ldr	r3, [r7, #12]
     782:	685a      	ldr	r2, [r3, #4]
     784:	69fb      	ldr	r3, [r7, #28]
     786:	3318      	adds	r3, #24
     788:	429a      	cmp	r2, r3
     78a:	d103      	bne.n	794 <xTaskResumeAll+0x6c>
     78c:	69fb      	ldr	r3, [r7, #28]
     78e:	6a1a      	ldr	r2, [r3, #32]
     790:	68fb      	ldr	r3, [r7, #12]
     792:	605a      	str	r2, [r3, #4]
     794:	69fb      	ldr	r3, [r7, #28]
     796:	2200      	movs	r2, #0
     798:	629a      	str	r2, [r3, #40]	@ 0x28
     79a:	68fb      	ldr	r3, [r7, #12]
     79c:	681b      	ldr	r3, [r3, #0]
     79e:	1e5a      	subs	r2, r3, #1
     7a0:	68fb      	ldr	r3, [r7, #12]
     7a2:	601a      	str	r2, [r3, #0]
                        portMEMORY_BARRIER();
                        listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
     7a4:	69fb      	ldr	r3, [r7, #28]
     7a6:	695b      	ldr	r3, [r3, #20]
     7a8:	60bb      	str	r3, [r7, #8]
     7aa:	69fb      	ldr	r3, [r7, #28]
     7ac:	689b      	ldr	r3, [r3, #8]
     7ae:	69fa      	ldr	r2, [r7, #28]
     7b0:	68d2      	ldr	r2, [r2, #12]
     7b2:	609a      	str	r2, [r3, #8]
     7b4:	69fb      	ldr	r3, [r7, #28]
     7b6:	68db      	ldr	r3, [r3, #12]
     7b8:	69fa      	ldr	r2, [r7, #28]
     7ba:	6892      	ldr	r2, [r2, #8]
     7bc:	605a      	str	r2, [r3, #4]
     7be:	68bb      	ldr	r3, [r7, #8]
     7c0:	685a      	ldr	r2, [r3, #4]
     7c2:	69fb      	ldr	r3, [r7, #28]
     7c4:	3304      	adds	r3, #4
     7c6:	429a      	cmp	r2, r3
     7c8:	d103      	bne.n	7d2 <xTaskResumeAll+0xaa>
     7ca:	69fb      	ldr	r3, [r7, #28]
     7cc:	68da      	ldr	r2, [r3, #12]
     7ce:	68bb      	ldr	r3, [r7, #8]
     7d0:	605a      	str	r2, [r3, #4]
     7d2:	69fb      	ldr	r3, [r7, #28]
     7d4:	2200      	movs	r2, #0
     7d6:	615a      	str	r2, [r3, #20]
     7d8:	68bb      	ldr	r3, [r7, #8]
     7da:	681b      	ldr	r3, [r3, #0]
     7dc:	1e5a      	subs	r2, r3, #1
     7de:	68bb      	ldr	r3, [r7, #8]
     7e0:	601a      	str	r2, [r3, #0]
                        prvAddTaskToReadyList( pxTCB );
     7e2:	69fb      	ldr	r3, [r7, #28]
     7e4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
     7e6:	2201      	movs	r2, #1
     7e8:	409a      	lsls	r2, r3
     7ea:	4b45      	ldr	r3, [pc, #276]	@ (900 <xTaskResumeAll+0x1d8>)
     7ec:	681b      	ldr	r3, [r3, #0]
     7ee:	4313      	orrs	r3, r2
     7f0:	4a43      	ldr	r2, [pc, #268]	@ (900 <xTaskResumeAll+0x1d8>)
     7f2:	6013      	str	r3, [r2, #0]
     7f4:	69fb      	ldr	r3, [r7, #28]
     7f6:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     7f8:	4942      	ldr	r1, [pc, #264]	@ (904 <xTaskResumeAll+0x1dc>)
     7fa:	4613      	mov	r3, r2
     7fc:	009b      	lsls	r3, r3, #2
     7fe:	4413      	add	r3, r2
     800:	009b      	lsls	r3, r3, #2
     802:	440b      	add	r3, r1
     804:	3304      	adds	r3, #4
     806:	681b      	ldr	r3, [r3, #0]
     808:	607b      	str	r3, [r7, #4]
     80a:	69fb      	ldr	r3, [r7, #28]
     80c:	687a      	ldr	r2, [r7, #4]
     80e:	609a      	str	r2, [r3, #8]
     810:	687b      	ldr	r3, [r7, #4]
     812:	689a      	ldr	r2, [r3, #8]
     814:	69fb      	ldr	r3, [r7, #28]
     816:	60da      	str	r2, [r3, #12]
     818:	687b      	ldr	r3, [r7, #4]
     81a:	689b      	ldr	r3, [r3, #8]
     81c:	69fa      	ldr	r2, [r7, #28]
     81e:	3204      	adds	r2, #4
     820:	605a      	str	r2, [r3, #4]
     822:	69fb      	ldr	r3, [r7, #28]
     824:	1d1a      	adds	r2, r3, #4
     826:	687b      	ldr	r3, [r7, #4]
     828:	609a      	str	r2, [r3, #8]
     82a:	69fb      	ldr	r3, [r7, #28]
     82c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     82e:	4613      	mov	r3, r2
     830:	009b      	lsls	r3, r3, #2
     832:	4413      	add	r3, r2
     834:	009b      	lsls	r3, r3, #2
     836:	4a33      	ldr	r2, [pc, #204]	@ (904 <xTaskResumeAll+0x1dc>)
     838:	441a      	add	r2, r3
     83a:	69fb      	ldr	r3, [r7, #28]
     83c:	615a      	str	r2, [r3, #20]
     83e:	69fb      	ldr	r3, [r7, #28]
     840:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     842:	4930      	ldr	r1, [pc, #192]	@ (904 <xTaskResumeAll+0x1dc>)
     844:	4613      	mov	r3, r2
     846:	009b      	lsls	r3, r3, #2
     848:	4413      	add	r3, r2
     84a:	009b      	lsls	r3, r3, #2
     84c:	440b      	add	r3, r1
     84e:	681b      	ldr	r3, [r3, #0]
     850:	69fa      	ldr	r2, [r7, #28]
     852:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
     854:	1c59      	adds	r1, r3, #1
     856:	482b      	ldr	r0, [pc, #172]	@ (904 <xTaskResumeAll+0x1dc>)
     858:	4613      	mov	r3, r2
     85a:	009b      	lsls	r3, r3, #2
     85c:	4413      	add	r3, r2
     85e:	009b      	lsls	r3, r3, #2
     860:	4403      	add	r3, r0
     862:	6019      	str	r1, [r3, #0]

                        #if ( configNUMBER_OF_CORES == 1 )
                        {
                            /* If the moved task has a priority higher than the current
                             * task then a yield must be performed. */
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     864:	69fb      	ldr	r3, [r7, #28]
     866:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     868:	4b27      	ldr	r3, [pc, #156]	@ (908 <xTaskResumeAll+0x1e0>)
     86a:	681b      	ldr	r3, [r3, #0]
     86c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
     86e:	429a      	cmp	r2, r3
     870:	d904      	bls.n	87c <xTaskResumeAll+0x154>
                            {
                                xYieldPendings[ xCoreID ] = pdTRUE;
     872:	4a26      	ldr	r2, [pc, #152]	@ (90c <xTaskResumeAll+0x1e4>)
     874:	693b      	ldr	r3, [r7, #16]
     876:	2101      	movs	r1, #1
     878:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     87c:	4b1f      	ldr	r3, [pc, #124]	@ (8fc <xTaskResumeAll+0x1d4>)
     87e:	681b      	ldr	r3, [r3, #0]
     880:	2b00      	cmp	r3, #0
     882:	f47f af6c 	bne.w	75e <xTaskResumeAll+0x36>
                             * which sets xYieldPendings for the current core to pdTRUE. */
                        }
                        #endif /* #if ( configNUMBER_OF_CORES == 1 ) */
                    }

                    if( pxTCB != NULL )
     886:	69fb      	ldr	r3, [r7, #28]
     888:	2b00      	cmp	r3, #0
     88a:	d001      	beq.n	890 <xTaskResumeAll+0x168>
                         * which may have prevented the next unblock time from being
                         * re-calculated, in which case re-calculate it now.  Mainly
                         * important for low power tickless implementations, where
                         * this can prevent an unnecessary exit from low power
                         * state. */
                        prvResetNextTaskUnblockTime();
     88c:	f000 fc74 	bl	1178 <prvResetNextTaskUnblockTime>
                     * It should be safe to call xTaskIncrementTick here from any core
                     * since we are in a critical section and xTaskIncrementTick itself
                     * protects itself within a critical section. Suspending the scheduler
                     * from any core causes xTaskIncrementTick to increment uxPendedCounts. */
                    {
                        TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
     890:	4b1f      	ldr	r3, [pc, #124]	@ (910 <xTaskResumeAll+0x1e8>)
     892:	681b      	ldr	r3, [r3, #0]
     894:	617b      	str	r3, [r7, #20]

                        if( xPendedCounts > ( TickType_t ) 0U )
     896:	697b      	ldr	r3, [r7, #20]
     898:	2b00      	cmp	r3, #0
     89a:	d012      	beq.n	8c2 <xTaskResumeAll+0x19a>
                        {
                            do
                            {
                                if( xTaskIncrementTick() != pdFALSE )
     89c:	f000 f894 	bl	9c8 <xTaskIncrementTick>
     8a0:	4603      	mov	r3, r0
     8a2:	2b00      	cmp	r3, #0
     8a4:	d004      	beq.n	8b0 <xTaskResumeAll+0x188>
                                {
                                    /* Other cores are interrupted from
                                     * within xTaskIncrementTick(). */
                                    xYieldPendings[ xCoreID ] = pdTRUE;
     8a6:	4a19      	ldr	r2, [pc, #100]	@ (90c <xTaskResumeAll+0x1e4>)
     8a8:	693b      	ldr	r3, [r7, #16]
     8aa:	2101      	movs	r1, #1
     8ac:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                                else
                                {
                                    mtCOVERAGE_TEST_MARKER();
                                }

                                --xPendedCounts;
     8b0:	697b      	ldr	r3, [r7, #20]
     8b2:	3b01      	subs	r3, #1
     8b4:	617b      	str	r3, [r7, #20]
                            } while( xPendedCounts > ( TickType_t ) 0U );
     8b6:	697b      	ldr	r3, [r7, #20]
     8b8:	2b00      	cmp	r3, #0
     8ba:	d1ef      	bne.n	89c <xTaskResumeAll+0x174>

                            xPendedTicks = 0;
     8bc:	4b14      	ldr	r3, [pc, #80]	@ (910 <xTaskResumeAll+0x1e8>)
     8be:	2200      	movs	r2, #0
     8c0:	601a      	str	r2, [r3, #0]
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }

                    if( xYieldPendings[ xCoreID ] != pdFALSE )
     8c2:	4a12      	ldr	r2, [pc, #72]	@ (90c <xTaskResumeAll+0x1e4>)
     8c4:	693b      	ldr	r3, [r7, #16]
     8c6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
     8ca:	2b00      	cmp	r3, #0
     8cc:	d00b      	beq.n	8e6 <xTaskResumeAll+0x1be>
                    {
                        #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
     8ce:	2301      	movs	r3, #1
     8d0:	61bb      	str	r3, [r7, #24]
                        }
                        #endif /* #if ( configUSE_PREEMPTION != 0 ) */

                        #if ( configNUMBER_OF_CORES == 1 )
                        {
                            taskYIELD_TASK_CORE_IF_USING_PREEMPTION( pxCurrentTCB );
     8d2:	4b0d      	ldr	r3, [pc, #52]	@ (908 <xTaskResumeAll+0x1e0>)
     8d4:	681b      	ldr	r3, [r3, #0]
     8d6:	4b0f      	ldr	r3, [pc, #60]	@ (914 <xTaskResumeAll+0x1ec>)
     8d8:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
     8dc:	601a      	str	r2, [r3, #0]
     8de:	f3bf 8f4f 	dsb	sy
     8e2:	f3bf 8f6f 	isb	sy
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
     8e6:	f001 fd6d 	bl	23c4 <vPortExitCritical>
    }

    traceRETURN_xTaskResumeAll( xAlreadyYielded );

    return xAlreadyYielded;
     8ea:	69bb      	ldr	r3, [r7, #24]
}
     8ec:	4618      	mov	r0, r3
     8ee:	3720      	adds	r7, #32
     8f0:	46bd      	mov	sp, r7
     8f2:	bd80      	pop	{r7, pc}
     8f4:	200000d8 	ldrdcs	r0, [r0], -r8
     8f8:	200000b0 	strhcs	r0, [r0], -r0	@ <UNPREDICTABLE>
     8fc:	2000009c 	mulcs	r0, ip, r0
     900:	200000b8 	strhcs	r0, [r0], -r8
     904:	20000008 	andcs	r0, r0, r8
     908:	20000004 	andcs	r0, r0, r4
     90c:	200000c4 	andcs	r0, r0, r4, asr #1
     910:	200000c0 	andcs	r0, r0, r0, asr #1
     914:	e000ed04 	and	lr, r0, r4, lsl #26

00000918 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
     918:	b480      	push	{r7}
     91a:	b083      	sub	sp, #12
     91c:	af00      	add	r7, sp, #0
    traceENTER_xTaskGetTickCount();

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    {
        xTicks = xTickCount;
     91e:	4b04      	ldr	r3, [pc, #16]	@ (930 <xTaskGetTickCount+0x18>)
     920:	681b      	ldr	r3, [r3, #0]
     922:	607b      	str	r3, [r7, #4]
    }
    portTICK_TYPE_EXIT_CRITICAL();

    traceRETURN_xTaskGetTickCount( xTicks );

    return xTicks;
     924:	687b      	ldr	r3, [r7, #4]
}
     926:	4618      	mov	r0, r3
     928:	370c      	adds	r7, #12
     92a:	46bd      	mov	sp, r7
     92c:	bc80      	pop	{r7}
     92e:	4770      	bx	lr
     930:	200000b4 	strhcs	r0, [r0], -r4

00000934 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
     934:	b480      	push	{r7}
     936:	b083      	sub	sp, #12
     938:	af00      	add	r7, sp, #0
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
     93a:	2300      	movs	r3, #0
     93c:	607b      	str	r3, [r7, #4]
    {
        xReturn = xTickCount;
     93e:	4b04      	ldr	r3, [pc, #16]	@ (950 <xTaskGetTickCountFromISR+0x1c>)
     940:	681b      	ldr	r3, [r3, #0]
     942:	603b      	str	r3, [r7, #0]
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    traceRETURN_xTaskGetTickCountFromISR( xReturn );

    return xReturn;
     944:	683b      	ldr	r3, [r7, #0]
}
     946:	4618      	mov	r0, r3
     948:	370c      	adds	r7, #12
     94a:	46bd      	mov	sp, r7
     94c:	bc80      	pop	{r7}
     94e:	4770      	bx	lr
     950:	200000b4 	strhcs	r0, [r0], -r4

00000954 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
     954:	b480      	push	{r7}
     956:	af00      	add	r7, sp, #0

    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    traceRETURN_uxTaskGetNumberOfTasks( uxCurrentNumberOfTasks );

    return uxCurrentNumberOfTasks;
     958:	4b02      	ldr	r3, [pc, #8]	@ (964 <uxTaskGetNumberOfTasks+0x10>)
     95a:	681b      	ldr	r3, [r3, #0]
}
     95c:	4618      	mov	r0, r3
     95e:	46bd      	mov	sp, r7
     960:	bc80      	pop	{r7}
     962:	4770      	bx	lr
     964:	200000b0 	strhcs	r0, [r0], -r0	@ <UNPREDICTABLE>

00000968 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery )
{
     968:	b480      	push	{r7}
     96a:	b085      	sub	sp, #20
     96c:	af00      	add	r7, sp, #0
     96e:	6078      	str	r0, [r7, #4]

    traceENTER_pcTaskGetName( xTaskToQuery );

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     970:	687b      	ldr	r3, [r7, #4]
     972:	2b00      	cmp	r3, #0
     974:	d102      	bne.n	97c <pcTaskGetName+0x14>
     976:	4b06      	ldr	r3, [pc, #24]	@ (990 <pcTaskGetName+0x28>)
     978:	681b      	ldr	r3, [r3, #0]
     97a:	e000      	b.n	97e <pcTaskGetName+0x16>
     97c:	687b      	ldr	r3, [r7, #4]
     97e:	60fb      	str	r3, [r7, #12]
    configASSERT( pxTCB != NULL );

    traceRETURN_pcTaskGetName( &( pxTCB->pcTaskName[ 0 ] ) );

    return &( pxTCB->pcTaskName[ 0 ] );
     980:	68fb      	ldr	r3, [r7, #12]
     982:	3334      	adds	r3, #52	@ 0x34
}
     984:	4618      	mov	r0, r3
     986:	3714      	adds	r7, #20
     988:	46bd      	mov	sp, r7
     98a:	bc80      	pop	{r7}
     98c:	4770      	bx	lr
     98e:	bf00      	nop
     990:	20000004 	andcs	r0, r0, r4

00000994 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
     994:	b580      	push	{r7, lr}
     996:	b084      	sub	sp, #16
     998:	af00      	add	r7, sp, #0
     99a:	6078      	str	r0, [r7, #4]
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == ( UBaseType_t ) 0U );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
     99c:	f7ff feb6 	bl	70c <vTaskSuspendAll>

    /* Prevent the tick interrupt modifying xPendedTicks simultaneously. */
    taskENTER_CRITICAL();
     9a0:	f001 fcf6 	bl	2390 <vPortEnterCritical>
    {
        xPendedTicks += xTicksToCatchUp;
     9a4:	4b07      	ldr	r3, [pc, #28]	@ (9c4 <xTaskCatchUpTicks+0x30>)
     9a6:	681a      	ldr	r2, [r3, #0]
     9a8:	687b      	ldr	r3, [r7, #4]
     9aa:	4413      	add	r3, r2
     9ac:	4a05      	ldr	r2, [pc, #20]	@ (9c4 <xTaskCatchUpTicks+0x30>)
     9ae:	6013      	str	r3, [r2, #0]
    }
    taskEXIT_CRITICAL();
     9b0:	f001 fd08 	bl	23c4 <vPortExitCritical>
    xYieldOccurred = xTaskResumeAll();
     9b4:	f7ff feb8 	bl	728 <xTaskResumeAll>
     9b8:	60f8      	str	r0, [r7, #12]

    traceRETURN_xTaskCatchUpTicks( xYieldOccurred );

    return xYieldOccurred;
     9ba:	68fb      	ldr	r3, [r7, #12]
}
     9bc:	4618      	mov	r0, r3
     9be:	3710      	adds	r7, #16
     9c0:	46bd      	mov	sp, r7
     9c2:	bd80      	pop	{r7, pc}
     9c4:	200000c0 	andcs	r0, r0, r0, asr #1

000009c8 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     9c8:	b580      	push	{r7, lr}
     9ca:	b088      	sub	sp, #32
     9cc:	af00      	add	r7, sp, #0
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
     9ce:	2300      	movs	r3, #0
     9d0:	61fb      	str	r3, [r7, #28]

    /* Tick increment should occur on every kernel timer event. Core 0 has the
     * responsibility to increment the tick, or increment the pended ticks if the
     * scheduler is suspended.  If pended ticks is greater than zero, the core that
     * calls xTaskResumeAll has the responsibility to increment the tick. */
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
     9d2:	4b76      	ldr	r3, [pc, #472]	@ (bac <xTaskIncrementTick+0x1e4>)
     9d4:	681b      	ldr	r3, [r3, #0]
     9d6:	2b00      	cmp	r3, #0
     9d8:	f040 80de 	bne.w	b98 <xTaskIncrementTick+0x1d0>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     9dc:	4b74      	ldr	r3, [pc, #464]	@ (bb0 <xTaskIncrementTick+0x1e8>)
     9de:	681b      	ldr	r3, [r3, #0]
     9e0:	3301      	adds	r3, #1
     9e2:	61bb      	str	r3, [r7, #24]

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
     9e4:	4a72      	ldr	r2, [pc, #456]	@ (bb0 <xTaskIncrementTick+0x1e8>)
     9e6:	69bb      	ldr	r3, [r7, #24]
     9e8:	6013      	str	r3, [r2, #0]

        if( xConstTickCount == ( TickType_t ) 0U )
     9ea:	69bb      	ldr	r3, [r7, #24]
     9ec:	2b00      	cmp	r3, #0
     9ee:	d110      	bne.n	a12 <xTaskIncrementTick+0x4a>
        {
            taskSWITCH_DELAYED_LISTS();
     9f0:	4b70      	ldr	r3, [pc, #448]	@ (bb4 <xTaskIncrementTick+0x1ec>)
     9f2:	681b      	ldr	r3, [r3, #0]
     9f4:	617b      	str	r3, [r7, #20]
     9f6:	4b70      	ldr	r3, [pc, #448]	@ (bb8 <xTaskIncrementTick+0x1f0>)
     9f8:	681b      	ldr	r3, [r3, #0]
     9fa:	4a6e      	ldr	r2, [pc, #440]	@ (bb4 <xTaskIncrementTick+0x1ec>)
     9fc:	6013      	str	r3, [r2, #0]
     9fe:	4a6e      	ldr	r2, [pc, #440]	@ (bb8 <xTaskIncrementTick+0x1f0>)
     a00:	697b      	ldr	r3, [r7, #20]
     a02:	6013      	str	r3, [r2, #0]
     a04:	4b6d      	ldr	r3, [pc, #436]	@ (bbc <xTaskIncrementTick+0x1f4>)
     a06:	681b      	ldr	r3, [r3, #0]
     a08:	3301      	adds	r3, #1
     a0a:	4a6c      	ldr	r2, [pc, #432]	@ (bbc <xTaskIncrementTick+0x1f4>)
     a0c:	6013      	str	r3, [r2, #0]
     a0e:	f000 fbb3 	bl	1178 <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
     a12:	4b6b      	ldr	r3, [pc, #428]	@ (bc0 <xTaskIncrementTick+0x1f8>)
     a14:	681b      	ldr	r3, [r3, #0]
     a16:	69ba      	ldr	r2, [r7, #24]
     a18:	429a      	cmp	r2, r3
     a1a:	f0c0 80a8 	bcc.w	b6e <xTaskIncrementTick+0x1a6>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     a1e:	4b65      	ldr	r3, [pc, #404]	@ (bb4 <xTaskIncrementTick+0x1ec>)
     a20:	681b      	ldr	r3, [r3, #0]
     a22:	681b      	ldr	r3, [r3, #0]
     a24:	2b00      	cmp	r3, #0
     a26:	d104      	bne.n	a32 <xTaskIncrementTick+0x6a>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY;
     a28:	4b65      	ldr	r3, [pc, #404]	@ (bc0 <xTaskIncrementTick+0x1f8>)
     a2a:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
     a2e:	601a      	str	r2, [r3, #0]
                    break;
     a30:	e09d      	b.n	b6e <xTaskIncrementTick+0x1a6>
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    /* MISRA Ref 11.5.3 [Void pointer assignment] */
                    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
                    /* coverity[misra_c_2012_rule_11_5_violation] */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     a32:	4b60      	ldr	r3, [pc, #384]	@ (bb4 <xTaskIncrementTick+0x1ec>)
     a34:	681b      	ldr	r3, [r3, #0]
     a36:	68db      	ldr	r3, [r3, #12]
     a38:	68db      	ldr	r3, [r3, #12]
     a3a:	613b      	str	r3, [r7, #16]
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     a3c:	693b      	ldr	r3, [r7, #16]
     a3e:	685b      	ldr	r3, [r3, #4]
     a40:	60fb      	str	r3, [r7, #12]

                    if( xConstTickCount < xItemValue )
     a42:	69ba      	ldr	r2, [r7, #24]
     a44:	68fb      	ldr	r3, [r7, #12]
     a46:	429a      	cmp	r2, r3
     a48:	d203      	bcs.n	a52 <xTaskIncrementTick+0x8a>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
     a4a:	4a5d      	ldr	r2, [pc, #372]	@ (bc0 <xTaskIncrementTick+0x1f8>)
     a4c:	68fb      	ldr	r3, [r7, #12]
     a4e:	6013      	str	r3, [r2, #0]
                        break;
     a50:	e08d      	b.n	b6e <xTaskIncrementTick+0x1a6>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
     a52:	693b      	ldr	r3, [r7, #16]
     a54:	695b      	ldr	r3, [r3, #20]
     a56:	60bb      	str	r3, [r7, #8]
     a58:	693b      	ldr	r3, [r7, #16]
     a5a:	689b      	ldr	r3, [r3, #8]
     a5c:	693a      	ldr	r2, [r7, #16]
     a5e:	68d2      	ldr	r2, [r2, #12]
     a60:	609a      	str	r2, [r3, #8]
     a62:	693b      	ldr	r3, [r7, #16]
     a64:	68db      	ldr	r3, [r3, #12]
     a66:	693a      	ldr	r2, [r7, #16]
     a68:	6892      	ldr	r2, [r2, #8]
     a6a:	605a      	str	r2, [r3, #4]
     a6c:	68bb      	ldr	r3, [r7, #8]
     a6e:	685a      	ldr	r2, [r3, #4]
     a70:	693b      	ldr	r3, [r7, #16]
     a72:	3304      	adds	r3, #4
     a74:	429a      	cmp	r2, r3
     a76:	d103      	bne.n	a80 <xTaskIncrementTick+0xb8>
     a78:	693b      	ldr	r3, [r7, #16]
     a7a:	68da      	ldr	r2, [r3, #12]
     a7c:	68bb      	ldr	r3, [r7, #8]
     a7e:	605a      	str	r2, [r3, #4]
     a80:	693b      	ldr	r3, [r7, #16]
     a82:	2200      	movs	r2, #0
     a84:	615a      	str	r2, [r3, #20]
     a86:	68bb      	ldr	r3, [r7, #8]
     a88:	681b      	ldr	r3, [r3, #0]
     a8a:	1e5a      	subs	r2, r3, #1
     a8c:	68bb      	ldr	r3, [r7, #8]
     a8e:	601a      	str	r2, [r3, #0]

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     a90:	693b      	ldr	r3, [r7, #16]
     a92:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
     a94:	2b00      	cmp	r3, #0
     a96:	d01e      	beq.n	ad6 <xTaskIncrementTick+0x10e>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
     a98:	693b      	ldr	r3, [r7, #16]
     a9a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
     a9c:	607b      	str	r3, [r7, #4]
     a9e:	693b      	ldr	r3, [r7, #16]
     aa0:	69db      	ldr	r3, [r3, #28]
     aa2:	693a      	ldr	r2, [r7, #16]
     aa4:	6a12      	ldr	r2, [r2, #32]
     aa6:	609a      	str	r2, [r3, #8]
     aa8:	693b      	ldr	r3, [r7, #16]
     aaa:	6a1b      	ldr	r3, [r3, #32]
     aac:	693a      	ldr	r2, [r7, #16]
     aae:	69d2      	ldr	r2, [r2, #28]
     ab0:	605a      	str	r2, [r3, #4]
     ab2:	687b      	ldr	r3, [r7, #4]
     ab4:	685a      	ldr	r2, [r3, #4]
     ab6:	693b      	ldr	r3, [r7, #16]
     ab8:	3318      	adds	r3, #24
     aba:	429a      	cmp	r2, r3
     abc:	d103      	bne.n	ac6 <xTaskIncrementTick+0xfe>
     abe:	693b      	ldr	r3, [r7, #16]
     ac0:	6a1a      	ldr	r2, [r3, #32]
     ac2:	687b      	ldr	r3, [r7, #4]
     ac4:	605a      	str	r2, [r3, #4]
     ac6:	693b      	ldr	r3, [r7, #16]
     ac8:	2200      	movs	r2, #0
     aca:	629a      	str	r2, [r3, #40]	@ 0x28
     acc:	687b      	ldr	r3, [r7, #4]
     ace:	681b      	ldr	r3, [r3, #0]
     ad0:	1e5a      	subs	r2, r3, #1
     ad2:	687b      	ldr	r3, [r7, #4]
     ad4:	601a      	str	r2, [r3, #0]
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
     ad6:	693b      	ldr	r3, [r7, #16]
     ad8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
     ada:	2201      	movs	r2, #1
     adc:	409a      	lsls	r2, r3
     ade:	4b39      	ldr	r3, [pc, #228]	@ (bc4 <xTaskIncrementTick+0x1fc>)
     ae0:	681b      	ldr	r3, [r3, #0]
     ae2:	4313      	orrs	r3, r2
     ae4:	4a37      	ldr	r2, [pc, #220]	@ (bc4 <xTaskIncrementTick+0x1fc>)
     ae6:	6013      	str	r3, [r2, #0]
     ae8:	693b      	ldr	r3, [r7, #16]
     aea:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     aec:	4936      	ldr	r1, [pc, #216]	@ (bc8 <xTaskIncrementTick+0x200>)
     aee:	4613      	mov	r3, r2
     af0:	009b      	lsls	r3, r3, #2
     af2:	4413      	add	r3, r2
     af4:	009b      	lsls	r3, r3, #2
     af6:	440b      	add	r3, r1
     af8:	3304      	adds	r3, #4
     afa:	681b      	ldr	r3, [r3, #0]
     afc:	603b      	str	r3, [r7, #0]
     afe:	693b      	ldr	r3, [r7, #16]
     b00:	683a      	ldr	r2, [r7, #0]
     b02:	609a      	str	r2, [r3, #8]
     b04:	683b      	ldr	r3, [r7, #0]
     b06:	689a      	ldr	r2, [r3, #8]
     b08:	693b      	ldr	r3, [r7, #16]
     b0a:	60da      	str	r2, [r3, #12]
     b0c:	683b      	ldr	r3, [r7, #0]
     b0e:	689b      	ldr	r3, [r3, #8]
     b10:	693a      	ldr	r2, [r7, #16]
     b12:	3204      	adds	r2, #4
     b14:	605a      	str	r2, [r3, #4]
     b16:	693b      	ldr	r3, [r7, #16]
     b18:	1d1a      	adds	r2, r3, #4
     b1a:	683b      	ldr	r3, [r7, #0]
     b1c:	609a      	str	r2, [r3, #8]
     b1e:	693b      	ldr	r3, [r7, #16]
     b20:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     b22:	4613      	mov	r3, r2
     b24:	009b      	lsls	r3, r3, #2
     b26:	4413      	add	r3, r2
     b28:	009b      	lsls	r3, r3, #2
     b2a:	4a27      	ldr	r2, [pc, #156]	@ (bc8 <xTaskIncrementTick+0x200>)
     b2c:	441a      	add	r2, r3
     b2e:	693b      	ldr	r3, [r7, #16]
     b30:	615a      	str	r2, [r3, #20]
     b32:	693b      	ldr	r3, [r7, #16]
     b34:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     b36:	4924      	ldr	r1, [pc, #144]	@ (bc8 <xTaskIncrementTick+0x200>)
     b38:	4613      	mov	r3, r2
     b3a:	009b      	lsls	r3, r3, #2
     b3c:	4413      	add	r3, r2
     b3e:	009b      	lsls	r3, r3, #2
     b40:	440b      	add	r3, r1
     b42:	681b      	ldr	r3, [r3, #0]
     b44:	693a      	ldr	r2, [r7, #16]
     b46:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
     b48:	1c59      	adds	r1, r3, #1
     b4a:	481f      	ldr	r0, [pc, #124]	@ (bc8 <xTaskIncrementTick+0x200>)
     b4c:	4613      	mov	r3, r2
     b4e:	009b      	lsls	r3, r3, #2
     b50:	4413      	add	r3, r2
     b52:	009b      	lsls	r3, r3, #2
     b54:	4403      	add	r3, r0
     b56:	6019      	str	r1, [r3, #0]
                             * task.
                             * The case of equal priority tasks sharing
                             * processing time (which happens when both
                             * preemption and time slicing are on) is
                             * handled below.*/
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     b58:	693b      	ldr	r3, [r7, #16]
     b5a:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     b5c:	4b1b      	ldr	r3, [pc, #108]	@ (bcc <xTaskIncrementTick+0x204>)
     b5e:	681b      	ldr	r3, [r3, #0]
     b60:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
     b62:	429a      	cmp	r2, r3
     b64:	f67f af5b 	bls.w	a1e <xTaskIncrementTick+0x56>
                            {
                                xSwitchRequired = pdTRUE;
     b68:	2301      	movs	r3, #1
     b6a:	61fb      	str	r3, [r7, #28]
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     b6c:	e757      	b.n	a1e <xTaskIncrementTick+0x56>
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
        {
            #if ( configNUMBER_OF_CORES == 1 )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > 1U )
     b6e:	4b17      	ldr	r3, [pc, #92]	@ (bcc <xTaskIncrementTick+0x204>)
     b70:	681b      	ldr	r3, [r3, #0]
     b72:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     b74:	4914      	ldr	r1, [pc, #80]	@ (bc8 <xTaskIncrementTick+0x200>)
     b76:	4613      	mov	r3, r2
     b78:	009b      	lsls	r3, r3, #2
     b7a:	4413      	add	r3, r2
     b7c:	009b      	lsls	r3, r3, #2
     b7e:	440b      	add	r3, r1
     b80:	681b      	ldr	r3, [r3, #0]
     b82:	2b01      	cmp	r3, #1
     b84:	d901      	bls.n	b8a <xTaskIncrementTick+0x1c2>
                {
                    xSwitchRequired = pdTRUE;
     b86:	2301      	movs	r3, #1
     b88:	61fb      	str	r3, [r7, #28]
        #if ( configUSE_PREEMPTION == 1 )
        {
            #if ( configNUMBER_OF_CORES == 1 )
            {
                /* For single core the core ID is always 0. */
                if( xYieldPendings[ 0 ] != pdFALSE )
     b8a:	4b11      	ldr	r3, [pc, #68]	@ (bd0 <xTaskIncrementTick+0x208>)
     b8c:	681b      	ldr	r3, [r3, #0]
     b8e:	2b00      	cmp	r3, #0
     b90:	d007      	beq.n	ba2 <xTaskIncrementTick+0x1da>
                {
                    xSwitchRequired = pdTRUE;
     b92:	2301      	movs	r3, #1
     b94:	61fb      	str	r3, [r7, #28]
     b96:	e004      	b.n	ba2 <xTaskIncrementTick+0x1da>
        }
        #endif /* #if ( configUSE_PREEMPTION == 1 ) */
    }
    else
    {
        xPendedTicks += 1U;
     b98:	4b0e      	ldr	r3, [pc, #56]	@ (bd4 <xTaskIncrementTick+0x20c>)
     b9a:	681b      	ldr	r3, [r3, #0]
     b9c:	3301      	adds	r3, #1
     b9e:	4a0d      	ldr	r2, [pc, #52]	@ (bd4 <xTaskIncrementTick+0x20c>)
     ba0:	6013      	str	r3, [r2, #0]
        #endif
    }

    traceRETURN_xTaskIncrementTick( xSwitchRequired );

    return xSwitchRequired;
     ba2:	69fb      	ldr	r3, [r7, #28]
}
     ba4:	4618      	mov	r0, r3
     ba6:	3720      	adds	r7, #32
     ba8:	46bd      	mov	sp, r7
     baa:	bd80      	pop	{r7, pc}
     bac:	200000d8 	ldrdcs	r0, [r0], -r8
     bb0:	200000b4 	strhcs	r0, [r0], -r4
     bb4:	20000094 	mulcs	r0, r4, r0
     bb8:	20000098 	mulcs	r0, r8, r0
     bbc:	200000c8 	andcs	r0, r0, r8, asr #1
     bc0:	200000d0 	ldrdcs	r0, [r0], -r0	@ <UNPREDICTABLE>
     bc4:	200000b8 	strhcs	r0, [r0], -r8
     bc8:	20000008 	andcs	r0, r0, r8
     bcc:	20000004 	andcs	r0, r0, r4
     bd0:	200000c4 	andcs	r0, r0, r4, asr #1
     bd4:	200000c0 	andcs	r0, r0, r0, asr #1

00000bd8 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

#if ( configNUMBER_OF_CORES == 1 )
    void vTaskSwitchContext( void )
    {
     bd8:	b480      	push	{r7}
     bda:	b085      	sub	sp, #20
     bdc:	af00      	add	r7, sp, #0
        traceENTER_vTaskSwitchContext();

        if( uxSchedulerSuspended != ( UBaseType_t ) 0U )
     bde:	4b1c      	ldr	r3, [pc, #112]	@ (c50 <vTaskSwitchContext+0x78>)
     be0:	681b      	ldr	r3, [r3, #0]
     be2:	2b00      	cmp	r3, #0
     be4:	d003      	beq.n	bee <vTaskSwitchContext+0x16>
        {
            /* The scheduler is currently suspended - do not allow a context
             * switch. */
            xYieldPendings[ 0 ] = pdTRUE;
     be6:	4b1b      	ldr	r3, [pc, #108]	@ (c54 <vTaskSwitchContext+0x7c>)
     be8:	2201      	movs	r2, #1
     bea:	601a      	str	r2, [r3, #0]
            }
            #endif
        }

        traceRETURN_vTaskSwitchContext();
    }
     bec:	e02b      	b.n	c46 <vTaskSwitchContext+0x6e>
            xYieldPendings[ 0 ] = pdFALSE;
     bee:	4b19      	ldr	r3, [pc, #100]	@ (c54 <vTaskSwitchContext+0x7c>)
     bf0:	2200      	movs	r2, #0
     bf2:	601a      	str	r2, [r3, #0]
            taskSELECT_HIGHEST_PRIORITY_TASK();
     bf4:	4b18      	ldr	r3, [pc, #96]	@ (c58 <vTaskSwitchContext+0x80>)
     bf6:	681b      	ldr	r3, [r3, #0]
     bf8:	607b      	str	r3, [r7, #4]
        __asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
     bfa:	687b      	ldr	r3, [r7, #4]
     bfc:	fab3 f383 	clz	r3, r3
     c00:	70fb      	strb	r3, [r7, #3]
        return ucReturn;
     c02:	78fb      	ldrb	r3, [r7, #3]
     c04:	f1c3 031f 	rsb	r3, r3, #31
     c08:	60fb      	str	r3, [r7, #12]
     c0a:	68fa      	ldr	r2, [r7, #12]
     c0c:	4613      	mov	r3, r2
     c0e:	009b      	lsls	r3, r3, #2
     c10:	4413      	add	r3, r2
     c12:	009b      	lsls	r3, r3, #2
     c14:	4a11      	ldr	r2, [pc, #68]	@ (c5c <vTaskSwitchContext+0x84>)
     c16:	4413      	add	r3, r2
     c18:	60bb      	str	r3, [r7, #8]
     c1a:	68bb      	ldr	r3, [r7, #8]
     c1c:	685b      	ldr	r3, [r3, #4]
     c1e:	685a      	ldr	r2, [r3, #4]
     c20:	68bb      	ldr	r3, [r7, #8]
     c22:	605a      	str	r2, [r3, #4]
     c24:	68bb      	ldr	r3, [r7, #8]
     c26:	685a      	ldr	r2, [r3, #4]
     c28:	68bb      	ldr	r3, [r7, #8]
     c2a:	3308      	adds	r3, #8
     c2c:	429a      	cmp	r2, r3
     c2e:	d103      	bne.n	c38 <vTaskSwitchContext+0x60>
     c30:	68bb      	ldr	r3, [r7, #8]
     c32:	68da      	ldr	r2, [r3, #12]
     c34:	68bb      	ldr	r3, [r7, #8]
     c36:	605a      	str	r2, [r3, #4]
     c38:	68bb      	ldr	r3, [r7, #8]
     c3a:	685b      	ldr	r3, [r3, #4]
     c3c:	68db      	ldr	r3, [r3, #12]
     c3e:	4a08      	ldr	r2, [pc, #32]	@ (c60 <vTaskSwitchContext+0x88>)
     c40:	6013      	str	r3, [r2, #0]
            portTASK_SWITCH_HOOK( pxCurrentTCB );
     c42:	4b07      	ldr	r3, [pc, #28]	@ (c60 <vTaskSwitchContext+0x88>)
     c44:	681b      	ldr	r3, [r3, #0]
    }
     c46:	bf00      	nop
     c48:	3714      	adds	r7, #20
     c4a:	46bd      	mov	sp, r7
     c4c:	bc80      	pop	{r7}
     c4e:	4770      	bx	lr
     c50:	200000d8 	ldrdcs	r0, [r0], -r8
     c54:	200000c4 	andcs	r0, r0, r4, asr #1
     c58:	200000b8 	strhcs	r0, [r0], -r8
     c5c:	20000008 	andcs	r0, r0, r8
     c60:	20000004 	andcs	r0, r0, r4

00000c64 <vTaskPlaceOnEventList>:
#endif /* if ( configNUMBER_OF_CORES > 1 ) */
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
     c64:	b580      	push	{r7, lr}
     c66:	b082      	sub	sp, #8
     c68:	af00      	add	r7, sp, #0
     c6a:	6078      	str	r0, [r7, #4]
     c6c:	6039      	str	r1, [r7, #0]
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     c6e:	4b07      	ldr	r3, [pc, #28]	@ (c8c <vTaskPlaceOnEventList+0x28>)
     c70:	681b      	ldr	r3, [r3, #0]
     c72:	3318      	adds	r3, #24
     c74:	4619      	mov	r1, r3
     c76:	6878      	ldr	r0, [r7, #4]
     c78:	f001 f818 	bl	1cac <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     c7c:	2101      	movs	r1, #1
     c7e:	6838      	ldr	r0, [r7, #0]
     c80:	f000 ff26 	bl	1ad0 <prvAddCurrentTaskToDelayedList>

    traceRETURN_vTaskPlaceOnEventList();
}
     c84:	bf00      	nop
     c86:	3708      	adds	r7, #8
     c88:	46bd      	mov	sp, r7
     c8a:	bd80      	pop	{r7, pc}
     c8c:	20000004 	andcs	r0, r0, r4

00000c90 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
     c90:	b580      	push	{r7, lr}
     c92:	b086      	sub	sp, #24
     c94:	af00      	add	r7, sp, #0
     c96:	60f8      	str	r0, [r7, #12]
     c98:	60b9      	str	r1, [r7, #8]
     c9a:	607a      	str	r2, [r7, #4]
    configASSERT( uxSchedulerSuspended != ( UBaseType_t ) 0U );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     c9c:	4b17      	ldr	r3, [pc, #92]	@ (cfc <vTaskPlaceOnUnorderedEventList+0x6c>)
     c9e:	681b      	ldr	r3, [r3, #0]
     ca0:	68ba      	ldr	r2, [r7, #8]
     ca2:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
     ca6:	619a      	str	r2, [r3, #24]
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     ca8:	68fb      	ldr	r3, [r7, #12]
     caa:	685b      	ldr	r3, [r3, #4]
     cac:	617b      	str	r3, [r7, #20]
     cae:	4b13      	ldr	r3, [pc, #76]	@ (cfc <vTaskPlaceOnUnorderedEventList+0x6c>)
     cb0:	681b      	ldr	r3, [r3, #0]
     cb2:	697a      	ldr	r2, [r7, #20]
     cb4:	61da      	str	r2, [r3, #28]
     cb6:	4b11      	ldr	r3, [pc, #68]	@ (cfc <vTaskPlaceOnUnorderedEventList+0x6c>)
     cb8:	681b      	ldr	r3, [r3, #0]
     cba:	697a      	ldr	r2, [r7, #20]
     cbc:	6892      	ldr	r2, [r2, #8]
     cbe:	621a      	str	r2, [r3, #32]
     cc0:	4b0e      	ldr	r3, [pc, #56]	@ (cfc <vTaskPlaceOnUnorderedEventList+0x6c>)
     cc2:	681a      	ldr	r2, [r3, #0]
     cc4:	697b      	ldr	r3, [r7, #20]
     cc6:	689b      	ldr	r3, [r3, #8]
     cc8:	3218      	adds	r2, #24
     cca:	605a      	str	r2, [r3, #4]
     ccc:	4b0b      	ldr	r3, [pc, #44]	@ (cfc <vTaskPlaceOnUnorderedEventList+0x6c>)
     cce:	681b      	ldr	r3, [r3, #0]
     cd0:	f103 0218 	add.w	r2, r3, #24
     cd4:	697b      	ldr	r3, [r7, #20]
     cd6:	609a      	str	r2, [r3, #8]
     cd8:	4b08      	ldr	r3, [pc, #32]	@ (cfc <vTaskPlaceOnUnorderedEventList+0x6c>)
     cda:	681b      	ldr	r3, [r3, #0]
     cdc:	68fa      	ldr	r2, [r7, #12]
     cde:	629a      	str	r2, [r3, #40]	@ 0x28
     ce0:	68fb      	ldr	r3, [r7, #12]
     ce2:	681b      	ldr	r3, [r3, #0]
     ce4:	1c5a      	adds	r2, r3, #1
     ce6:	68fb      	ldr	r3, [r7, #12]
     ce8:	601a      	str	r2, [r3, #0]

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     cea:	2101      	movs	r1, #1
     cec:	6878      	ldr	r0, [r7, #4]
     cee:	f000 feef 	bl	1ad0 <prvAddCurrentTaskToDelayedList>

    traceRETURN_vTaskPlaceOnUnorderedEventList();
}
     cf2:	bf00      	nop
     cf4:	3718      	adds	r7, #24
     cf6:	46bd      	mov	sp, r7
     cf8:	bd80      	pop	{r7, pc}
     cfa:	bf00      	nop
     cfc:	20000004 	andcs	r0, r0, r4

00000d00 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
     d00:	b480      	push	{r7}
     d02:	b089      	sub	sp, #36	@ 0x24
     d04:	af00      	add	r7, sp, #0
     d06:	6078      	str	r0, [r7, #4]
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    /* MISRA Ref 11.5.3 [Void pointer assignment] */
    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
    /* coverity[misra_c_2012_rule_11_5_violation] */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     d08:	687b      	ldr	r3, [r7, #4]
     d0a:	68db      	ldr	r3, [r3, #12]
     d0c:	68db      	ldr	r3, [r3, #12]
     d0e:	61bb      	str	r3, [r7, #24]
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
     d10:	69bb      	ldr	r3, [r7, #24]
     d12:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
     d14:	617b      	str	r3, [r7, #20]
     d16:	69bb      	ldr	r3, [r7, #24]
     d18:	69db      	ldr	r3, [r3, #28]
     d1a:	69ba      	ldr	r2, [r7, #24]
     d1c:	6a12      	ldr	r2, [r2, #32]
     d1e:	609a      	str	r2, [r3, #8]
     d20:	69bb      	ldr	r3, [r7, #24]
     d22:	6a1b      	ldr	r3, [r3, #32]
     d24:	69ba      	ldr	r2, [r7, #24]
     d26:	69d2      	ldr	r2, [r2, #28]
     d28:	605a      	str	r2, [r3, #4]
     d2a:	697b      	ldr	r3, [r7, #20]
     d2c:	685a      	ldr	r2, [r3, #4]
     d2e:	69bb      	ldr	r3, [r7, #24]
     d30:	3318      	adds	r3, #24
     d32:	429a      	cmp	r2, r3
     d34:	d103      	bne.n	d3e <xTaskRemoveFromEventList+0x3e>
     d36:	69bb      	ldr	r3, [r7, #24]
     d38:	6a1a      	ldr	r2, [r3, #32]
     d3a:	697b      	ldr	r3, [r7, #20]
     d3c:	605a      	str	r2, [r3, #4]
     d3e:	69bb      	ldr	r3, [r7, #24]
     d40:	2200      	movs	r2, #0
     d42:	629a      	str	r2, [r3, #40]	@ 0x28
     d44:	697b      	ldr	r3, [r7, #20]
     d46:	681b      	ldr	r3, [r3, #0]
     d48:	1e5a      	subs	r2, r3, #1
     d4a:	697b      	ldr	r3, [r7, #20]
     d4c:	601a      	str	r2, [r3, #0]

    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
     d4e:	4b4b      	ldr	r3, [pc, #300]	@ (e7c <xTaskRemoveFromEventList+0x17c>)
     d50:	681b      	ldr	r3, [r3, #0]
     d52:	2b00      	cmp	r3, #0
     d54:	d160      	bne.n	e18 <xTaskRemoveFromEventList+0x118>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
     d56:	69bb      	ldr	r3, [r7, #24]
     d58:	695b      	ldr	r3, [r3, #20]
     d5a:	60fb      	str	r3, [r7, #12]
     d5c:	69bb      	ldr	r3, [r7, #24]
     d5e:	689b      	ldr	r3, [r3, #8]
     d60:	69ba      	ldr	r2, [r7, #24]
     d62:	68d2      	ldr	r2, [r2, #12]
     d64:	609a      	str	r2, [r3, #8]
     d66:	69bb      	ldr	r3, [r7, #24]
     d68:	68db      	ldr	r3, [r3, #12]
     d6a:	69ba      	ldr	r2, [r7, #24]
     d6c:	6892      	ldr	r2, [r2, #8]
     d6e:	605a      	str	r2, [r3, #4]
     d70:	68fb      	ldr	r3, [r7, #12]
     d72:	685a      	ldr	r2, [r3, #4]
     d74:	69bb      	ldr	r3, [r7, #24]
     d76:	3304      	adds	r3, #4
     d78:	429a      	cmp	r2, r3
     d7a:	d103      	bne.n	d84 <xTaskRemoveFromEventList+0x84>
     d7c:	69bb      	ldr	r3, [r7, #24]
     d7e:	68da      	ldr	r2, [r3, #12]
     d80:	68fb      	ldr	r3, [r7, #12]
     d82:	605a      	str	r2, [r3, #4]
     d84:	69bb      	ldr	r3, [r7, #24]
     d86:	2200      	movs	r2, #0
     d88:	615a      	str	r2, [r3, #20]
     d8a:	68fb      	ldr	r3, [r7, #12]
     d8c:	681b      	ldr	r3, [r3, #0]
     d8e:	1e5a      	subs	r2, r3, #1
     d90:	68fb      	ldr	r3, [r7, #12]
     d92:	601a      	str	r2, [r3, #0]
        prvAddTaskToReadyList( pxUnblockedTCB );
     d94:	69bb      	ldr	r3, [r7, #24]
     d96:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
     d98:	2201      	movs	r2, #1
     d9a:	409a      	lsls	r2, r3
     d9c:	4b38      	ldr	r3, [pc, #224]	@ (e80 <xTaskRemoveFromEventList+0x180>)
     d9e:	681b      	ldr	r3, [r3, #0]
     da0:	4313      	orrs	r3, r2
     da2:	4a37      	ldr	r2, [pc, #220]	@ (e80 <xTaskRemoveFromEventList+0x180>)
     da4:	6013      	str	r3, [r2, #0]
     da6:	69bb      	ldr	r3, [r7, #24]
     da8:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     daa:	4936      	ldr	r1, [pc, #216]	@ (e84 <xTaskRemoveFromEventList+0x184>)
     dac:	4613      	mov	r3, r2
     dae:	009b      	lsls	r3, r3, #2
     db0:	4413      	add	r3, r2
     db2:	009b      	lsls	r3, r3, #2
     db4:	440b      	add	r3, r1
     db6:	3304      	adds	r3, #4
     db8:	681b      	ldr	r3, [r3, #0]
     dba:	60bb      	str	r3, [r7, #8]
     dbc:	69bb      	ldr	r3, [r7, #24]
     dbe:	68ba      	ldr	r2, [r7, #8]
     dc0:	609a      	str	r2, [r3, #8]
     dc2:	68bb      	ldr	r3, [r7, #8]
     dc4:	689a      	ldr	r2, [r3, #8]
     dc6:	69bb      	ldr	r3, [r7, #24]
     dc8:	60da      	str	r2, [r3, #12]
     dca:	68bb      	ldr	r3, [r7, #8]
     dcc:	689b      	ldr	r3, [r3, #8]
     dce:	69ba      	ldr	r2, [r7, #24]
     dd0:	3204      	adds	r2, #4
     dd2:	605a      	str	r2, [r3, #4]
     dd4:	69bb      	ldr	r3, [r7, #24]
     dd6:	1d1a      	adds	r2, r3, #4
     dd8:	68bb      	ldr	r3, [r7, #8]
     dda:	609a      	str	r2, [r3, #8]
     ddc:	69bb      	ldr	r3, [r7, #24]
     dde:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     de0:	4613      	mov	r3, r2
     de2:	009b      	lsls	r3, r3, #2
     de4:	4413      	add	r3, r2
     de6:	009b      	lsls	r3, r3, #2
     de8:	4a26      	ldr	r2, [pc, #152]	@ (e84 <xTaskRemoveFromEventList+0x184>)
     dea:	441a      	add	r2, r3
     dec:	69bb      	ldr	r3, [r7, #24]
     dee:	615a      	str	r2, [r3, #20]
     df0:	69bb      	ldr	r3, [r7, #24]
     df2:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     df4:	4923      	ldr	r1, [pc, #140]	@ (e84 <xTaskRemoveFromEventList+0x184>)
     df6:	4613      	mov	r3, r2
     df8:	009b      	lsls	r3, r3, #2
     dfa:	4413      	add	r3, r2
     dfc:	009b      	lsls	r3, r3, #2
     dfe:	440b      	add	r3, r1
     e00:	681b      	ldr	r3, [r3, #0]
     e02:	69ba      	ldr	r2, [r7, #24]
     e04:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
     e06:	1c59      	adds	r1, r3, #1
     e08:	481e      	ldr	r0, [pc, #120]	@ (e84 <xTaskRemoveFromEventList+0x184>)
     e0a:	4613      	mov	r3, r2
     e0c:	009b      	lsls	r3, r3, #2
     e0e:	4413      	add	r3, r2
     e10:	009b      	lsls	r3, r3, #2
     e12:	4403      	add	r3, r0
     e14:	6019      	str	r1, [r3, #0]
     e16:	e01b      	b.n	e50 <xTaskRemoveFromEventList+0x150>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     e18:	4b1b      	ldr	r3, [pc, #108]	@ (e88 <xTaskRemoveFromEventList+0x188>)
     e1a:	685b      	ldr	r3, [r3, #4]
     e1c:	613b      	str	r3, [r7, #16]
     e1e:	69bb      	ldr	r3, [r7, #24]
     e20:	693a      	ldr	r2, [r7, #16]
     e22:	61da      	str	r2, [r3, #28]
     e24:	693b      	ldr	r3, [r7, #16]
     e26:	689a      	ldr	r2, [r3, #8]
     e28:	69bb      	ldr	r3, [r7, #24]
     e2a:	621a      	str	r2, [r3, #32]
     e2c:	693b      	ldr	r3, [r7, #16]
     e2e:	689b      	ldr	r3, [r3, #8]
     e30:	69ba      	ldr	r2, [r7, #24]
     e32:	3218      	adds	r2, #24
     e34:	605a      	str	r2, [r3, #4]
     e36:	69bb      	ldr	r3, [r7, #24]
     e38:	f103 0218 	add.w	r2, r3, #24
     e3c:	693b      	ldr	r3, [r7, #16]
     e3e:	609a      	str	r2, [r3, #8]
     e40:	69bb      	ldr	r3, [r7, #24]
     e42:	4a11      	ldr	r2, [pc, #68]	@ (e88 <xTaskRemoveFromEventList+0x188>)
     e44:	629a      	str	r2, [r3, #40]	@ 0x28
     e46:	4b10      	ldr	r3, [pc, #64]	@ (e88 <xTaskRemoveFromEventList+0x188>)
     e48:	681b      	ldr	r3, [r3, #0]
     e4a:	3301      	adds	r3, #1
     e4c:	4a0e      	ldr	r2, [pc, #56]	@ (e88 <xTaskRemoveFromEventList+0x188>)
     e4e:	6013      	str	r3, [r2, #0]
    }

    #if ( configNUMBER_OF_CORES == 1 )
    {
        if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     e50:	69bb      	ldr	r3, [r7, #24]
     e52:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     e54:	4b0d      	ldr	r3, [pc, #52]	@ (e8c <xTaskRemoveFromEventList+0x18c>)
     e56:	681b      	ldr	r3, [r3, #0]
     e58:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
     e5a:	429a      	cmp	r2, r3
     e5c:	d905      	bls.n	e6a <xTaskRemoveFromEventList+0x16a>
        {
            /* Return true if the task removed from the event list has a higher
             * priority than the calling task.  This allows the calling task to know if
             * it should force a context switch now. */
            xReturn = pdTRUE;
     e5e:	2301      	movs	r3, #1
     e60:	61fb      	str	r3, [r7, #28]

            /* Mark that a yield is pending in case the user is not using the
             * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
            xYieldPendings[ 0 ] = pdTRUE;
     e62:	4b0b      	ldr	r3, [pc, #44]	@ (e90 <xTaskRemoveFromEventList+0x190>)
     e64:	2201      	movs	r2, #1
     e66:	601a      	str	r2, [r3, #0]
     e68:	e001      	b.n	e6e <xTaskRemoveFromEventList+0x16e>
        }
        else
        {
            xReturn = pdFALSE;
     e6a:	2300      	movs	r3, #0
     e6c:	61fb      	str	r3, [r7, #28]
        #endif /* #if ( configUSE_PREEMPTION == 1 ) */
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    traceRETURN_xTaskRemoveFromEventList( xReturn );
    return xReturn;
     e6e:	69fb      	ldr	r3, [r7, #28]
}
     e70:	4618      	mov	r0, r3
     e72:	3724      	adds	r7, #36	@ 0x24
     e74:	46bd      	mov	sp, r7
     e76:	bc80      	pop	{r7}
     e78:	4770      	bx	lr
     e7a:	bf00      	nop
     e7c:	200000d8 	ldrdcs	r0, [r0], -r8
     e80:	200000b8 	strhcs	r0, [r0], -r8
     e84:	20000008 	andcs	r0, r0, r8
     e88:	2000009c 	mulcs	r0, ip, r0
     e8c:	20000004 	andcs	r0, r0, r4
     e90:	200000c4 	andcs	r0, r0, r4, asr #1

00000e94 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
     e94:	b480      	push	{r7}
     e96:	b087      	sub	sp, #28
     e98:	af00      	add	r7, sp, #0
     e9a:	6078      	str	r0, [r7, #4]
     e9c:	6039      	str	r1, [r7, #0]
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != ( UBaseType_t ) 0U );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     e9e:	683b      	ldr	r3, [r7, #0]
     ea0:	f043 4200 	orr.w	r2, r3, #2147483648	@ 0x80000000
     ea4:	687b      	ldr	r3, [r7, #4]
     ea6:	601a      	str	r2, [r3, #0]
    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    /* MISRA Ref 11.5.3 [Void pointer assignment] */
    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
    /* coverity[misra_c_2012_rule_11_5_violation] */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem );
     ea8:	687b      	ldr	r3, [r7, #4]
     eaa:	68db      	ldr	r3, [r3, #12]
     eac:	617b      	str	r3, [r7, #20]
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
     eae:	687b      	ldr	r3, [r7, #4]
     eb0:	691b      	ldr	r3, [r3, #16]
     eb2:	613b      	str	r3, [r7, #16]
     eb4:	687b      	ldr	r3, [r7, #4]
     eb6:	685b      	ldr	r3, [r3, #4]
     eb8:	687a      	ldr	r2, [r7, #4]
     eba:	6892      	ldr	r2, [r2, #8]
     ebc:	609a      	str	r2, [r3, #8]
     ebe:	687b      	ldr	r3, [r7, #4]
     ec0:	689b      	ldr	r3, [r3, #8]
     ec2:	687a      	ldr	r2, [r7, #4]
     ec4:	6852      	ldr	r2, [r2, #4]
     ec6:	605a      	str	r2, [r3, #4]
     ec8:	693b      	ldr	r3, [r7, #16]
     eca:	685b      	ldr	r3, [r3, #4]
     ecc:	687a      	ldr	r2, [r7, #4]
     ece:	429a      	cmp	r2, r3
     ed0:	d103      	bne.n	eda <vTaskRemoveFromUnorderedEventList+0x46>
     ed2:	687b      	ldr	r3, [r7, #4]
     ed4:	689a      	ldr	r2, [r3, #8]
     ed6:	693b      	ldr	r3, [r7, #16]
     ed8:	605a      	str	r2, [r3, #4]
     eda:	687b      	ldr	r3, [r7, #4]
     edc:	2200      	movs	r2, #0
     ede:	611a      	str	r2, [r3, #16]
     ee0:	693b      	ldr	r3, [r7, #16]
     ee2:	681b      	ldr	r3, [r3, #0]
     ee4:	1e5a      	subs	r2, r3, #1
     ee6:	693b      	ldr	r3, [r7, #16]
     ee8:	601a      	str	r2, [r3, #0]
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
     eea:	697b      	ldr	r3, [r7, #20]
     eec:	695b      	ldr	r3, [r3, #20]
     eee:	60fb      	str	r3, [r7, #12]
     ef0:	697b      	ldr	r3, [r7, #20]
     ef2:	689b      	ldr	r3, [r3, #8]
     ef4:	697a      	ldr	r2, [r7, #20]
     ef6:	68d2      	ldr	r2, [r2, #12]
     ef8:	609a      	str	r2, [r3, #8]
     efa:	697b      	ldr	r3, [r7, #20]
     efc:	68db      	ldr	r3, [r3, #12]
     efe:	697a      	ldr	r2, [r7, #20]
     f00:	6892      	ldr	r2, [r2, #8]
     f02:	605a      	str	r2, [r3, #4]
     f04:	68fb      	ldr	r3, [r7, #12]
     f06:	685a      	ldr	r2, [r3, #4]
     f08:	697b      	ldr	r3, [r7, #20]
     f0a:	3304      	adds	r3, #4
     f0c:	429a      	cmp	r2, r3
     f0e:	d103      	bne.n	f18 <vTaskRemoveFromUnorderedEventList+0x84>
     f10:	697b      	ldr	r3, [r7, #20]
     f12:	68da      	ldr	r2, [r3, #12]
     f14:	68fb      	ldr	r3, [r7, #12]
     f16:	605a      	str	r2, [r3, #4]
     f18:	697b      	ldr	r3, [r7, #20]
     f1a:	2200      	movs	r2, #0
     f1c:	615a      	str	r2, [r3, #20]
     f1e:	68fb      	ldr	r3, [r7, #12]
     f20:	681b      	ldr	r3, [r3, #0]
     f22:	1e5a      	subs	r2, r3, #1
     f24:	68fb      	ldr	r3, [r7, #12]
     f26:	601a      	str	r2, [r3, #0]
    prvAddTaskToReadyList( pxUnblockedTCB );
     f28:	697b      	ldr	r3, [r7, #20]
     f2a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
     f2c:	2201      	movs	r2, #1
     f2e:	409a      	lsls	r2, r3
     f30:	4b25      	ldr	r3, [pc, #148]	@ (fc8 <vTaskRemoveFromUnorderedEventList+0x134>)
     f32:	681b      	ldr	r3, [r3, #0]
     f34:	4313      	orrs	r3, r2
     f36:	4a24      	ldr	r2, [pc, #144]	@ (fc8 <vTaskRemoveFromUnorderedEventList+0x134>)
     f38:	6013      	str	r3, [r2, #0]
     f3a:	697b      	ldr	r3, [r7, #20]
     f3c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     f3e:	4923      	ldr	r1, [pc, #140]	@ (fcc <vTaskRemoveFromUnorderedEventList+0x138>)
     f40:	4613      	mov	r3, r2
     f42:	009b      	lsls	r3, r3, #2
     f44:	4413      	add	r3, r2
     f46:	009b      	lsls	r3, r3, #2
     f48:	440b      	add	r3, r1
     f4a:	3304      	adds	r3, #4
     f4c:	681b      	ldr	r3, [r3, #0]
     f4e:	60bb      	str	r3, [r7, #8]
     f50:	697b      	ldr	r3, [r7, #20]
     f52:	68ba      	ldr	r2, [r7, #8]
     f54:	609a      	str	r2, [r3, #8]
     f56:	68bb      	ldr	r3, [r7, #8]
     f58:	689a      	ldr	r2, [r3, #8]
     f5a:	697b      	ldr	r3, [r7, #20]
     f5c:	60da      	str	r2, [r3, #12]
     f5e:	68bb      	ldr	r3, [r7, #8]
     f60:	689b      	ldr	r3, [r3, #8]
     f62:	697a      	ldr	r2, [r7, #20]
     f64:	3204      	adds	r2, #4
     f66:	605a      	str	r2, [r3, #4]
     f68:	697b      	ldr	r3, [r7, #20]
     f6a:	1d1a      	adds	r2, r3, #4
     f6c:	68bb      	ldr	r3, [r7, #8]
     f6e:	609a      	str	r2, [r3, #8]
     f70:	697b      	ldr	r3, [r7, #20]
     f72:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     f74:	4613      	mov	r3, r2
     f76:	009b      	lsls	r3, r3, #2
     f78:	4413      	add	r3, r2
     f7a:	009b      	lsls	r3, r3, #2
     f7c:	4a13      	ldr	r2, [pc, #76]	@ (fcc <vTaskRemoveFromUnorderedEventList+0x138>)
     f7e:	441a      	add	r2, r3
     f80:	697b      	ldr	r3, [r7, #20]
     f82:	615a      	str	r2, [r3, #20]
     f84:	697b      	ldr	r3, [r7, #20]
     f86:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     f88:	4910      	ldr	r1, [pc, #64]	@ (fcc <vTaskRemoveFromUnorderedEventList+0x138>)
     f8a:	4613      	mov	r3, r2
     f8c:	009b      	lsls	r3, r3, #2
     f8e:	4413      	add	r3, r2
     f90:	009b      	lsls	r3, r3, #2
     f92:	440b      	add	r3, r1
     f94:	681b      	ldr	r3, [r3, #0]
     f96:	697a      	ldr	r2, [r7, #20]
     f98:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
     f9a:	1c59      	adds	r1, r3, #1
     f9c:	480b      	ldr	r0, [pc, #44]	@ (fcc <vTaskRemoveFromUnorderedEventList+0x138>)
     f9e:	4613      	mov	r3, r2
     fa0:	009b      	lsls	r3, r3, #2
     fa2:	4413      	add	r3, r2
     fa4:	009b      	lsls	r3, r3, #2
     fa6:	4403      	add	r3, r0
     fa8:	6019      	str	r1, [r3, #0]

    #if ( configNUMBER_OF_CORES == 1 )
    {
        if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     faa:	697b      	ldr	r3, [r7, #20]
     fac:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     fae:	4b08      	ldr	r3, [pc, #32]	@ (fd0 <vTaskRemoveFromUnorderedEventList+0x13c>)
     fb0:	681b      	ldr	r3, [r3, #0]
     fb2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
     fb4:	429a      	cmp	r2, r3
     fb6:	d902      	bls.n	fbe <vTaskRemoveFromUnorderedEventList+0x12a>
        {
            /* The unblocked task has a priority above that of the calling task, so
             * a context switch is required.  This function is called with the
             * scheduler suspended so xYieldPending is set so the context switch
             * occurs immediately that the scheduler is resumed (unsuspended). */
            xYieldPendings[ 0 ] = pdTRUE;
     fb8:	4b06      	ldr	r3, [pc, #24]	@ (fd4 <vTaskRemoveFromUnorderedEventList+0x140>)
     fba:	2201      	movs	r2, #1
     fbc:	601a      	str	r2, [r3, #0]
        #endif
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    traceRETURN_vTaskRemoveFromUnorderedEventList();
}
     fbe:	bf00      	nop
     fc0:	371c      	adds	r7, #28
     fc2:	46bd      	mov	sp, r7
     fc4:	bc80      	pop	{r7}
     fc6:	4770      	bx	lr
     fc8:	200000b8 	strhcs	r0, [r0], -r8
     fcc:	20000008 	andcs	r0, r0, r8
     fd0:	20000004 	andcs	r0, r0, r4
     fd4:	200000c4 	andcs	r0, r0, r4, asr #1

00000fd8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
     fd8:	b580      	push	{r7, lr}
     fda:	b082      	sub	sp, #8
     fdc:	af00      	add	r7, sp, #0
     fde:	6078      	str	r0, [r7, #4]
    traceENTER_vTaskSetTimeOutState( pxTimeOut );

    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
     fe0:	f001 f9d6 	bl	2390 <vPortEnterCritical>
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
     fe4:	4b06      	ldr	r3, [pc, #24]	@ (1000 <vTaskSetTimeOutState+0x28>)
     fe6:	681a      	ldr	r2, [r3, #0]
     fe8:	687b      	ldr	r3, [r7, #4]
     fea:	601a      	str	r2, [r3, #0]
        pxTimeOut->xTimeOnEntering = xTickCount;
     fec:	4b05      	ldr	r3, [pc, #20]	@ (1004 <vTaskSetTimeOutState+0x2c>)
     fee:	681a      	ldr	r2, [r3, #0]
     ff0:	687b      	ldr	r3, [r7, #4]
     ff2:	605a      	str	r2, [r3, #4]
    }
    taskEXIT_CRITICAL();
     ff4:	f001 f9e6 	bl	23c4 <vPortExitCritical>

    traceRETURN_vTaskSetTimeOutState();
}
     ff8:	bf00      	nop
     ffa:	3708      	adds	r7, #8
     ffc:	46bd      	mov	sp, r7
     ffe:	bd80      	pop	{r7, pc}
    1000:	200000c8 	andcs	r0, r0, r8, asr #1
    1004:	200000b4 	strhcs	r0, [r0], -r4

00001008 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    1008:	b480      	push	{r7}
    100a:	b083      	sub	sp, #12
    100c:	af00      	add	r7, sp, #0
    100e:	6078      	str	r0, [r7, #4]
    traceENTER_vTaskInternalSetTimeOutState( pxTimeOut );

    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    1010:	4b06      	ldr	r3, [pc, #24]	@ (102c <vTaskInternalSetTimeOutState+0x24>)
    1012:	681a      	ldr	r2, [r3, #0]
    1014:	687b      	ldr	r3, [r7, #4]
    1016:	601a      	str	r2, [r3, #0]
    pxTimeOut->xTimeOnEntering = xTickCount;
    1018:	4b05      	ldr	r3, [pc, #20]	@ (1030 <vTaskInternalSetTimeOutState+0x28>)
    101a:	681a      	ldr	r2, [r3, #0]
    101c:	687b      	ldr	r3, [r7, #4]
    101e:	605a      	str	r2, [r3, #4]

    traceRETURN_vTaskInternalSetTimeOutState();
}
    1020:	bf00      	nop
    1022:	370c      	adds	r7, #12
    1024:	46bd      	mov	sp, r7
    1026:	bc80      	pop	{r7}
    1028:	4770      	bx	lr
    102a:	bf00      	nop
    102c:	200000c8 	andcs	r0, r0, r8, asr #1
    1030:	200000b4 	strhcs	r0, [r0], -r4

00001034 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    1034:	b580      	push	{r7, lr}
    1036:	b086      	sub	sp, #24
    1038:	af00      	add	r7, sp, #0
    103a:	6078      	str	r0, [r7, #4]
    103c:	6039      	str	r1, [r7, #0]
    traceENTER_xTaskCheckForTimeOut( pxTimeOut, pxTicksToWait );

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    103e:	f001 f9a7 	bl	2390 <vPortEnterCritical>
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    1042:	4b1b      	ldr	r3, [pc, #108]	@ (10b0 <xTaskCheckForTimeOut+0x7c>)
    1044:	681b      	ldr	r3, [r3, #0]
    1046:	613b      	str	r3, [r7, #16]
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    1048:	687b      	ldr	r3, [r7, #4]
    104a:	685b      	ldr	r3, [r3, #4]
    104c:	693a      	ldr	r2, [r7, #16]
    104e:	1ad3      	subs	r3, r2, r3
    1050:	60fb      	str	r3, [r7, #12]
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) )
    1052:	687b      	ldr	r3, [r7, #4]
    1054:	681a      	ldr	r2, [r3, #0]
    1056:	4b17      	ldr	r3, [pc, #92]	@ (10b4 <xTaskCheckForTimeOut+0x80>)
    1058:	681b      	ldr	r3, [r3, #0]
    105a:	429a      	cmp	r2, r3
    105c:	d00a      	beq.n	1074 <xTaskCheckForTimeOut+0x40>
    105e:	687b      	ldr	r3, [r7, #4]
    1060:	685b      	ldr	r3, [r3, #4]
    1062:	693a      	ldr	r2, [r7, #16]
    1064:	429a      	cmp	r2, r3
    1066:	d305      	bcc.n	1074 <xTaskCheckForTimeOut+0x40>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
    1068:	2301      	movs	r3, #1
    106a:	617b      	str	r3, [r7, #20]
            *pxTicksToWait = ( TickType_t ) 0;
    106c:	683b      	ldr	r3, [r7, #0]
    106e:	2200      	movs	r2, #0
    1070:	601a      	str	r2, [r3, #0]
    1072:	e015      	b.n	10a0 <xTaskCheckForTimeOut+0x6c>
        }
        else if( xElapsedTime < *pxTicksToWait )
    1074:	683b      	ldr	r3, [r7, #0]
    1076:	681b      	ldr	r3, [r3, #0]
    1078:	68fa      	ldr	r2, [r7, #12]
    107a:	429a      	cmp	r2, r3
    107c:	d20b      	bcs.n	1096 <xTaskCheckForTimeOut+0x62>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    107e:	683b      	ldr	r3, [r7, #0]
    1080:	681a      	ldr	r2, [r3, #0]
    1082:	68fb      	ldr	r3, [r7, #12]
    1084:	1ad2      	subs	r2, r2, r3
    1086:	683b      	ldr	r3, [r7, #0]
    1088:	601a      	str	r2, [r3, #0]
            vTaskInternalSetTimeOutState( pxTimeOut );
    108a:	6878      	ldr	r0, [r7, #4]
    108c:	f7ff ffbc 	bl	1008 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
    1090:	2300      	movs	r3, #0
    1092:	617b      	str	r3, [r7, #20]
    1094:	e004      	b.n	10a0 <xTaskCheckForTimeOut+0x6c>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    1096:	683b      	ldr	r3, [r7, #0]
    1098:	2200      	movs	r2, #0
    109a:	601a      	str	r2, [r3, #0]
            xReturn = pdTRUE;
    109c:	2301      	movs	r3, #1
    109e:	617b      	str	r3, [r7, #20]
        }
    }
    taskEXIT_CRITICAL();
    10a0:	f001 f990 	bl	23c4 <vPortExitCritical>

    traceRETURN_xTaskCheckForTimeOut( xReturn );

    return xReturn;
    10a4:	697b      	ldr	r3, [r7, #20]
}
    10a6:	4618      	mov	r0, r3
    10a8:	3718      	adds	r7, #24
    10aa:	46bd      	mov	sp, r7
    10ac:	bd80      	pop	{r7, pc}
    10ae:	bf00      	nop
    10b0:	200000b4 	strhcs	r0, [r0], -r4
    10b4:	200000c8 	andcs	r0, r0, r8, asr #1

000010b8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    10b8:	b480      	push	{r7}
    10ba:	af00      	add	r7, sp, #0
    traceENTER_vTaskMissedYield();

    /* Must be called from within a critical section. */
    xYieldPendings[ portGET_CORE_ID() ] = pdTRUE;
    10bc:	4b03      	ldr	r3, [pc, #12]	@ (10cc <vTaskMissedYield+0x14>)
    10be:	2201      	movs	r2, #1
    10c0:	601a      	str	r2, [r3, #0]

    traceRETURN_vTaskMissedYield();
}
    10c2:	bf00      	nop
    10c4:	46bd      	mov	sp, r7
    10c6:	bc80      	pop	{r7}
    10c8:	4770      	bx	lr
    10ca:	bf00      	nop
    10cc:	200000c4 	andcs	r0, r0, r4, asr #1

000010d0 <prvIdleTask>:
 * void prvIdleTask( void *pvParameters );
 *
 */

static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    10d0:	b580      	push	{r7, lr}
    10d2:	b082      	sub	sp, #8
    10d4:	af00      	add	r7, sp, #0
    10d6:	6078      	str	r0, [r7, #4]

    for( ; configCONTROL_INFINITE_LOOP(); )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
    10d8:	f000 f848 	bl	116c <prvCheckTasksWaitingTermination>
             * A critical region is not required here as we are just reading from
             * the list, and an occasional incorrect value will not matter.  If
             * the ready list at the idle priority contains one more task than the
             * number of idle tasks, which is equal to the configured numbers of cores
             * then a task other than the idle task is ready to execute. */
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) configNUMBER_OF_CORES )
    10dc:	4b06      	ldr	r3, [pc, #24]	@ (10f8 <prvIdleTask+0x28>)
    10de:	681b      	ldr	r3, [r3, #0]
    10e0:	2b01      	cmp	r3, #1
    10e2:	d9f9      	bls.n	10d8 <prvIdleTask+0x8>
            {
                taskYIELD();
    10e4:	4b05      	ldr	r3, [pc, #20]	@ (10fc <prvIdleTask+0x2c>)
    10e6:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
    10ea:	601a      	str	r2, [r3, #0]
    10ec:	f3bf 8f4f 	dsb	sy
    10f0:	f3bf 8f6f 	isb	sy
        prvCheckTasksWaitingTermination();
    10f4:	e7f0      	b.n	10d8 <prvIdleTask+0x8>
    10f6:	bf00      	nop
    10f8:	20000008 	andcs	r0, r0, r8
    10fc:	e000ed04 	and	lr, r0, r4, lsl #26

00001100 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    1100:	b580      	push	{r7, lr}
    1102:	b082      	sub	sp, #8
    1104:	af00      	add	r7, sp, #0
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    1106:	2300      	movs	r3, #0
    1108:	607b      	str	r3, [r7, #4]
    110a:	e00c      	b.n	1126 <prvInitialiseTaskLists+0x26>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    110c:	687a      	ldr	r2, [r7, #4]
    110e:	4613      	mov	r3, r2
    1110:	009b      	lsls	r3, r3, #2
    1112:	4413      	add	r3, r2
    1114:	009b      	lsls	r3, r3, #2
    1116:	4a0f      	ldr	r2, [pc, #60]	@ (1154 <prvInitialiseTaskLists+0x54>)
    1118:	4413      	add	r3, r2
    111a:	4618      	mov	r0, r3
    111c:	f000 fd78 	bl	1c10 <vListInitialise>
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    1120:	687b      	ldr	r3, [r7, #4]
    1122:	3301      	adds	r3, #1
    1124:	607b      	str	r3, [r7, #4]
    1126:	687b      	ldr	r3, [r7, #4]
    1128:	2b04      	cmp	r3, #4
    112a:	d9ef      	bls.n	110c <prvInitialiseTaskLists+0xc>
    }

    vListInitialise( &xDelayedTaskList1 );
    112c:	480a      	ldr	r0, [pc, #40]	@ (1158 <prvInitialiseTaskLists+0x58>)
    112e:	f000 fd6f 	bl	1c10 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    1132:	480a      	ldr	r0, [pc, #40]	@ (115c <prvInitialiseTaskLists+0x5c>)
    1134:	f000 fd6c 	bl	1c10 <vListInitialise>
    vListInitialise( &xPendingReadyList );
    1138:	4809      	ldr	r0, [pc, #36]	@ (1160 <prvInitialiseTaskLists+0x60>)
    113a:	f000 fd69 	bl	1c10 <vListInitialise>
    }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    113e:	4b09      	ldr	r3, [pc, #36]	@ (1164 <prvInitialiseTaskLists+0x64>)
    1140:	4a05      	ldr	r2, [pc, #20]	@ (1158 <prvInitialiseTaskLists+0x58>)
    1142:	601a      	str	r2, [r3, #0]
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1144:	4b08      	ldr	r3, [pc, #32]	@ (1168 <prvInitialiseTaskLists+0x68>)
    1146:	4a05      	ldr	r2, [pc, #20]	@ (115c <prvInitialiseTaskLists+0x5c>)
    1148:	601a      	str	r2, [r3, #0]
}
    114a:	bf00      	nop
    114c:	3708      	adds	r7, #8
    114e:	46bd      	mov	sp, r7
    1150:	bd80      	pop	{r7, pc}
    1152:	bf00      	nop
    1154:	20000008 	andcs	r0, r0, r8
    1158:	2000006c 	andcs	r0, r0, ip, rrx
    115c:	20000080 	andcs	r0, r0, r0, lsl #1
    1160:	2000009c 	mulcs	r0, ip, r0
    1164:	20000094 	mulcs	r0, r4, r0
    1168:	20000098 	mulcs	r0, r8, r0

0000116c <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    116c:	b480      	push	{r7}
    116e:	af00      	add	r7, sp, #0
            }
            #endif /* #if( configNUMBER_OF_CORES == 1 ) */
        }
    }
    #endif /* INCLUDE_vTaskDelete */
}
    1170:	bf00      	nop
    1172:	46bd      	mov	sp, r7
    1174:	bc80      	pop	{r7}
    1176:	4770      	bx	lr

00001178 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    1178:	b480      	push	{r7}
    117a:	af00      	add	r7, sp, #0
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    117c:	4b09      	ldr	r3, [pc, #36]	@ (11a4 <prvResetNextTaskUnblockTime+0x2c>)
    117e:	681b      	ldr	r3, [r3, #0]
    1180:	681b      	ldr	r3, [r3, #0]
    1182:	2b00      	cmp	r3, #0
    1184:	d104      	bne.n	1190 <prvResetNextTaskUnblockTime+0x18>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    1186:	4b08      	ldr	r3, [pc, #32]	@ (11a8 <prvResetNextTaskUnblockTime+0x30>)
    1188:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
    118c:	601a      	str	r2, [r3, #0]
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    }
}
    118e:	e005      	b.n	119c <prvResetNextTaskUnblockTime+0x24>
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    1190:	4b04      	ldr	r3, [pc, #16]	@ (11a4 <prvResetNextTaskUnblockTime+0x2c>)
    1192:	681b      	ldr	r3, [r3, #0]
    1194:	68db      	ldr	r3, [r3, #12]
    1196:	681b      	ldr	r3, [r3, #0]
    1198:	4a03      	ldr	r2, [pc, #12]	@ (11a8 <prvResetNextTaskUnblockTime+0x30>)
    119a:	6013      	str	r3, [r2, #0]
}
    119c:	bf00      	nop
    119e:	46bd      	mov	sp, r7
    11a0:	bc80      	pop	{r7}
    11a2:	4770      	bx	lr
    11a4:	20000094 	mulcs	r0, r4, r0
    11a8:	200000d0 	ldrdcs	r0, [r0], -r0	@ <UNPREDICTABLE>

000011ac <xTaskGetCurrentTaskHandle>:

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_RECURSIVE_MUTEXES == 1 ) ) || ( configNUMBER_OF_CORES > 1 )

    #if ( configNUMBER_OF_CORES == 1 )
        TaskHandle_t xTaskGetCurrentTaskHandle( void )
        {
    11ac:	b480      	push	{r7}
    11ae:	b083      	sub	sp, #12
    11b0:	af00      	add	r7, sp, #0
            traceENTER_xTaskGetCurrentTaskHandle();

            /* A critical section is not required as this is not called from
             * an interrupt and the current TCB will always be the same for any
             * individual execution thread. */
            xReturn = pxCurrentTCB;
    11b2:	4b04      	ldr	r3, [pc, #16]	@ (11c4 <xTaskGetCurrentTaskHandle+0x18>)
    11b4:	681b      	ldr	r3, [r3, #0]
    11b6:	607b      	str	r3, [r7, #4]

            traceRETURN_xTaskGetCurrentTaskHandle( xReturn );

            return xReturn;
    11b8:	687b      	ldr	r3, [r7, #4]
        }
    11ba:	4618      	mov	r0, r3
    11bc:	370c      	adds	r7, #12
    11be:	46bd      	mov	sp, r7
    11c0:	bc80      	pop	{r7}
    11c2:	4770      	bx	lr
    11c4:	20000004 	andcs	r0, r0, r4

000011c8 <xTaskGetCurrentTaskHandleForCore>:
            return xReturn;
        }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    TaskHandle_t xTaskGetCurrentTaskHandleForCore( BaseType_t xCoreID )
    {
    11c8:	b480      	push	{r7}
    11ca:	b085      	sub	sp, #20
    11cc:	af00      	add	r7, sp, #0
    11ce:	6078      	str	r0, [r7, #4]
        TaskHandle_t xReturn = NULL;
    11d0:	2300      	movs	r3, #0
    11d2:	60fb      	str	r3, [r7, #12]

        traceENTER_xTaskGetCurrentTaskHandleForCore( xCoreID );

        if( taskVALID_CORE_ID( xCoreID ) != pdFALSE )
    11d4:	687b      	ldr	r3, [r7, #4]
    11d6:	2b00      	cmp	r3, #0
    11d8:	db05      	blt.n	11e6 <xTaskGetCurrentTaskHandleForCore+0x1e>
    11da:	687b      	ldr	r3, [r7, #4]
    11dc:	2b00      	cmp	r3, #0
    11de:	dc02      	bgt.n	11e6 <xTaskGetCurrentTaskHandleForCore+0x1e>
        {
            #if ( configNUMBER_OF_CORES == 1 )
                xReturn = pxCurrentTCB;
    11e0:	4b04      	ldr	r3, [pc, #16]	@ (11f4 <xTaskGetCurrentTaskHandleForCore+0x2c>)
    11e2:	681b      	ldr	r3, [r3, #0]
    11e4:	60fb      	str	r3, [r7, #12]
            #endif /* #if ( configNUMBER_OF_CORES == 1 ) */
        }

        traceRETURN_xTaskGetCurrentTaskHandleForCore( xReturn );

        return xReturn;
    11e6:	68fb      	ldr	r3, [r7, #12]
    }
    11e8:	4618      	mov	r0, r3
    11ea:	3714      	adds	r7, #20
    11ec:	46bd      	mov	sp, r7
    11ee:	bc80      	pop	{r7}
    11f0:	4770      	bx	lr
    11f2:	bf00      	nop
    11f4:	20000004 	andcs	r0, r0, r4

000011f8 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    11f8:	b480      	push	{r7}
    11fa:	b083      	sub	sp, #12
    11fc:	af00      	add	r7, sp, #0
    TickType_t uxReturn;

    traceENTER_uxTaskResetEventItemValue();

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    11fe:	4b09      	ldr	r3, [pc, #36]	@ (1224 <uxTaskResetEventItemValue+0x2c>)
    1200:	681b      	ldr	r3, [r3, #0]
    1202:	699b      	ldr	r3, [r3, #24]
    1204:	607b      	str	r3, [r7, #4]

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) );
    1206:	4b07      	ldr	r3, [pc, #28]	@ (1224 <uxTaskResetEventItemValue+0x2c>)
    1208:	681b      	ldr	r3, [r3, #0]
    120a:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
    120c:	4b05      	ldr	r3, [pc, #20]	@ (1224 <uxTaskResetEventItemValue+0x2c>)
    120e:	681b      	ldr	r3, [r3, #0]
    1210:	f1c2 0205 	rsb	r2, r2, #5
    1214:	619a      	str	r2, [r3, #24]

    traceRETURN_uxTaskResetEventItemValue( uxReturn );

    return uxReturn;
    1216:	687b      	ldr	r3, [r7, #4]
}
    1218:	4618      	mov	r0, r3
    121a:	370c      	adds	r7, #12
    121c:	46bd      	mov	sp, r7
    121e:	bc80      	pop	{r7}
    1220:	4770      	bx	lr
    1222:	bf00      	nop
    1224:	20000004 	andcs	r0, r0, r4

00001228 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWaitOn,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    1228:	b580      	push	{r7, lr}
    122a:	b088      	sub	sp, #32
    122c:	af00      	add	r7, sp, #0
    122e:	60f8      	str	r0, [r7, #12]
    1230:	60b9      	str	r1, [r7, #8]
    1232:	607a      	str	r2, [r7, #4]
        uint32_t ulReturn;
        BaseType_t xAlreadyYielded, xShouldBlock = pdFALSE;
    1234:	2300      	movs	r3, #0
    1236:	61fb      	str	r3, [r7, #28]

        configASSERT( uxIndexToWaitOn < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If the notification count is zero, and if we are willing to wait for a
         * notification, then block the task and wait. */
        if( ( pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] == 0U ) && ( xTicksToWait > ( TickType_t ) 0 ) )
    1238:	4b35      	ldr	r3, [pc, #212]	@ (1310 <ulTaskGenericNotifyTake+0xe8>)
    123a:	681a      	ldr	r2, [r3, #0]
    123c:	68fb      	ldr	r3, [r7, #12]
    123e:	3310      	adds	r3, #16
    1240:	009b      	lsls	r3, r3, #2
    1242:	4413      	add	r3, r2
    1244:	685b      	ldr	r3, [r3, #4]
    1246:	2b00      	cmp	r3, #0
    1248:	d132      	bne.n	12b0 <ulTaskGenericNotifyTake+0x88>
    124a:	687b      	ldr	r3, [r7, #4]
    124c:	2b00      	cmp	r3, #0
    124e:	d02f      	beq.n	12b0 <ulTaskGenericNotifyTake+0x88>
        {
            /* We suspend the scheduler here as prvAddCurrentTaskToDelayedList is a
             * non-deterministic operation. */
            vTaskSuspendAll();
    1250:	f7ff fa5c 	bl	70c <vTaskSuspendAll>
            {
                /* We MUST enter a critical section to atomically check if a notification
                 * has occurred and set the flag to indicate that we are waiting for
                 * a notification. If we do not do so, a notification sent from an ISR
                 * will get lost. */
                taskENTER_CRITICAL();
    1254:	f001 f89c 	bl	2390 <vPortEnterCritical>
                {
                    /* Only block if the notification count is not already non-zero. */
                    if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] == 0U )
    1258:	4b2d      	ldr	r3, [pc, #180]	@ (1310 <ulTaskGenericNotifyTake+0xe8>)
    125a:	681a      	ldr	r2, [r3, #0]
    125c:	68fb      	ldr	r3, [r7, #12]
    125e:	3310      	adds	r3, #16
    1260:	009b      	lsls	r3, r3, #2
    1262:	4413      	add	r3, r2
    1264:	685b      	ldr	r3, [r3, #4]
    1266:	2b00      	cmp	r3, #0
    1268:	d108      	bne.n	127c <ulTaskGenericNotifyTake+0x54>
                    {
                        /* Mark this task as waiting for a notification. */
                        pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskWAITING_NOTIFICATION;
    126a:	4b29      	ldr	r3, [pc, #164]	@ (1310 <ulTaskGenericNotifyTake+0xe8>)
    126c:	681a      	ldr	r2, [r3, #0]
    126e:	68fb      	ldr	r3, [r7, #12]
    1270:	4413      	add	r3, r2
    1272:	3348      	adds	r3, #72	@ 0x48
    1274:	2201      	movs	r2, #1
    1276:	701a      	strb	r2, [r3, #0]

                        /* Arrange to wait for a notification. */
                        xShouldBlock = pdTRUE;
    1278:	2301      	movs	r3, #1
    127a:	61fb      	str	r3, [r7, #28]
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                taskEXIT_CRITICAL();
    127c:	f001 f8a2 	bl	23c4 <vPortExitCritical>

                /* We are now out of the critical section but the scheduler is still
                 * suspended, so we are safe to do non-deterministic operations such
                 * as prvAddCurrentTaskToDelayedList. */
                if( xShouldBlock == pdTRUE )
    1280:	69fb      	ldr	r3, [r7, #28]
    1282:	2b01      	cmp	r3, #1
    1284:	d103      	bne.n	128e <ulTaskGenericNotifyTake+0x66>
                {
                    traceTASK_NOTIFY_TAKE_BLOCK( uxIndexToWaitOn );
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1286:	2101      	movs	r1, #1
    1288:	6878      	ldr	r0, [r7, #4]
    128a:	f000 fc21 	bl	1ad0 <prvAddCurrentTaskToDelayedList>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            xAlreadyYielded = xTaskResumeAll();
    128e:	f7ff fa4b 	bl	728 <xTaskResumeAll>
    1292:	61b8      	str	r0, [r7, #24]

            /* Force a reschedule if xTaskResumeAll has not already done so. */
            if( ( xShouldBlock == pdTRUE ) && ( xAlreadyYielded == pdFALSE ) )
    1294:	69fb      	ldr	r3, [r7, #28]
    1296:	2b01      	cmp	r3, #1
    1298:	d10a      	bne.n	12b0 <ulTaskGenericNotifyTake+0x88>
    129a:	69bb      	ldr	r3, [r7, #24]
    129c:	2b00      	cmp	r3, #0
    129e:	d107      	bne.n	12b0 <ulTaskGenericNotifyTake+0x88>
            {
                taskYIELD_WITHIN_API();
    12a0:	4b1c      	ldr	r3, [pc, #112]	@ (1314 <ulTaskGenericNotifyTake+0xec>)
    12a2:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
    12a6:	601a      	str	r2, [r3, #0]
    12a8:	f3bf 8f4f 	dsb	sy
    12ac:	f3bf 8f6f 	isb	sy
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        taskENTER_CRITICAL();
    12b0:	f001 f86e 	bl	2390 <vPortEnterCritical>
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWaitOn );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ];
    12b4:	4b16      	ldr	r3, [pc, #88]	@ (1310 <ulTaskGenericNotifyTake+0xe8>)
    12b6:	681a      	ldr	r2, [r3, #0]
    12b8:	68fb      	ldr	r3, [r7, #12]
    12ba:	3310      	adds	r3, #16
    12bc:	009b      	lsls	r3, r3, #2
    12be:	4413      	add	r3, r2
    12c0:	685b      	ldr	r3, [r3, #4]
    12c2:	617b      	str	r3, [r7, #20]

            if( ulReturn != 0U )
    12c4:	697b      	ldr	r3, [r7, #20]
    12c6:	2b00      	cmp	r3, #0
    12c8:	d014      	beq.n	12f4 <ulTaskGenericNotifyTake+0xcc>
            {
                if( xClearCountOnExit != pdFALSE )
    12ca:	68bb      	ldr	r3, [r7, #8]
    12cc:	2b00      	cmp	r3, #0
    12ce:	d008      	beq.n	12e2 <ulTaskGenericNotifyTake+0xba>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] = ( uint32_t ) 0U;
    12d0:	4b0f      	ldr	r3, [pc, #60]	@ (1310 <ulTaskGenericNotifyTake+0xe8>)
    12d2:	681a      	ldr	r2, [r3, #0]
    12d4:	68fb      	ldr	r3, [r7, #12]
    12d6:	3310      	adds	r3, #16
    12d8:	009b      	lsls	r3, r3, #2
    12da:	4413      	add	r3, r2
    12dc:	2200      	movs	r2, #0
    12de:	605a      	str	r2, [r3, #4]
    12e0:	e008      	b.n	12f4 <ulTaskGenericNotifyTake+0xcc>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] = ulReturn - ( uint32_t ) 1;
    12e2:	4b0b      	ldr	r3, [pc, #44]	@ (1310 <ulTaskGenericNotifyTake+0xe8>)
    12e4:	6819      	ldr	r1, [r3, #0]
    12e6:	697b      	ldr	r3, [r7, #20]
    12e8:	1e5a      	subs	r2, r3, #1
    12ea:	68fb      	ldr	r3, [r7, #12]
    12ec:	3310      	adds	r3, #16
    12ee:	009b      	lsls	r3, r3, #2
    12f0:	440b      	add	r3, r1
    12f2:	605a      	str	r2, [r3, #4]
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskNOT_WAITING_NOTIFICATION;
    12f4:	4b06      	ldr	r3, [pc, #24]	@ (1310 <ulTaskGenericNotifyTake+0xe8>)
    12f6:	681a      	ldr	r2, [r3, #0]
    12f8:	68fb      	ldr	r3, [r7, #12]
    12fa:	4413      	add	r3, r2
    12fc:	3348      	adds	r3, #72	@ 0x48
    12fe:	2200      	movs	r2, #0
    1300:	701a      	strb	r2, [r3, #0]
        }
        taskEXIT_CRITICAL();
    1302:	f001 f85f 	bl	23c4 <vPortExitCritical>

        traceRETURN_ulTaskGenericNotifyTake( ulReturn );

        return ulReturn;
    1306:	697b      	ldr	r3, [r7, #20]
    }
    1308:	4618      	mov	r0, r3
    130a:	3720      	adds	r7, #32
    130c:	46bd      	mov	sp, r7
    130e:	bd80      	pop	{r7, pc}
    1310:	20000004 	andcs	r0, r0, r4
    1314:	e000ed04 	and	lr, r0, r4, lsl #26

00001318 <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWaitOn,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    1318:	b580      	push	{r7, lr}
    131a:	b088      	sub	sp, #32
    131c:	af00      	add	r7, sp, #0
    131e:	60f8      	str	r0, [r7, #12]
    1320:	60b9      	str	r1, [r7, #8]
    1322:	607a      	str	r2, [r7, #4]
    1324:	603b      	str	r3, [r7, #0]
        BaseType_t xReturn, xAlreadyYielded, xShouldBlock = pdFALSE;
    1326:	2300      	movs	r3, #0
    1328:	61bb      	str	r3, [r7, #24]

        configASSERT( uxIndexToWaitOn < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If the task hasn't received a notification, and if we are willing to wait
         * for it, then block the task and wait. */
        if( ( pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] != taskNOTIFICATION_RECEIVED ) && ( xTicksToWait > ( TickType_t ) 0 ) )
    132a:	4b42      	ldr	r3, [pc, #264]	@ (1434 <xTaskGenericNotifyWait+0x11c>)
    132c:	681a      	ldr	r2, [r3, #0]
    132e:	68fb      	ldr	r3, [r7, #12]
    1330:	4413      	add	r3, r2
    1332:	3348      	adds	r3, #72	@ 0x48
    1334:	781b      	ldrb	r3, [r3, #0]
    1336:	b2db      	uxtb	r3, r3
    1338:	2b02      	cmp	r3, #2
    133a:	d041      	beq.n	13c0 <xTaskGenericNotifyWait+0xa8>
    133c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    133e:	2b00      	cmp	r3, #0
    1340:	d03e      	beq.n	13c0 <xTaskGenericNotifyWait+0xa8>
        {
            /* We suspend the scheduler here as prvAddCurrentTaskToDelayedList is a
             * non-deterministic operation. */
            vTaskSuspendAll();
    1342:	f7ff f9e3 	bl	70c <vTaskSuspendAll>
            {
                /* We MUST enter a critical section to atomically check and update the
                 * task notification value. If we do not do so, a notification from
                 * an ISR will get lost. */
                taskENTER_CRITICAL();
    1346:	f001 f823 	bl	2390 <vPortEnterCritical>
                {
                    /* Only block if a notification is not already pending. */
                    if( pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] != taskNOTIFICATION_RECEIVED )
    134a:	4b3a      	ldr	r3, [pc, #232]	@ (1434 <xTaskGenericNotifyWait+0x11c>)
    134c:	681a      	ldr	r2, [r3, #0]
    134e:	68fb      	ldr	r3, [r7, #12]
    1350:	4413      	add	r3, r2
    1352:	3348      	adds	r3, #72	@ 0x48
    1354:	781b      	ldrb	r3, [r3, #0]
    1356:	b2db      	uxtb	r3, r3
    1358:	2b02      	cmp	r3, #2
    135a:	d017      	beq.n	138c <xTaskGenericNotifyWait+0x74>
                    {
                        /* Clear bits in the task's notification value as bits may get
                         * set by the notifying task or interrupt. This can be used
                         * to clear the value to zero. */
                        pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] &= ~ulBitsToClearOnEntry;
    135c:	4b35      	ldr	r3, [pc, #212]	@ (1434 <xTaskGenericNotifyWait+0x11c>)
    135e:	681a      	ldr	r2, [r3, #0]
    1360:	68fb      	ldr	r3, [r7, #12]
    1362:	3310      	adds	r3, #16
    1364:	009b      	lsls	r3, r3, #2
    1366:	4413      	add	r3, r2
    1368:	6859      	ldr	r1, [r3, #4]
    136a:	68bb      	ldr	r3, [r7, #8]
    136c:	43db      	mvns	r3, r3
    136e:	4019      	ands	r1, r3
    1370:	68fb      	ldr	r3, [r7, #12]
    1372:	3310      	adds	r3, #16
    1374:	009b      	lsls	r3, r3, #2
    1376:	4413      	add	r3, r2
    1378:	6059      	str	r1, [r3, #4]

                        /* Mark this task as waiting for a notification. */
                        pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskWAITING_NOTIFICATION;
    137a:	4b2e      	ldr	r3, [pc, #184]	@ (1434 <xTaskGenericNotifyWait+0x11c>)
    137c:	681a      	ldr	r2, [r3, #0]
    137e:	68fb      	ldr	r3, [r7, #12]
    1380:	4413      	add	r3, r2
    1382:	3348      	adds	r3, #72	@ 0x48
    1384:	2201      	movs	r2, #1
    1386:	701a      	strb	r2, [r3, #0]

                        /* Arrange to wait for a notification. */
                        xShouldBlock = pdTRUE;
    1388:	2301      	movs	r3, #1
    138a:	61bb      	str	r3, [r7, #24]
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                taskEXIT_CRITICAL();
    138c:	f001 f81a 	bl	23c4 <vPortExitCritical>

                /* We are now out of the critical section but the scheduler is still
                 * suspended, so we are safe to do non-deterministic operations such
                 * as prvAddCurrentTaskToDelayedList. */
                if( xShouldBlock == pdTRUE )
    1390:	69bb      	ldr	r3, [r7, #24]
    1392:	2b01      	cmp	r3, #1
    1394:	d103      	bne.n	139e <xTaskGenericNotifyWait+0x86>
                {
                    traceTASK_NOTIFY_WAIT_BLOCK( uxIndexToWaitOn );
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1396:	2101      	movs	r1, #1
    1398:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
    139a:	f000 fb99 	bl	1ad0 <prvAddCurrentTaskToDelayedList>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            xAlreadyYielded = xTaskResumeAll();
    139e:	f7ff f9c3 	bl	728 <xTaskResumeAll>
    13a2:	6178      	str	r0, [r7, #20]

            /* Force a reschedule if xTaskResumeAll has not already done so. */
            if( ( xShouldBlock == pdTRUE ) && ( xAlreadyYielded == pdFALSE ) )
    13a4:	69bb      	ldr	r3, [r7, #24]
    13a6:	2b01      	cmp	r3, #1
    13a8:	d10a      	bne.n	13c0 <xTaskGenericNotifyWait+0xa8>
    13aa:	697b      	ldr	r3, [r7, #20]
    13ac:	2b00      	cmp	r3, #0
    13ae:	d107      	bne.n	13c0 <xTaskGenericNotifyWait+0xa8>
            {
                taskYIELD_WITHIN_API();
    13b0:	4b21      	ldr	r3, [pc, #132]	@ (1438 <xTaskGenericNotifyWait+0x120>)
    13b2:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
    13b6:	601a      	str	r2, [r3, #0]
    13b8:	f3bf 8f4f 	dsb	sy
    13bc:	f3bf 8f6f 	isb	sy
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        taskENTER_CRITICAL();
    13c0:	f000 ffe6 	bl	2390 <vPortEnterCritical>
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWaitOn );

            if( pulNotificationValue != NULL )
    13c4:	683b      	ldr	r3, [r7, #0]
    13c6:	2b00      	cmp	r3, #0
    13c8:	d008      	beq.n	13dc <xTaskGenericNotifyWait+0xc4>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ];
    13ca:	4b1a      	ldr	r3, [pc, #104]	@ (1434 <xTaskGenericNotifyWait+0x11c>)
    13cc:	681a      	ldr	r2, [r3, #0]
    13ce:	68fb      	ldr	r3, [r7, #12]
    13d0:	3310      	adds	r3, #16
    13d2:	009b      	lsls	r3, r3, #2
    13d4:	4413      	add	r3, r2
    13d6:	685a      	ldr	r2, [r3, #4]
    13d8:	683b      	ldr	r3, [r7, #0]
    13da:	601a      	str	r2, [r3, #0]

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] != taskNOTIFICATION_RECEIVED )
    13dc:	4b15      	ldr	r3, [pc, #84]	@ (1434 <xTaskGenericNotifyWait+0x11c>)
    13de:	681a      	ldr	r2, [r3, #0]
    13e0:	68fb      	ldr	r3, [r7, #12]
    13e2:	4413      	add	r3, r2
    13e4:	3348      	adds	r3, #72	@ 0x48
    13e6:	781b      	ldrb	r3, [r3, #0]
    13e8:	b2db      	uxtb	r3, r3
    13ea:	2b02      	cmp	r3, #2
    13ec:	d002      	beq.n	13f4 <xTaskGenericNotifyWait+0xdc>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
    13ee:	2300      	movs	r3, #0
    13f0:	61fb      	str	r3, [r7, #28]
    13f2:	e010      	b.n	1416 <xTaskGenericNotifyWait+0xfe>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] &= ~ulBitsToClearOnExit;
    13f4:	4b0f      	ldr	r3, [pc, #60]	@ (1434 <xTaskGenericNotifyWait+0x11c>)
    13f6:	681a      	ldr	r2, [r3, #0]
    13f8:	68fb      	ldr	r3, [r7, #12]
    13fa:	3310      	adds	r3, #16
    13fc:	009b      	lsls	r3, r3, #2
    13fe:	4413      	add	r3, r2
    1400:	6859      	ldr	r1, [r3, #4]
    1402:	687b      	ldr	r3, [r7, #4]
    1404:	43db      	mvns	r3, r3
    1406:	4019      	ands	r1, r3
    1408:	68fb      	ldr	r3, [r7, #12]
    140a:	3310      	adds	r3, #16
    140c:	009b      	lsls	r3, r3, #2
    140e:	4413      	add	r3, r2
    1410:	6059      	str	r1, [r3, #4]
                xReturn = pdTRUE;
    1412:	2301      	movs	r3, #1
    1414:	61fb      	str	r3, [r7, #28]
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskNOT_WAITING_NOTIFICATION;
    1416:	4b07      	ldr	r3, [pc, #28]	@ (1434 <xTaskGenericNotifyWait+0x11c>)
    1418:	681a      	ldr	r2, [r3, #0]
    141a:	68fb      	ldr	r3, [r7, #12]
    141c:	4413      	add	r3, r2
    141e:	3348      	adds	r3, #72	@ 0x48
    1420:	2200      	movs	r2, #0
    1422:	701a      	strb	r2, [r3, #0]
        }
        taskEXIT_CRITICAL();
    1424:	f000 ffce 	bl	23c4 <vPortExitCritical>

        traceRETURN_xTaskGenericNotifyWait( xReturn );

        return xReturn;
    1428:	69fb      	ldr	r3, [r7, #28]
    }
    142a:	4618      	mov	r0, r3
    142c:	3720      	adds	r7, #32
    142e:	46bd      	mov	sp, r7
    1430:	bd80      	pop	{r7, pc}
    1432:	bf00      	nop
    1434:	20000004 	andcs	r0, r0, r4
    1438:	e000ed04 	and	lr, r0, r4, lsl #26

0000143c <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    143c:	b580      	push	{r7, lr}
    143e:	b08a      	sub	sp, #40	@ 0x28
    1440:	af00      	add	r7, sp, #0
    1442:	60f8      	str	r0, [r7, #12]
    1444:	60b9      	str	r1, [r7, #8]
    1446:	607a      	str	r2, [r7, #4]
    1448:	70fb      	strb	r3, [r7, #3]
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
    144a:	2301      	movs	r3, #1
    144c:	627b      	str	r3, [r7, #36]	@ 0x24

        traceENTER_xTaskGenericNotify( xTaskToNotify, uxIndexToNotify, ulValue, eAction, pulPreviousNotificationValue );

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
    144e:	68fb      	ldr	r3, [r7, #12]
    1450:	623b      	str	r3, [r7, #32]

        taskENTER_CRITICAL();
    1452:	f000 ff9d 	bl	2390 <vPortEnterCritical>
        {
            if( pulPreviousNotificationValue != NULL )
    1456:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    1458:	2b00      	cmp	r3, #0
    145a:	d007      	beq.n	146c <xTaskGenericNotify+0x30>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    145c:	6a3a      	ldr	r2, [r7, #32]
    145e:	68bb      	ldr	r3, [r7, #8]
    1460:	3310      	adds	r3, #16
    1462:	009b      	lsls	r3, r3, #2
    1464:	4413      	add	r3, r2
    1466:	685a      	ldr	r2, [r3, #4]
    1468:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    146a:	601a      	str	r2, [r3, #0]
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    146c:	6a3a      	ldr	r2, [r7, #32]
    146e:	68bb      	ldr	r3, [r7, #8]
    1470:	4413      	add	r3, r2
    1472:	3348      	adds	r3, #72	@ 0x48
    1474:	781b      	ldrb	r3, [r3, #0]
    1476:	77fb      	strb	r3, [r7, #31]

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    1478:	6a3a      	ldr	r2, [r7, #32]
    147a:	68bb      	ldr	r3, [r7, #8]
    147c:	4413      	add	r3, r2
    147e:	3348      	adds	r3, #72	@ 0x48
    1480:	2202      	movs	r2, #2
    1482:	701a      	strb	r2, [r3, #0]

            switch( eAction )
    1484:	78fb      	ldrb	r3, [r7, #3]
    1486:	2b04      	cmp	r3, #4
    1488:	d83f      	bhi.n	150a <xTaskGenericNotify+0xce>
    148a:	a201      	add	r2, pc, #4	@ (adr r2, 1490 <xTaskGenericNotify+0x54>)
    148c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    1490:	0000150b 	andeq	r1, r0, fp, lsl #10
    1494:	000014a5 	andeq	r1, r0, r5, lsr #9
    1498:	000014c3 	andeq	r1, r0, r3, asr #9
    149c:	000014df 	ldrdeq	r1, [r0], -pc	@ <UNPREDICTABLE>
    14a0:	000014ef 	andeq	r1, r0, pc, ror #9
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    14a4:	6a3a      	ldr	r2, [r7, #32]
    14a6:	68bb      	ldr	r3, [r7, #8]
    14a8:	3310      	adds	r3, #16
    14aa:	009b      	lsls	r3, r3, #2
    14ac:	4413      	add	r3, r2
    14ae:	685a      	ldr	r2, [r3, #4]
    14b0:	687b      	ldr	r3, [r7, #4]
    14b2:	431a      	orrs	r2, r3
    14b4:	6a39      	ldr	r1, [r7, #32]
    14b6:	68bb      	ldr	r3, [r7, #8]
    14b8:	3310      	adds	r3, #16
    14ba:	009b      	lsls	r3, r3, #2
    14bc:	440b      	add	r3, r1
    14be:	605a      	str	r2, [r3, #4]
                    break;
    14c0:	e024      	b.n	150c <xTaskGenericNotify+0xd0>

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    14c2:	6a3a      	ldr	r2, [r7, #32]
    14c4:	68bb      	ldr	r3, [r7, #8]
    14c6:	3310      	adds	r3, #16
    14c8:	009b      	lsls	r3, r3, #2
    14ca:	4413      	add	r3, r2
    14cc:	685b      	ldr	r3, [r3, #4]
    14ce:	1c5a      	adds	r2, r3, #1
    14d0:	6a39      	ldr	r1, [r7, #32]
    14d2:	68bb      	ldr	r3, [r7, #8]
    14d4:	3310      	adds	r3, #16
    14d6:	009b      	lsls	r3, r3, #2
    14d8:	440b      	add	r3, r1
    14da:	605a      	str	r2, [r3, #4]
                    break;
    14dc:	e016      	b.n	150c <xTaskGenericNotify+0xd0>

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    14de:	6a3a      	ldr	r2, [r7, #32]
    14e0:	68bb      	ldr	r3, [r7, #8]
    14e2:	3310      	adds	r3, #16
    14e4:	009b      	lsls	r3, r3, #2
    14e6:	4413      	add	r3, r2
    14e8:	687a      	ldr	r2, [r7, #4]
    14ea:	605a      	str	r2, [r3, #4]
                    break;
    14ec:	e00e      	b.n	150c <xTaskGenericNotify+0xd0>

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    14ee:	7ffb      	ldrb	r3, [r7, #31]
    14f0:	2b02      	cmp	r3, #2
    14f2:	d007      	beq.n	1504 <xTaskGenericNotify+0xc8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    14f4:	6a3a      	ldr	r2, [r7, #32]
    14f6:	68bb      	ldr	r3, [r7, #8]
    14f8:	3310      	adds	r3, #16
    14fa:	009b      	lsls	r3, r3, #2
    14fc:	4413      	add	r3, r2
    14fe:	687a      	ldr	r2, [r7, #4]
    1500:	605a      	str	r2, [r3, #4]
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
                    }

                    break;
    1502:	e003      	b.n	150c <xTaskGenericNotify+0xd0>
                        xReturn = pdFAIL;
    1504:	2300      	movs	r3, #0
    1506:	627b      	str	r3, [r7, #36]	@ 0x24
                    break;
    1508:	e000      	b.n	150c <xTaskGenericNotify+0xd0>
                    /* Should not get here if all enums are handled.
                     * Artificially force an assert by testing a value the
                     * compiler can't assume is const. */
                    configASSERT( xTickCount == ( TickType_t ) 0 );

                    break;
    150a:	bf00      	nop

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    150c:	7ffb      	ldrb	r3, [r7, #31]
    150e:	2b01      	cmp	r3, #1
    1510:	d16e      	bne.n	15f0 <xTaskGenericNotify+0x1b4>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    1512:	6a3b      	ldr	r3, [r7, #32]
    1514:	695b      	ldr	r3, [r3, #20]
    1516:	61bb      	str	r3, [r7, #24]
    1518:	6a3b      	ldr	r3, [r7, #32]
    151a:	689b      	ldr	r3, [r3, #8]
    151c:	6a3a      	ldr	r2, [r7, #32]
    151e:	68d2      	ldr	r2, [r2, #12]
    1520:	609a      	str	r2, [r3, #8]
    1522:	6a3b      	ldr	r3, [r7, #32]
    1524:	68db      	ldr	r3, [r3, #12]
    1526:	6a3a      	ldr	r2, [r7, #32]
    1528:	6892      	ldr	r2, [r2, #8]
    152a:	605a      	str	r2, [r3, #4]
    152c:	69bb      	ldr	r3, [r7, #24]
    152e:	685a      	ldr	r2, [r3, #4]
    1530:	6a3b      	ldr	r3, [r7, #32]
    1532:	3304      	adds	r3, #4
    1534:	429a      	cmp	r2, r3
    1536:	d103      	bne.n	1540 <xTaskGenericNotify+0x104>
    1538:	6a3b      	ldr	r3, [r7, #32]
    153a:	68da      	ldr	r2, [r3, #12]
    153c:	69bb      	ldr	r3, [r7, #24]
    153e:	605a      	str	r2, [r3, #4]
    1540:	6a3b      	ldr	r3, [r7, #32]
    1542:	2200      	movs	r2, #0
    1544:	615a      	str	r2, [r3, #20]
    1546:	69bb      	ldr	r3, [r7, #24]
    1548:	681b      	ldr	r3, [r3, #0]
    154a:	1e5a      	subs	r2, r3, #1
    154c:	69bb      	ldr	r3, [r7, #24]
    154e:	601a      	str	r2, [r3, #0]
                prvAddTaskToReadyList( pxTCB );
    1550:	6a3b      	ldr	r3, [r7, #32]
    1552:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
    1554:	2201      	movs	r2, #1
    1556:	409a      	lsls	r2, r3
    1558:	4b29      	ldr	r3, [pc, #164]	@ (1600 <xTaskGenericNotify+0x1c4>)
    155a:	681b      	ldr	r3, [r3, #0]
    155c:	4313      	orrs	r3, r2
    155e:	4a28      	ldr	r2, [pc, #160]	@ (1600 <xTaskGenericNotify+0x1c4>)
    1560:	6013      	str	r3, [r2, #0]
    1562:	6a3b      	ldr	r3, [r7, #32]
    1564:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
    1566:	4927      	ldr	r1, [pc, #156]	@ (1604 <xTaskGenericNotify+0x1c8>)
    1568:	4613      	mov	r3, r2
    156a:	009b      	lsls	r3, r3, #2
    156c:	4413      	add	r3, r2
    156e:	009b      	lsls	r3, r3, #2
    1570:	440b      	add	r3, r1
    1572:	3304      	adds	r3, #4
    1574:	681b      	ldr	r3, [r3, #0]
    1576:	617b      	str	r3, [r7, #20]
    1578:	6a3b      	ldr	r3, [r7, #32]
    157a:	697a      	ldr	r2, [r7, #20]
    157c:	609a      	str	r2, [r3, #8]
    157e:	697b      	ldr	r3, [r7, #20]
    1580:	689a      	ldr	r2, [r3, #8]
    1582:	6a3b      	ldr	r3, [r7, #32]
    1584:	60da      	str	r2, [r3, #12]
    1586:	697b      	ldr	r3, [r7, #20]
    1588:	689b      	ldr	r3, [r3, #8]
    158a:	6a3a      	ldr	r2, [r7, #32]
    158c:	3204      	adds	r2, #4
    158e:	605a      	str	r2, [r3, #4]
    1590:	6a3b      	ldr	r3, [r7, #32]
    1592:	1d1a      	adds	r2, r3, #4
    1594:	697b      	ldr	r3, [r7, #20]
    1596:	609a      	str	r2, [r3, #8]
    1598:	6a3b      	ldr	r3, [r7, #32]
    159a:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
    159c:	4613      	mov	r3, r2
    159e:	009b      	lsls	r3, r3, #2
    15a0:	4413      	add	r3, r2
    15a2:	009b      	lsls	r3, r3, #2
    15a4:	4a17      	ldr	r2, [pc, #92]	@ (1604 <xTaskGenericNotify+0x1c8>)
    15a6:	441a      	add	r2, r3
    15a8:	6a3b      	ldr	r3, [r7, #32]
    15aa:	615a      	str	r2, [r3, #20]
    15ac:	6a3b      	ldr	r3, [r7, #32]
    15ae:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
    15b0:	4914      	ldr	r1, [pc, #80]	@ (1604 <xTaskGenericNotify+0x1c8>)
    15b2:	4613      	mov	r3, r2
    15b4:	009b      	lsls	r3, r3, #2
    15b6:	4413      	add	r3, r2
    15b8:	009b      	lsls	r3, r3, #2
    15ba:	440b      	add	r3, r1
    15bc:	681b      	ldr	r3, [r3, #0]
    15be:	6a3a      	ldr	r2, [r7, #32]
    15c0:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
    15c2:	1c59      	adds	r1, r3, #1
    15c4:	480f      	ldr	r0, [pc, #60]	@ (1604 <xTaskGenericNotify+0x1c8>)
    15c6:	4613      	mov	r3, r2
    15c8:	009b      	lsls	r3, r3, #2
    15ca:	4413      	add	r3, r2
    15cc:	009b      	lsls	r3, r3, #2
    15ce:	4403      	add	r3, r0
    15d0:	6019      	str	r1, [r3, #0]
                }
                #endif

                /* Check if the notified task has a priority above the currently
                 * executing task. */
                taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxTCB );
    15d2:	4b0d      	ldr	r3, [pc, #52]	@ (1608 <xTaskGenericNotify+0x1cc>)
    15d4:	681b      	ldr	r3, [r3, #0]
    15d6:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
    15d8:	6a3b      	ldr	r3, [r7, #32]
    15da:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
    15dc:	429a      	cmp	r2, r3
    15de:	d207      	bcs.n	15f0 <xTaskGenericNotify+0x1b4>
    15e0:	4b0a      	ldr	r3, [pc, #40]	@ (160c <xTaskGenericNotify+0x1d0>)
    15e2:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
    15e6:	601a      	str	r2, [r3, #0]
    15e8:	f3bf 8f4f 	dsb	sy
    15ec:	f3bf 8f6f 	isb	sy
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    15f0:	f000 fee8 	bl	23c4 <vPortExitCritical>

        traceRETURN_xTaskGenericNotify( xReturn );

        return xReturn;
    15f4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    }
    15f6:	4618      	mov	r0, r3
    15f8:	3728      	adds	r7, #40	@ 0x28
    15fa:	46bd      	mov	sp, r7
    15fc:	bd80      	pop	{r7, pc}
    15fe:	bf00      	nop
    1600:	200000b8 	strhcs	r0, [r0], -r8
    1604:	20000008 	andcs	r0, r0, r8
    1608:	20000004 	andcs	r0, r0, r4
    160c:	e000ed04 	and	lr, r0, r4, lsl #26

00001610 <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    1610:	b480      	push	{r7}
    1612:	b08f      	sub	sp, #60	@ 0x3c
    1614:	af00      	add	r7, sp, #0
    1616:	60f8      	str	r0, [r7, #12]
    1618:	60b9      	str	r1, [r7, #8]
    161a:	607a      	str	r2, [r7, #4]
    161c:	70fb      	strb	r3, [r7, #3]
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
    161e:	2301      	movs	r3, #1
    1620:	637b      	str	r3, [r7, #52]	@ 0x34
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    1622:	68fb      	ldr	r3, [r7, #12]
    1624:	633b      	str	r3, [r7, #48]	@ 0x30

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
    uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

    __asm volatile
    1626:	f3ef 8211 	mrs	r2, BASEPRI
    162a:	f04f 0301 	mov.w	r3, #1
    162e:	f383 8811 	msr	BASEPRI, r3
    1632:	f3bf 8f6f 	isb	sy
    1636:	f3bf 8f4f 	dsb	sy
    163a:	61ba      	str	r2, [r7, #24]
    163c:	617b      	str	r3, [r7, #20]
        : "=r" ( ulOriginalBASEPRI ), "=r" ( ulNewBASEPRI ) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
    );

    /* This return will not be reached but is necessary to prevent compiler
     * warnings. */
    return ulOriginalBASEPRI;
    163e:	69bb      	ldr	r3, [r7, #24]

        /* MISRA Ref 4.7.1 [Return value shall be checked] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#dir-47 */
        /* coverity[misra_c_2012_directive_4_7_violation] */
        uxSavedInterruptStatus = ( UBaseType_t ) taskENTER_CRITICAL_FROM_ISR();
    1640:	62fb      	str	r3, [r7, #44]	@ 0x2c
        {
            if( pulPreviousNotificationValue != NULL )
    1642:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
    1644:	2b00      	cmp	r3, #0
    1646:	d007      	beq.n	1658 <xTaskGenericNotifyFromISR+0x48>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    1648:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
    164a:	68bb      	ldr	r3, [r7, #8]
    164c:	3310      	adds	r3, #16
    164e:	009b      	lsls	r3, r3, #2
    1650:	4413      	add	r3, r2
    1652:	685a      	ldr	r2, [r3, #4]
    1654:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
    1656:	601a      	str	r2, [r3, #0]
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    1658:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
    165a:	68bb      	ldr	r3, [r7, #8]
    165c:	4413      	add	r3, r2
    165e:	3348      	adds	r3, #72	@ 0x48
    1660:	781b      	ldrb	r3, [r3, #0]
    1662:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    1666:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
    1668:	68bb      	ldr	r3, [r7, #8]
    166a:	4413      	add	r3, r2
    166c:	3348      	adds	r3, #72	@ 0x48
    166e:	2202      	movs	r2, #2
    1670:	701a      	strb	r2, [r3, #0]

            switch( eAction )
    1672:	78fb      	ldrb	r3, [r7, #3]
    1674:	2b04      	cmp	r3, #4
    1676:	d841      	bhi.n	16fc <xTaskGenericNotifyFromISR+0xec>
    1678:	a201      	add	r2, pc, #4	@ (adr r2, 1680 <xTaskGenericNotifyFromISR+0x70>)
    167a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    167e:	bf00      	nop
    1680:	000016fd 	strdeq	r1, [r0], -sp
    1684:	00001695 	muleq	r0, r5, r6
    1688:	000016b3 			@ <UNDEFINED> instruction: 0x000016b3
    168c:	000016cf 	andeq	r1, r0, pc, asr #13
    1690:	000016df 	ldrdeq	r1, [r0], -pc	@ <UNPREDICTABLE>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    1694:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
    1696:	68bb      	ldr	r3, [r7, #8]
    1698:	3310      	adds	r3, #16
    169a:	009b      	lsls	r3, r3, #2
    169c:	4413      	add	r3, r2
    169e:	685a      	ldr	r2, [r3, #4]
    16a0:	687b      	ldr	r3, [r7, #4]
    16a2:	431a      	orrs	r2, r3
    16a4:	6b39      	ldr	r1, [r7, #48]	@ 0x30
    16a6:	68bb      	ldr	r3, [r7, #8]
    16a8:	3310      	adds	r3, #16
    16aa:	009b      	lsls	r3, r3, #2
    16ac:	440b      	add	r3, r1
    16ae:	605a      	str	r2, [r3, #4]
                    break;
    16b0:	e025      	b.n	16fe <xTaskGenericNotifyFromISR+0xee>

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    16b2:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
    16b4:	68bb      	ldr	r3, [r7, #8]
    16b6:	3310      	adds	r3, #16
    16b8:	009b      	lsls	r3, r3, #2
    16ba:	4413      	add	r3, r2
    16bc:	685b      	ldr	r3, [r3, #4]
    16be:	1c5a      	adds	r2, r3, #1
    16c0:	6b39      	ldr	r1, [r7, #48]	@ 0x30
    16c2:	68bb      	ldr	r3, [r7, #8]
    16c4:	3310      	adds	r3, #16
    16c6:	009b      	lsls	r3, r3, #2
    16c8:	440b      	add	r3, r1
    16ca:	605a      	str	r2, [r3, #4]
                    break;
    16cc:	e017      	b.n	16fe <xTaskGenericNotifyFromISR+0xee>

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    16ce:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
    16d0:	68bb      	ldr	r3, [r7, #8]
    16d2:	3310      	adds	r3, #16
    16d4:	009b      	lsls	r3, r3, #2
    16d6:	4413      	add	r3, r2
    16d8:	687a      	ldr	r2, [r7, #4]
    16da:	605a      	str	r2, [r3, #4]
                    break;
    16dc:	e00f      	b.n	16fe <xTaskGenericNotifyFromISR+0xee>

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    16de:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
    16e2:	2b02      	cmp	r3, #2
    16e4:	d007      	beq.n	16f6 <xTaskGenericNotifyFromISR+0xe6>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    16e6:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
    16e8:	68bb      	ldr	r3, [r7, #8]
    16ea:	3310      	adds	r3, #16
    16ec:	009b      	lsls	r3, r3, #2
    16ee:	4413      	add	r3, r2
    16f0:	687a      	ldr	r2, [r7, #4]
    16f2:	605a      	str	r2, [r3, #4]
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
                    }

                    break;
    16f4:	e003      	b.n	16fe <xTaskGenericNotifyFromISR+0xee>
                        xReturn = pdFAIL;
    16f6:	2300      	movs	r3, #0
    16f8:	637b      	str	r3, [r7, #52]	@ 0x34
                    break;
    16fa:	e000      	b.n	16fe <xTaskGenericNotifyFromISR+0xee>

                    /* Should not get here if all enums are handled.
                     * Artificially force an assert by testing a value the
                     * compiler can't assume is const. */
                    configASSERT( xTickCount == ( TickType_t ) 0 );
                    break;
    16fc:	bf00      	nop

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    16fe:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
    1702:	2b01      	cmp	r3, #1
    1704:	f040 8091 	bne.w	182a <xTaskGenericNotifyFromISR+0x21a>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
    1708:	4b4e      	ldr	r3, [pc, #312]	@ (1844 <xTaskGenericNotifyFromISR+0x234>)
    170a:	681b      	ldr	r3, [r3, #0]
    170c:	2b00      	cmp	r3, #0
    170e:	d160      	bne.n	17d2 <xTaskGenericNotifyFromISR+0x1c2>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    1710:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    1712:	695b      	ldr	r3, [r3, #20]
    1714:	623b      	str	r3, [r7, #32]
    1716:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    1718:	689b      	ldr	r3, [r3, #8]
    171a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
    171c:	68d2      	ldr	r2, [r2, #12]
    171e:	609a      	str	r2, [r3, #8]
    1720:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    1722:	68db      	ldr	r3, [r3, #12]
    1724:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
    1726:	6892      	ldr	r2, [r2, #8]
    1728:	605a      	str	r2, [r3, #4]
    172a:	6a3b      	ldr	r3, [r7, #32]
    172c:	685a      	ldr	r2, [r3, #4]
    172e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    1730:	3304      	adds	r3, #4
    1732:	429a      	cmp	r2, r3
    1734:	d103      	bne.n	173e <xTaskGenericNotifyFromISR+0x12e>
    1736:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    1738:	68da      	ldr	r2, [r3, #12]
    173a:	6a3b      	ldr	r3, [r7, #32]
    173c:	605a      	str	r2, [r3, #4]
    173e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    1740:	2200      	movs	r2, #0
    1742:	615a      	str	r2, [r3, #20]
    1744:	6a3b      	ldr	r3, [r7, #32]
    1746:	681b      	ldr	r3, [r3, #0]
    1748:	1e5a      	subs	r2, r3, #1
    174a:	6a3b      	ldr	r3, [r7, #32]
    174c:	601a      	str	r2, [r3, #0]
                    prvAddTaskToReadyList( pxTCB );
    174e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    1750:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
    1752:	2201      	movs	r2, #1
    1754:	409a      	lsls	r2, r3
    1756:	4b3c      	ldr	r3, [pc, #240]	@ (1848 <xTaskGenericNotifyFromISR+0x238>)
    1758:	681b      	ldr	r3, [r3, #0]
    175a:	4313      	orrs	r3, r2
    175c:	4a3a      	ldr	r2, [pc, #232]	@ (1848 <xTaskGenericNotifyFromISR+0x238>)
    175e:	6013      	str	r3, [r2, #0]
    1760:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    1762:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
    1764:	4939      	ldr	r1, [pc, #228]	@ (184c <xTaskGenericNotifyFromISR+0x23c>)
    1766:	4613      	mov	r3, r2
    1768:	009b      	lsls	r3, r3, #2
    176a:	4413      	add	r3, r2
    176c:	009b      	lsls	r3, r3, #2
    176e:	440b      	add	r3, r1
    1770:	3304      	adds	r3, #4
    1772:	681b      	ldr	r3, [r3, #0]
    1774:	61fb      	str	r3, [r7, #28]
    1776:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    1778:	69fa      	ldr	r2, [r7, #28]
    177a:	609a      	str	r2, [r3, #8]
    177c:	69fb      	ldr	r3, [r7, #28]
    177e:	689a      	ldr	r2, [r3, #8]
    1780:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    1782:	60da      	str	r2, [r3, #12]
    1784:	69fb      	ldr	r3, [r7, #28]
    1786:	689b      	ldr	r3, [r3, #8]
    1788:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
    178a:	3204      	adds	r2, #4
    178c:	605a      	str	r2, [r3, #4]
    178e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    1790:	1d1a      	adds	r2, r3, #4
    1792:	69fb      	ldr	r3, [r7, #28]
    1794:	609a      	str	r2, [r3, #8]
    1796:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    1798:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
    179a:	4613      	mov	r3, r2
    179c:	009b      	lsls	r3, r3, #2
    179e:	4413      	add	r3, r2
    17a0:	009b      	lsls	r3, r3, #2
    17a2:	4a2a      	ldr	r2, [pc, #168]	@ (184c <xTaskGenericNotifyFromISR+0x23c>)
    17a4:	441a      	add	r2, r3
    17a6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    17a8:	615a      	str	r2, [r3, #20]
    17aa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    17ac:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
    17ae:	4927      	ldr	r1, [pc, #156]	@ (184c <xTaskGenericNotifyFromISR+0x23c>)
    17b0:	4613      	mov	r3, r2
    17b2:	009b      	lsls	r3, r3, #2
    17b4:	4413      	add	r3, r2
    17b6:	009b      	lsls	r3, r3, #2
    17b8:	440b      	add	r3, r1
    17ba:	681b      	ldr	r3, [r3, #0]
    17bc:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
    17be:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
    17c0:	1c59      	adds	r1, r3, #1
    17c2:	4822      	ldr	r0, [pc, #136]	@ (184c <xTaskGenericNotifyFromISR+0x23c>)
    17c4:	4613      	mov	r3, r2
    17c6:	009b      	lsls	r3, r3, #2
    17c8:	4413      	add	r3, r2
    17ca:	009b      	lsls	r3, r3, #2
    17cc:	4403      	add	r3, r0
    17ce:	6019      	str	r1, [r3, #0]
    17d0:	e01b      	b.n	180a <xTaskGenericNotifyFromISR+0x1fa>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    17d2:	4b1f      	ldr	r3, [pc, #124]	@ (1850 <xTaskGenericNotifyFromISR+0x240>)
    17d4:	685b      	ldr	r3, [r3, #4]
    17d6:	627b      	str	r3, [r7, #36]	@ 0x24
    17d8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    17da:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    17dc:	61da      	str	r2, [r3, #28]
    17de:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    17e0:	689a      	ldr	r2, [r3, #8]
    17e2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    17e4:	621a      	str	r2, [r3, #32]
    17e6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    17e8:	689b      	ldr	r3, [r3, #8]
    17ea:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
    17ec:	3218      	adds	r2, #24
    17ee:	605a      	str	r2, [r3, #4]
    17f0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    17f2:	f103 0218 	add.w	r2, r3, #24
    17f6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    17f8:	609a      	str	r2, [r3, #8]
    17fa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    17fc:	4a14      	ldr	r2, [pc, #80]	@ (1850 <xTaskGenericNotifyFromISR+0x240>)
    17fe:	629a      	str	r2, [r3, #40]	@ 0x28
    1800:	4b13      	ldr	r3, [pc, #76]	@ (1850 <xTaskGenericNotifyFromISR+0x240>)
    1802:	681b      	ldr	r3, [r3, #0]
    1804:	3301      	adds	r3, #1
    1806:	4a12      	ldr	r2, [pc, #72]	@ (1850 <xTaskGenericNotifyFromISR+0x240>)
    1808:	6013      	str	r3, [r2, #0]
                }

                #if ( configNUMBER_OF_CORES == 1 )
                {
                    if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    180a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    180c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
    180e:	4b11      	ldr	r3, [pc, #68]	@ (1854 <xTaskGenericNotifyFromISR+0x244>)
    1810:	681b      	ldr	r3, [r3, #0]
    1812:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
    1814:	429a      	cmp	r2, r3
    1816:	d908      	bls.n	182a <xTaskGenericNotifyFromISR+0x21a>
                    {
                        /* The notified task has a priority above the currently
                         * executing task so a yield is required. */
                        if( pxHigherPriorityTaskWoken != NULL )
    1818:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
    181a:	2b00      	cmp	r3, #0
    181c:	d002      	beq.n	1824 <xTaskGenericNotifyFromISR+0x214>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    181e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
    1820:	2201      	movs	r2, #1
    1822:	601a      	str	r2, [r3, #0]
                        }

                        /* Mark that a yield is pending in case the user is not
                         * using the "xHigherPriorityTaskWoken" parameter to an ISR
                         * safe FreeRTOS function. */
                        xYieldPendings[ 0 ] = pdTRUE;
    1824:	4b0c      	ldr	r3, [pc, #48]	@ (1858 <xTaskGenericNotifyFromISR+0x248>)
    1826:	2201      	movs	r2, #1
    1828:	601a      	str	r2, [r3, #0]
    182a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    182c:	613b      	str	r3, [r7, #16]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
    __asm volatile
    182e:	693b      	ldr	r3, [r7, #16]
    1830:	f383 8811 	msr	BASEPRI, r3
    (
        "   msr basepri, %0 " ::"r" ( ulNewMaskValue ) : "memory"
    );
}
    1834:	bf00      	nop
        }
        taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );

        traceRETURN_xTaskGenericNotifyFromISR( xReturn );

        return xReturn;
    1836:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    }
    1838:	4618      	mov	r0, r3
    183a:	373c      	adds	r7, #60	@ 0x3c
    183c:	46bd      	mov	sp, r7
    183e:	bc80      	pop	{r7}
    1840:	4770      	bx	lr
    1842:	bf00      	nop
    1844:	200000d8 	ldrdcs	r0, [r0], -r8
    1848:	200000b8 	strhcs	r0, [r0], -r8
    184c:	20000008 	andcs	r0, r0, r8
    1850:	2000009c 	mulcs	r0, ip, r0
    1854:	20000004 	andcs	r0, r0, r4
    1858:	200000c4 	andcs	r0, r0, r4, asr #1

0000185c <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    185c:	b480      	push	{r7}
    185e:	b08f      	sub	sp, #60	@ 0x3c
    1860:	af00      	add	r7, sp, #0
    1862:	60f8      	str	r0, [r7, #12]
    1864:	60b9      	str	r1, [r7, #8]
    1866:	607a      	str	r2, [r7, #4]
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    1868:	68fb      	ldr	r3, [r7, #12]
    186a:	637b      	str	r3, [r7, #52]	@ 0x34
    __asm volatile
    186c:	f3ef 8211 	mrs	r2, BASEPRI
    1870:	f04f 0301 	mov.w	r3, #1
    1874:	f383 8811 	msr	BASEPRI, r3
    1878:	f3bf 8f6f 	isb	sy
    187c:	f3bf 8f4f 	dsb	sy
    1880:	61fa      	str	r2, [r7, #28]
    1882:	61bb      	str	r3, [r7, #24]
    return ulOriginalBASEPRI;
    1884:	69fb      	ldr	r3, [r7, #28]

        /* MISRA Ref 4.7.1 [Return value shall be checked] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#dir-47 */
        /* coverity[misra_c_2012_directive_4_7_violation] */
        uxSavedInterruptStatus = ( UBaseType_t ) taskENTER_CRITICAL_FROM_ISR();
    1886:	633b      	str	r3, [r7, #48]	@ 0x30
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    1888:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
    188a:	68bb      	ldr	r3, [r7, #8]
    188c:	4413      	add	r3, r2
    188e:	3348      	adds	r3, #72	@ 0x48
    1890:	781b      	ldrb	r3, [r3, #0]
    1892:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    1896:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
    1898:	68bb      	ldr	r3, [r7, #8]
    189a:	4413      	add	r3, r2
    189c:	3348      	adds	r3, #72	@ 0x48
    189e:	2202      	movs	r2, #2
    18a0:	701a      	strb	r2, [r3, #0]

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    18a2:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
    18a4:	68bb      	ldr	r3, [r7, #8]
    18a6:	3310      	adds	r3, #16
    18a8:	009b      	lsls	r3, r3, #2
    18aa:	4413      	add	r3, r2
    18ac:	685b      	ldr	r3, [r3, #4]
    18ae:	1c5a      	adds	r2, r3, #1
    18b0:	6b79      	ldr	r1, [r7, #52]	@ 0x34
    18b2:	68bb      	ldr	r3, [r7, #8]
    18b4:	3310      	adds	r3, #16
    18b6:	009b      	lsls	r3, r3, #2
    18b8:	440b      	add	r3, r1
    18ba:	605a      	str	r2, [r3, #4]

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    18bc:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
    18c0:	2b01      	cmp	r3, #1
    18c2:	f040 8091 	bne.w	19e8 <vTaskGenericNotifyGiveFromISR+0x18c>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
    18c6:	4b4e      	ldr	r3, [pc, #312]	@ (1a00 <vTaskGenericNotifyGiveFromISR+0x1a4>)
    18c8:	681b      	ldr	r3, [r3, #0]
    18ca:	2b00      	cmp	r3, #0
    18cc:	d160      	bne.n	1990 <vTaskGenericNotifyGiveFromISR+0x134>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    18ce:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    18d0:	695b      	ldr	r3, [r3, #20]
    18d2:	627b      	str	r3, [r7, #36]	@ 0x24
    18d4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    18d6:	689b      	ldr	r3, [r3, #8]
    18d8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
    18da:	68d2      	ldr	r2, [r2, #12]
    18dc:	609a      	str	r2, [r3, #8]
    18de:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    18e0:	68db      	ldr	r3, [r3, #12]
    18e2:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
    18e4:	6892      	ldr	r2, [r2, #8]
    18e6:	605a      	str	r2, [r3, #4]
    18e8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    18ea:	685a      	ldr	r2, [r3, #4]
    18ec:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    18ee:	3304      	adds	r3, #4
    18f0:	429a      	cmp	r2, r3
    18f2:	d103      	bne.n	18fc <vTaskGenericNotifyGiveFromISR+0xa0>
    18f4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    18f6:	68da      	ldr	r2, [r3, #12]
    18f8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    18fa:	605a      	str	r2, [r3, #4]
    18fc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    18fe:	2200      	movs	r2, #0
    1900:	615a      	str	r2, [r3, #20]
    1902:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    1904:	681b      	ldr	r3, [r3, #0]
    1906:	1e5a      	subs	r2, r3, #1
    1908:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    190a:	601a      	str	r2, [r3, #0]
                    prvAddTaskToReadyList( pxTCB );
    190c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    190e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
    1910:	2201      	movs	r2, #1
    1912:	409a      	lsls	r2, r3
    1914:	4b3b      	ldr	r3, [pc, #236]	@ (1a04 <vTaskGenericNotifyGiveFromISR+0x1a8>)
    1916:	681b      	ldr	r3, [r3, #0]
    1918:	4313      	orrs	r3, r2
    191a:	4a3a      	ldr	r2, [pc, #232]	@ (1a04 <vTaskGenericNotifyGiveFromISR+0x1a8>)
    191c:	6013      	str	r3, [r2, #0]
    191e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    1920:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
    1922:	4939      	ldr	r1, [pc, #228]	@ (1a08 <vTaskGenericNotifyGiveFromISR+0x1ac>)
    1924:	4613      	mov	r3, r2
    1926:	009b      	lsls	r3, r3, #2
    1928:	4413      	add	r3, r2
    192a:	009b      	lsls	r3, r3, #2
    192c:	440b      	add	r3, r1
    192e:	3304      	adds	r3, #4
    1930:	681b      	ldr	r3, [r3, #0]
    1932:	623b      	str	r3, [r7, #32]
    1934:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    1936:	6a3a      	ldr	r2, [r7, #32]
    1938:	609a      	str	r2, [r3, #8]
    193a:	6a3b      	ldr	r3, [r7, #32]
    193c:	689a      	ldr	r2, [r3, #8]
    193e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    1940:	60da      	str	r2, [r3, #12]
    1942:	6a3b      	ldr	r3, [r7, #32]
    1944:	689b      	ldr	r3, [r3, #8]
    1946:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
    1948:	3204      	adds	r2, #4
    194a:	605a      	str	r2, [r3, #4]
    194c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    194e:	1d1a      	adds	r2, r3, #4
    1950:	6a3b      	ldr	r3, [r7, #32]
    1952:	609a      	str	r2, [r3, #8]
    1954:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    1956:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
    1958:	4613      	mov	r3, r2
    195a:	009b      	lsls	r3, r3, #2
    195c:	4413      	add	r3, r2
    195e:	009b      	lsls	r3, r3, #2
    1960:	4a29      	ldr	r2, [pc, #164]	@ (1a08 <vTaskGenericNotifyGiveFromISR+0x1ac>)
    1962:	441a      	add	r2, r3
    1964:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    1966:	615a      	str	r2, [r3, #20]
    1968:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    196a:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
    196c:	4926      	ldr	r1, [pc, #152]	@ (1a08 <vTaskGenericNotifyGiveFromISR+0x1ac>)
    196e:	4613      	mov	r3, r2
    1970:	009b      	lsls	r3, r3, #2
    1972:	4413      	add	r3, r2
    1974:	009b      	lsls	r3, r3, #2
    1976:	440b      	add	r3, r1
    1978:	681b      	ldr	r3, [r3, #0]
    197a:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
    197c:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
    197e:	1c59      	adds	r1, r3, #1
    1980:	4821      	ldr	r0, [pc, #132]	@ (1a08 <vTaskGenericNotifyGiveFromISR+0x1ac>)
    1982:	4613      	mov	r3, r2
    1984:	009b      	lsls	r3, r3, #2
    1986:	4413      	add	r3, r2
    1988:	009b      	lsls	r3, r3, #2
    198a:	4403      	add	r3, r0
    198c:	6019      	str	r1, [r3, #0]
    198e:	e01b      	b.n	19c8 <vTaskGenericNotifyGiveFromISR+0x16c>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1990:	4b1e      	ldr	r3, [pc, #120]	@ (1a0c <vTaskGenericNotifyGiveFromISR+0x1b0>)
    1992:	685b      	ldr	r3, [r3, #4]
    1994:	62bb      	str	r3, [r7, #40]	@ 0x28
    1996:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    1998:	6aba      	ldr	r2, [r7, #40]	@ 0x28
    199a:	61da      	str	r2, [r3, #28]
    199c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    199e:	689a      	ldr	r2, [r3, #8]
    19a0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    19a2:	621a      	str	r2, [r3, #32]
    19a4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    19a6:	689b      	ldr	r3, [r3, #8]
    19a8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
    19aa:	3218      	adds	r2, #24
    19ac:	605a      	str	r2, [r3, #4]
    19ae:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    19b0:	f103 0218 	add.w	r2, r3, #24
    19b4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    19b6:	609a      	str	r2, [r3, #8]
    19b8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    19ba:	4a14      	ldr	r2, [pc, #80]	@ (1a0c <vTaskGenericNotifyGiveFromISR+0x1b0>)
    19bc:	629a      	str	r2, [r3, #40]	@ 0x28
    19be:	4b13      	ldr	r3, [pc, #76]	@ (1a0c <vTaskGenericNotifyGiveFromISR+0x1b0>)
    19c0:	681b      	ldr	r3, [r3, #0]
    19c2:	3301      	adds	r3, #1
    19c4:	4a11      	ldr	r2, [pc, #68]	@ (1a0c <vTaskGenericNotifyGiveFromISR+0x1b0>)
    19c6:	6013      	str	r3, [r2, #0]
                }

                #if ( configNUMBER_OF_CORES == 1 )
                {
                    if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    19c8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    19ca:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
    19cc:	4b10      	ldr	r3, [pc, #64]	@ (1a10 <vTaskGenericNotifyGiveFromISR+0x1b4>)
    19ce:	681b      	ldr	r3, [r3, #0]
    19d0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
    19d2:	429a      	cmp	r2, r3
    19d4:	d908      	bls.n	19e8 <vTaskGenericNotifyGiveFromISR+0x18c>
                    {
                        /* The notified task has a priority above the currently
                         * executing task so a yield is required. */
                        if( pxHigherPriorityTaskWoken != NULL )
    19d6:	687b      	ldr	r3, [r7, #4]
    19d8:	2b00      	cmp	r3, #0
    19da:	d002      	beq.n	19e2 <vTaskGenericNotifyGiveFromISR+0x186>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    19dc:	687b      	ldr	r3, [r7, #4]
    19de:	2201      	movs	r2, #1
    19e0:	601a      	str	r2, [r3, #0]
                        }

                        /* Mark that a yield is pending in case the user is not
                         * using the "xHigherPriorityTaskWoken" parameter in an ISR
                         * safe FreeRTOS function. */
                        xYieldPendings[ 0 ] = pdTRUE;
    19e2:	4b0c      	ldr	r3, [pc, #48]	@ (1a14 <vTaskGenericNotifyGiveFromISR+0x1b8>)
    19e4:	2201      	movs	r2, #1
    19e6:	601a      	str	r2, [r3, #0]
    19e8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    19ea:	617b      	str	r3, [r7, #20]
    __asm volatile
    19ec:	697b      	ldr	r3, [r7, #20]
    19ee:	f383 8811 	msr	BASEPRI, r3
}
    19f2:	bf00      	nop
            }
        }
        taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );

        traceRETURN_vTaskGenericNotifyGiveFromISR();
    }
    19f4:	bf00      	nop
    19f6:	373c      	adds	r7, #60	@ 0x3c
    19f8:	46bd      	mov	sp, r7
    19fa:	bc80      	pop	{r7}
    19fc:	4770      	bx	lr
    19fe:	bf00      	nop
    1a00:	200000d8 	ldrdcs	r0, [r0], -r8
    1a04:	200000b8 	strhcs	r0, [r0], -r8
    1a08:	20000008 	andcs	r0, r0, r8
    1a0c:	2000009c 	mulcs	r0, ip, r0
    1a10:	20000004 	andcs	r0, r0, r4
    1a14:	200000c4 	andcs	r0, r0, r4, asr #1

00001a18 <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    1a18:	b580      	push	{r7, lr}
    1a1a:	b084      	sub	sp, #16
    1a1c:	af00      	add	r7, sp, #0
    1a1e:	6078      	str	r0, [r7, #4]
    1a20:	6039      	str	r1, [r7, #0]

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    1a22:	687b      	ldr	r3, [r7, #4]
    1a24:	2b00      	cmp	r3, #0
    1a26:	d102      	bne.n	1a2e <xTaskGenericNotifyStateClear+0x16>
    1a28:	4b10      	ldr	r3, [pc, #64]	@ (1a6c <xTaskGenericNotifyStateClear+0x54>)
    1a2a:	681b      	ldr	r3, [r3, #0]
    1a2c:	e000      	b.n	1a30 <xTaskGenericNotifyStateClear+0x18>
    1a2e:	687b      	ldr	r3, [r7, #4]
    1a30:	60bb      	str	r3, [r7, #8]
        configASSERT( pxTCB != NULL );

        taskENTER_CRITICAL();
    1a32:	f000 fcad 	bl	2390 <vPortEnterCritical>
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    1a36:	68ba      	ldr	r2, [r7, #8]
    1a38:	683b      	ldr	r3, [r7, #0]
    1a3a:	4413      	add	r3, r2
    1a3c:	3348      	adds	r3, #72	@ 0x48
    1a3e:	781b      	ldrb	r3, [r3, #0]
    1a40:	b2db      	uxtb	r3, r3
    1a42:	2b02      	cmp	r3, #2
    1a44:	d108      	bne.n	1a58 <xTaskGenericNotifyStateClear+0x40>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    1a46:	68ba      	ldr	r2, [r7, #8]
    1a48:	683b      	ldr	r3, [r7, #0]
    1a4a:	4413      	add	r3, r2
    1a4c:	3348      	adds	r3, #72	@ 0x48
    1a4e:	2200      	movs	r2, #0
    1a50:	701a      	strb	r2, [r3, #0]
                xReturn = pdPASS;
    1a52:	2301      	movs	r3, #1
    1a54:	60fb      	str	r3, [r7, #12]
    1a56:	e001      	b.n	1a5c <xTaskGenericNotifyStateClear+0x44>
            }
            else
            {
                xReturn = pdFAIL;
    1a58:	2300      	movs	r3, #0
    1a5a:	60fb      	str	r3, [r7, #12]
            }
        }
        taskEXIT_CRITICAL();
    1a5c:	f000 fcb2 	bl	23c4 <vPortExitCritical>

        traceRETURN_xTaskGenericNotifyStateClear( xReturn );

        return xReturn;
    1a60:	68fb      	ldr	r3, [r7, #12]
    }
    1a62:	4618      	mov	r0, r3
    1a64:	3710      	adds	r7, #16
    1a66:	46bd      	mov	sp, r7
    1a68:	bd80      	pop	{r7, pc}
    1a6a:	bf00      	nop
    1a6c:	20000004 	andcs	r0, r0, r4

00001a70 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    1a70:	b580      	push	{r7, lr}
    1a72:	b086      	sub	sp, #24
    1a74:	af00      	add	r7, sp, #0
    1a76:	60f8      	str	r0, [r7, #12]
    1a78:	60b9      	str	r1, [r7, #8]
    1a7a:	607a      	str	r2, [r7, #4]

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    1a7c:	68fb      	ldr	r3, [r7, #12]
    1a7e:	2b00      	cmp	r3, #0
    1a80:	d102      	bne.n	1a88 <ulTaskGenericNotifyValueClear+0x18>
    1a82:	4b12      	ldr	r3, [pc, #72]	@ (1acc <ulTaskGenericNotifyValueClear+0x5c>)
    1a84:	681b      	ldr	r3, [r3, #0]
    1a86:	e000      	b.n	1a8a <ulTaskGenericNotifyValueClear+0x1a>
    1a88:	68fb      	ldr	r3, [r7, #12]
    1a8a:	617b      	str	r3, [r7, #20]
        configASSERT( pxTCB != NULL );

        taskENTER_CRITICAL();
    1a8c:	f000 fc80 	bl	2390 <vPortEnterCritical>
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    1a90:	697a      	ldr	r2, [r7, #20]
    1a92:	68bb      	ldr	r3, [r7, #8]
    1a94:	3310      	adds	r3, #16
    1a96:	009b      	lsls	r3, r3, #2
    1a98:	4413      	add	r3, r2
    1a9a:	685b      	ldr	r3, [r3, #4]
    1a9c:	613b      	str	r3, [r7, #16]
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    1a9e:	697a      	ldr	r2, [r7, #20]
    1aa0:	68bb      	ldr	r3, [r7, #8]
    1aa2:	3310      	adds	r3, #16
    1aa4:	009b      	lsls	r3, r3, #2
    1aa6:	4413      	add	r3, r2
    1aa8:	685a      	ldr	r2, [r3, #4]
    1aaa:	687b      	ldr	r3, [r7, #4]
    1aac:	43db      	mvns	r3, r3
    1aae:	401a      	ands	r2, r3
    1ab0:	6979      	ldr	r1, [r7, #20]
    1ab2:	68bb      	ldr	r3, [r7, #8]
    1ab4:	3310      	adds	r3, #16
    1ab6:	009b      	lsls	r3, r3, #2
    1ab8:	440b      	add	r3, r1
    1aba:	605a      	str	r2, [r3, #4]
        }
        taskEXIT_CRITICAL();
    1abc:	f000 fc82 	bl	23c4 <vPortExitCritical>

        traceRETURN_ulTaskGenericNotifyValueClear( ulReturn );

        return ulReturn;
    1ac0:	693b      	ldr	r3, [r7, #16]
    }
    1ac2:	4618      	mov	r0, r3
    1ac4:	3718      	adds	r7, #24
    1ac6:	46bd      	mov	sp, r7
    1ac8:	bd80      	pop	{r7, pc}
    1aca:	bf00      	nop
    1acc:	20000004 	andcs	r0, r0, r4

00001ad0 <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    1ad0:	b580      	push	{r7, lr}
    1ad2:	b086      	sub	sp, #24
    1ad4:	af00      	add	r7, sp, #0
    1ad6:	6078      	str	r0, [r7, #4]
    1ad8:	6039      	str	r1, [r7, #0]
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    1ada:	4b22      	ldr	r3, [pc, #136]	@ (1b64 <prvAddCurrentTaskToDelayedList+0x94>)
    1adc:	681b      	ldr	r3, [r3, #0]
    1ade:	617b      	str	r3, [r7, #20]
    List_t * const pxDelayedList = pxDelayedTaskList;
    1ae0:	4b21      	ldr	r3, [pc, #132]	@ (1b68 <prvAddCurrentTaskToDelayedList+0x98>)
    1ae2:	681b      	ldr	r3, [r3, #0]
    1ae4:	613b      	str	r3, [r7, #16]
    List_t * const pxOverflowDelayedList = pxOverflowDelayedTaskList;
    1ae6:	4b21      	ldr	r3, [pc, #132]	@ (1b6c <prvAddCurrentTaskToDelayedList+0x9c>)
    1ae8:	681b      	ldr	r3, [r3, #0]
    1aea:	60fb      	str	r3, [r7, #12]
    }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1aec:	4b20      	ldr	r3, [pc, #128]	@ (1b70 <prvAddCurrentTaskToDelayedList+0xa0>)
    1aee:	681b      	ldr	r3, [r3, #0]
    1af0:	3304      	adds	r3, #4
    1af2:	4618      	mov	r0, r3
    1af4:	f000 f912 	bl	1d1c <uxListRemove>
    1af8:	4603      	mov	r3, r0
    1afa:	2b00      	cmp	r3, #0
    1afc:	d10b      	bne.n	1b16 <prvAddCurrentTaskToDelayedList+0x46>
    {
        /* The current task must be in a ready list, so there is no need to
         * check, and the port reset macro can be called directly. */
        portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
    1afe:	4b1c      	ldr	r3, [pc, #112]	@ (1b70 <prvAddCurrentTaskToDelayedList+0xa0>)
    1b00:	681b      	ldr	r3, [r3, #0]
    1b02:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
    1b04:	2201      	movs	r2, #1
    1b06:	fa02 f303 	lsl.w	r3, r2, r3
    1b0a:	43da      	mvns	r2, r3
    1b0c:	4b19      	ldr	r3, [pc, #100]	@ (1b74 <prvAddCurrentTaskToDelayedList+0xa4>)
    1b0e:	681b      	ldr	r3, [r3, #0]
    1b10:	4013      	ands	r3, r2
    1b12:	4a18      	ldr	r2, [pc, #96]	@ (1b74 <prvAddCurrentTaskToDelayedList+0xa4>)
    1b14:	6013      	str	r3, [r2, #0]
    #else /* INCLUDE_vTaskSuspend */
    {
        /* Calculate the time at which the task should be woken if the event
         * does not occur.  This may overflow but this doesn't matter, the kernel
         * will manage it correctly. */
        xTimeToWake = xConstTickCount + xTicksToWait;
    1b16:	697a      	ldr	r2, [r7, #20]
    1b18:	687b      	ldr	r3, [r7, #4]
    1b1a:	4413      	add	r3, r2
    1b1c:	60bb      	str	r3, [r7, #8]

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    1b1e:	4b14      	ldr	r3, [pc, #80]	@ (1b70 <prvAddCurrentTaskToDelayedList+0xa0>)
    1b20:	681b      	ldr	r3, [r3, #0]
    1b22:	68ba      	ldr	r2, [r7, #8]
    1b24:	605a      	str	r2, [r3, #4]

        if( xTimeToWake < xConstTickCount )
    1b26:	68ba      	ldr	r2, [r7, #8]
    1b28:	697b      	ldr	r3, [r7, #20]
    1b2a:	429a      	cmp	r2, r3
    1b2c:	d207      	bcs.n	1b3e <prvAddCurrentTaskToDelayedList+0x6e>
        {
            traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
            /* Wake time has overflowed.  Place this item in the overflow list. */
            vListInsert( pxOverflowDelayedList, &( pxCurrentTCB->xStateListItem ) );
    1b2e:	4b10      	ldr	r3, [pc, #64]	@ (1b70 <prvAddCurrentTaskToDelayedList+0xa0>)
    1b30:	681b      	ldr	r3, [r3, #0]
    1b32:	3304      	adds	r3, #4
    1b34:	4619      	mov	r1, r3
    1b36:	68f8      	ldr	r0, [r7, #12]
    1b38:	f000 f8b8 	bl	1cac <vListInsert>

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
    }
    #endif /* INCLUDE_vTaskSuspend */
}
    1b3c:	e00e      	b.n	1b5c <prvAddCurrentTaskToDelayedList+0x8c>
            vListInsert( pxDelayedList, &( pxCurrentTCB->xStateListItem ) );
    1b3e:	4b0c      	ldr	r3, [pc, #48]	@ (1b70 <prvAddCurrentTaskToDelayedList+0xa0>)
    1b40:	681b      	ldr	r3, [r3, #0]
    1b42:	3304      	adds	r3, #4
    1b44:	4619      	mov	r1, r3
    1b46:	6938      	ldr	r0, [r7, #16]
    1b48:	f000 f8b0 	bl	1cac <vListInsert>
            if( xTimeToWake < xNextTaskUnblockTime )
    1b4c:	4b0a      	ldr	r3, [pc, #40]	@ (1b78 <prvAddCurrentTaskToDelayedList+0xa8>)
    1b4e:	681b      	ldr	r3, [r3, #0]
    1b50:	68ba      	ldr	r2, [r7, #8]
    1b52:	429a      	cmp	r2, r3
    1b54:	d202      	bcs.n	1b5c <prvAddCurrentTaskToDelayedList+0x8c>
                xNextTaskUnblockTime = xTimeToWake;
    1b56:	4a08      	ldr	r2, [pc, #32]	@ (1b78 <prvAddCurrentTaskToDelayedList+0xa8>)
    1b58:	68bb      	ldr	r3, [r7, #8]
    1b5a:	6013      	str	r3, [r2, #0]
}
    1b5c:	bf00      	nop
    1b5e:	3718      	adds	r7, #24
    1b60:	46bd      	mov	sp, r7
    1b62:	bd80      	pop	{r7, pc}
    1b64:	200000b4 	strhcs	r0, [r0], -r4
    1b68:	20000094 	mulcs	r0, r4, r0
    1b6c:	20000098 	mulcs	r0, r8, r0
    1b70:	20000004 	andcs	r0, r0, r4
    1b74:	200000b8 	strhcs	r0, [r0], -r8
    1b78:	200000d0 	ldrdcs	r0, [r0], -r0	@ <UNPREDICTABLE>

00001b7c <vTaskResetState>:
 * Reset the state in this file. This state is normally initialized at start up.
 * This function must be called by the application before restarting the
 * scheduler.
 */
void vTaskResetState( void )
{
    1b7c:	b480      	push	{r7}
    1b7e:	b083      	sub	sp, #12
    1b80:	af00      	add	r7, sp, #0
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
    1b82:	4b18      	ldr	r3, [pc, #96]	@ (1be4 <vTaskResetState+0x68>)
    1b84:	2200      	movs	r2, #0
    1b86:	601a      	str	r2, [r3, #0]
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
    1b88:	4b17      	ldr	r3, [pc, #92]	@ (1be8 <vTaskResetState+0x6c>)
    1b8a:	2200      	movs	r2, #0
    1b8c:	601a      	str	r2, [r3, #0]
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    1b8e:	4b17      	ldr	r3, [pc, #92]	@ (1bec <vTaskResetState+0x70>)
    1b90:	2200      	movs	r2, #0
    1b92:	601a      	str	r2, [r3, #0]
    uxTopReadyPriority = tskIDLE_PRIORITY;
    1b94:	4b16      	ldr	r3, [pc, #88]	@ (1bf0 <vTaskResetState+0x74>)
    1b96:	2200      	movs	r2, #0
    1b98:	601a      	str	r2, [r3, #0]
    xSchedulerRunning = pdFALSE;
    1b9a:	4b16      	ldr	r3, [pc, #88]	@ (1bf4 <vTaskResetState+0x78>)
    1b9c:	2200      	movs	r2, #0
    1b9e:	601a      	str	r2, [r3, #0]
    xPendedTicks = ( TickType_t ) 0U;
    1ba0:	4b15      	ldr	r3, [pc, #84]	@ (1bf8 <vTaskResetState+0x7c>)
    1ba2:	2200      	movs	r2, #0
    1ba4:	601a      	str	r2, [r3, #0]

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    1ba6:	2300      	movs	r3, #0
    1ba8:	607b      	str	r3, [r7, #4]
    1baa:	e007      	b.n	1bbc <vTaskResetState+0x40>
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
    1bac:	4a13      	ldr	r2, [pc, #76]	@ (1bfc <vTaskResetState+0x80>)
    1bae:	687b      	ldr	r3, [r7, #4]
    1bb0:	2100      	movs	r1, #0
    1bb2:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    1bb6:	687b      	ldr	r3, [r7, #4]
    1bb8:	3301      	adds	r3, #1
    1bba:	607b      	str	r3, [r7, #4]
    1bbc:	687b      	ldr	r3, [r7, #4]
    1bbe:	2b00      	cmp	r3, #0
    1bc0:	ddf4      	ble.n	1bac <vTaskResetState+0x30>
    }

    xNumOfOverflows = ( BaseType_t ) 0;
    1bc2:	4b0f      	ldr	r3, [pc, #60]	@ (1c00 <vTaskResetState+0x84>)
    1bc4:	2200      	movs	r2, #0
    1bc6:	601a      	str	r2, [r3, #0]
    uxTaskNumber = ( UBaseType_t ) 0U;
    1bc8:	4b0e      	ldr	r3, [pc, #56]	@ (1c04 <vTaskResetState+0x88>)
    1bca:	2200      	movs	r2, #0
    1bcc:	601a      	str	r2, [r3, #0]
    xNextTaskUnblockTime = ( TickType_t ) 0U;
    1bce:	4b0e      	ldr	r3, [pc, #56]	@ (1c08 <vTaskResetState+0x8c>)
    1bd0:	2200      	movs	r2, #0
    1bd2:	601a      	str	r2, [r3, #0]

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
    1bd4:	4b0d      	ldr	r3, [pc, #52]	@ (1c0c <vTaskResetState+0x90>)
    1bd6:	2200      	movs	r2, #0
    1bd8:	601a      	str	r2, [r3, #0]
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
    1bda:	bf00      	nop
    1bdc:	370c      	adds	r7, #12
    1bde:	46bd      	mov	sp, r7
    1be0:	bc80      	pop	{r7}
    1be2:	4770      	bx	lr
    1be4:	20000004 	andcs	r0, r0, r4
    1be8:	200000b0 	strhcs	r0, [r0], -r0	@ <UNPREDICTABLE>
    1bec:	200000b4 	strhcs	r0, [r0], -r4
    1bf0:	200000b8 	strhcs	r0, [r0], -r8
    1bf4:	200000bc 	strhcs	r0, [r0], -ip
    1bf8:	200000c0 	andcs	r0, r0, r0, asr #1
    1bfc:	200000c4 	andcs	r0, r0, r4, asr #1
    1c00:	200000c8 	andcs	r0, r0, r8, asr #1
    1c04:	200000cc 	andcs	r0, r0, ip, asr #1
    1c08:	200000d0 	ldrdcs	r0, [r0], -r0	@ <UNPREDICTABLE>
    1c0c:	200000d8 	ldrdcs	r0, [r0], -r8

00001c10 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1c10:	b480      	push	{r7}
    1c12:	b083      	sub	sp, #12
    1c14:	af00      	add	r7, sp, #0
    1c16:	6078      	str	r0, [r7, #4]
    traceENTER_vListInitialise( pxList );

    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );
    1c18:	687b      	ldr	r3, [r7, #4]
    1c1a:	f103 0208 	add.w	r2, r3, #8
    1c1e:	687b      	ldr	r3, [r7, #4]
    1c20:	605a      	str	r2, [r3, #4]

    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    1c22:	687b      	ldr	r3, [r7, #4]
    1c24:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
    1c28:	609a      	str	r2, [r3, #8]

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );
    1c2a:	687b      	ldr	r3, [r7, #4]
    1c2c:	f103 0208 	add.w	r2, r3, #8
    1c30:	687b      	ldr	r3, [r7, #4]
    1c32:	60da      	str	r2, [r3, #12]
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );
    1c34:	687b      	ldr	r3, [r7, #4]
    1c36:	f103 0208 	add.w	r2, r3, #8
    1c3a:	687b      	ldr	r3, [r7, #4]
    1c3c:	611a      	str	r2, [r3, #16]
        pxList->xListEnd.pxContainer = NULL;
        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );
    }
    #endif

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1c3e:	687b      	ldr	r3, [r7, #4]
    1c40:	2200      	movs	r2, #0
    1c42:	601a      	str	r2, [r3, #0]
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );

    traceRETURN_vListInitialise();
}
    1c44:	bf00      	nop
    1c46:	370c      	adds	r7, #12
    1c48:	46bd      	mov	sp, r7
    1c4a:	bc80      	pop	{r7}
    1c4c:	4770      	bx	lr

00001c4e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    1c4e:	b480      	push	{r7}
    1c50:	b083      	sub	sp, #12
    1c52:	af00      	add	r7, sp, #0
    1c54:	6078      	str	r0, [r7, #4]
    traceENTER_vListInitialiseItem( pxItem );

    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    1c56:	687b      	ldr	r3, [r7, #4]
    1c58:	2200      	movs	r2, #0
    1c5a:	611a      	str	r2, [r3, #16]
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );

    traceRETURN_vListInitialiseItem();
}
    1c5c:	bf00      	nop
    1c5e:	370c      	adds	r7, #12
    1c60:	46bd      	mov	sp, r7
    1c62:	bc80      	pop	{r7}
    1c64:	4770      	bx	lr

00001c66 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    1c66:	b480      	push	{r7}
    1c68:	b085      	sub	sp, #20
    1c6a:	af00      	add	r7, sp, #0
    1c6c:	6078      	str	r0, [r7, #4]
    1c6e:	6039      	str	r1, [r7, #0]
    ListItem_t * const pxIndex = pxList->pxIndex;
    1c70:	687b      	ldr	r3, [r7, #4]
    1c72:	685b      	ldr	r3, [r3, #4]
    1c74:	60fb      	str	r3, [r7, #12]
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    1c76:	683b      	ldr	r3, [r7, #0]
    1c78:	68fa      	ldr	r2, [r7, #12]
    1c7a:	605a      	str	r2, [r3, #4]
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1c7c:	68fb      	ldr	r3, [r7, #12]
    1c7e:	689a      	ldr	r2, [r3, #8]
    1c80:	683b      	ldr	r3, [r7, #0]
    1c82:	609a      	str	r2, [r3, #8]

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    1c84:	68fb      	ldr	r3, [r7, #12]
    1c86:	689b      	ldr	r3, [r3, #8]
    1c88:	683a      	ldr	r2, [r7, #0]
    1c8a:	605a      	str	r2, [r3, #4]
    pxIndex->pxPrevious = pxNewListItem;
    1c8c:	68fb      	ldr	r3, [r7, #12]
    1c8e:	683a      	ldr	r2, [r7, #0]
    1c90:	609a      	str	r2, [r3, #8]

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    1c92:	683b      	ldr	r3, [r7, #0]
    1c94:	687a      	ldr	r2, [r7, #4]
    1c96:	611a      	str	r2, [r3, #16]

    ( pxList->uxNumberOfItems ) = ( UBaseType_t ) ( pxList->uxNumberOfItems + 1U );
    1c98:	687b      	ldr	r3, [r7, #4]
    1c9a:	681b      	ldr	r3, [r3, #0]
    1c9c:	1c5a      	adds	r2, r3, #1
    1c9e:	687b      	ldr	r3, [r7, #4]
    1ca0:	601a      	str	r2, [r3, #0]

    traceRETURN_vListInsertEnd();
}
    1ca2:	bf00      	nop
    1ca4:	3714      	adds	r7, #20
    1ca6:	46bd      	mov	sp, r7
    1ca8:	bc80      	pop	{r7}
    1caa:	4770      	bx	lr

00001cac <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    1cac:	b480      	push	{r7}
    1cae:	b085      	sub	sp, #20
    1cb0:	af00      	add	r7, sp, #0
    1cb2:	6078      	str	r0, [r7, #4]
    1cb4:	6039      	str	r1, [r7, #0]
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1cb6:	683b      	ldr	r3, [r7, #0]
    1cb8:	681b      	ldr	r3, [r3, #0]
    1cba:	60bb      	str	r3, [r7, #8]
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    1cbc:	68bb      	ldr	r3, [r7, #8]
    1cbe:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
    1cc2:	d103      	bne.n	1ccc <vListInsert+0x20>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    1cc4:	687b      	ldr	r3, [r7, #4]
    1cc6:	691b      	ldr	r3, [r3, #16]
    1cc8:	60fb      	str	r3, [r7, #12]
    1cca:	e00c      	b.n	1ce6 <vListInsert+0x3a>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1ccc:	687b      	ldr	r3, [r7, #4]
    1cce:	3308      	adds	r3, #8
    1cd0:	60fb      	str	r3, [r7, #12]
    1cd2:	e002      	b.n	1cda <vListInsert+0x2e>
    1cd4:	68fb      	ldr	r3, [r7, #12]
    1cd6:	685b      	ldr	r3, [r3, #4]
    1cd8:	60fb      	str	r3, [r7, #12]
    1cda:	68fb      	ldr	r3, [r7, #12]
    1cdc:	685b      	ldr	r3, [r3, #4]
    1cde:	681b      	ldr	r3, [r3, #0]
    1ce0:	68ba      	ldr	r2, [r7, #8]
    1ce2:	429a      	cmp	r2, r3
    1ce4:	d2f6      	bcs.n	1cd4 <vListInsert+0x28>
             * IF YOU FIND YOUR CODE STUCK HERE, SEE THE NOTE JUST ABOVE.
             */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    1ce6:	68fb      	ldr	r3, [r7, #12]
    1ce8:	685a      	ldr	r2, [r3, #4]
    1cea:	683b      	ldr	r3, [r7, #0]
    1cec:	605a      	str	r2, [r3, #4]
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1cee:	683b      	ldr	r3, [r7, #0]
    1cf0:	685b      	ldr	r3, [r3, #4]
    1cf2:	683a      	ldr	r2, [r7, #0]
    1cf4:	609a      	str	r2, [r3, #8]
    pxNewListItem->pxPrevious = pxIterator;
    1cf6:	683b      	ldr	r3, [r7, #0]
    1cf8:	68fa      	ldr	r2, [r7, #12]
    1cfa:	609a      	str	r2, [r3, #8]
    pxIterator->pxNext = pxNewListItem;
    1cfc:	68fb      	ldr	r3, [r7, #12]
    1cfe:	683a      	ldr	r2, [r7, #0]
    1d00:	605a      	str	r2, [r3, #4]

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    1d02:	683b      	ldr	r3, [r7, #0]
    1d04:	687a      	ldr	r2, [r7, #4]
    1d06:	611a      	str	r2, [r3, #16]

    ( pxList->uxNumberOfItems ) = ( UBaseType_t ) ( pxList->uxNumberOfItems + 1U );
    1d08:	687b      	ldr	r3, [r7, #4]
    1d0a:	681b      	ldr	r3, [r3, #0]
    1d0c:	1c5a      	adds	r2, r3, #1
    1d0e:	687b      	ldr	r3, [r7, #4]
    1d10:	601a      	str	r2, [r3, #0]

    traceRETURN_vListInsert();
}
    1d12:	bf00      	nop
    1d14:	3714      	adds	r7, #20
    1d16:	46bd      	mov	sp, r7
    1d18:	bc80      	pop	{r7}
    1d1a:	4770      	bx	lr

00001d1c <uxListRemove>:
/*-----------------------------------------------------------*/


UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1d1c:	b480      	push	{r7}
    1d1e:	b085      	sub	sp, #20
    1d20:	af00      	add	r7, sp, #0
    1d22:	6078      	str	r0, [r7, #4]
    /* The list item knows which list it is in.  Obtain the list from the list
     * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    1d24:	687b      	ldr	r3, [r7, #4]
    1d26:	691b      	ldr	r3, [r3, #16]
    1d28:	60fb      	str	r3, [r7, #12]

    traceENTER_uxListRemove( pxItemToRemove );

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1d2a:	687b      	ldr	r3, [r7, #4]
    1d2c:	685b      	ldr	r3, [r3, #4]
    1d2e:	687a      	ldr	r2, [r7, #4]
    1d30:	6892      	ldr	r2, [r2, #8]
    1d32:	609a      	str	r2, [r3, #8]
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1d34:	687b      	ldr	r3, [r7, #4]
    1d36:	689b      	ldr	r3, [r3, #8]
    1d38:	687a      	ldr	r2, [r7, #4]
    1d3a:	6852      	ldr	r2, [r2, #4]
    1d3c:	605a      	str	r2, [r3, #4]

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    1d3e:	68fb      	ldr	r3, [r7, #12]
    1d40:	685b      	ldr	r3, [r3, #4]
    1d42:	687a      	ldr	r2, [r7, #4]
    1d44:	429a      	cmp	r2, r3
    1d46:	d103      	bne.n	1d50 <uxListRemove+0x34>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    1d48:	687b      	ldr	r3, [r7, #4]
    1d4a:	689a      	ldr	r2, [r3, #8]
    1d4c:	68fb      	ldr	r3, [r7, #12]
    1d4e:	605a      	str	r2, [r3, #4]
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    1d50:	687b      	ldr	r3, [r7, #4]
    1d52:	2200      	movs	r2, #0
    1d54:	611a      	str	r2, [r3, #16]
    ( pxList->uxNumberOfItems ) = ( UBaseType_t ) ( pxList->uxNumberOfItems - 1U );
    1d56:	68fb      	ldr	r3, [r7, #12]
    1d58:	681b      	ldr	r3, [r3, #0]
    1d5a:	1e5a      	subs	r2, r3, #1
    1d5c:	68fb      	ldr	r3, [r7, #12]
    1d5e:	601a      	str	r2, [r3, #0]

    traceRETURN_uxListRemove( pxList->uxNumberOfItems );

    return pxList->uxNumberOfItems;
    1d60:	68fb      	ldr	r3, [r7, #12]
    1d62:	681b      	ldr	r3, [r3, #0]
}
    1d64:	4618      	mov	r0, r3
    1d66:	3714      	adds	r7, #20
    1d68:	46bd      	mov	sp, r7
    1d6a:	bc80      	pop	{r7}
    1d6c:	4770      	bx	lr
	...

00001d70 <pvPortMalloc>:
PRIVILEGED_DATA static size_t xNumberOfSuccessfulFrees = ( size_t ) 0U;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
    1d70:	b580      	push	{r7, lr}
    1d72:	b088      	sub	sp, #32
    1d74:	af00      	add	r7, sp, #0
    1d76:	6078      	str	r0, [r7, #4]
    BlockLink_t * pxBlock;
    BlockLink_t * pxPreviousBlock;
    BlockLink_t * pxNewBlockLink;
    void * pvReturn = NULL;
    1d78:	2300      	movs	r3, #0
    1d7a:	617b      	str	r3, [r7, #20]
    size_t xAdditionalRequiredSize;
    size_t xAllocatedBlockSize = 0;
    1d7c:	2300      	movs	r3, #0
    1d7e:	613b      	str	r3, [r7, #16]

    if( xWantedSize > 0 )
    1d80:	687b      	ldr	r3, [r7, #4]
    1d82:	2b00      	cmp	r3, #0
    1d84:	d022      	beq.n	1dcc <pvPortMalloc+0x5c>
    {
        /* The wanted size must be increased so it can contain a BlockLink_t
         * structure in addition to the requested amount of bytes. */
        if( heapADD_WILL_OVERFLOW( xWantedSize, xHeapStructSize ) == 0 )
    1d86:	2308      	movs	r3, #8
    1d88:	43db      	mvns	r3, r3
    1d8a:	687a      	ldr	r2, [r7, #4]
    1d8c:	429a      	cmp	r2, r3
    1d8e:	d81b      	bhi.n	1dc8 <pvPortMalloc+0x58>
        {
            xWantedSize += xHeapStructSize;
    1d90:	2208      	movs	r2, #8
    1d92:	687b      	ldr	r3, [r7, #4]
    1d94:	4413      	add	r3, r2
    1d96:	607b      	str	r3, [r7, #4]

            /* Ensure that blocks are always aligned to the required number
             * of bytes. */
            if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
    1d98:	687b      	ldr	r3, [r7, #4]
    1d9a:	f003 0307 	and.w	r3, r3, #7
    1d9e:	2b00      	cmp	r3, #0
    1da0:	d014      	beq.n	1dcc <pvPortMalloc+0x5c>
            {
                /* Byte alignment required. */
                xAdditionalRequiredSize = portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK );
    1da2:	687b      	ldr	r3, [r7, #4]
    1da4:	f003 0307 	and.w	r3, r3, #7
    1da8:	f1c3 0308 	rsb	r3, r3, #8
    1dac:	60fb      	str	r3, [r7, #12]

                if( heapADD_WILL_OVERFLOW( xWantedSize, xAdditionalRequiredSize ) == 0 )
    1dae:	68fb      	ldr	r3, [r7, #12]
    1db0:	43db      	mvns	r3, r3
    1db2:	687a      	ldr	r2, [r7, #4]
    1db4:	429a      	cmp	r2, r3
    1db6:	d804      	bhi.n	1dc2 <pvPortMalloc+0x52>
                {
                    xWantedSize += xAdditionalRequiredSize;
    1db8:	687a      	ldr	r2, [r7, #4]
    1dba:	68fb      	ldr	r3, [r7, #12]
    1dbc:	4413      	add	r3, r2
    1dbe:	607b      	str	r3, [r7, #4]
    1dc0:	e004      	b.n	1dcc <pvPortMalloc+0x5c>
                }
                else
                {
                    xWantedSize = 0;
    1dc2:	2300      	movs	r3, #0
    1dc4:	607b      	str	r3, [r7, #4]
    1dc6:	e001      	b.n	1dcc <pvPortMalloc+0x5c>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            xWantedSize = 0;
    1dc8:	2300      	movs	r3, #0
    1dca:	607b      	str	r3, [r7, #4]
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    vTaskSuspendAll();
    1dcc:	f7fe fc9e 	bl	70c <vTaskSuspendAll>
    {
        /* If this is the first call to malloc then the heap will require
         * initialisation to setup the list of free blocks. */
        if( pxEnd == NULL )
    1dd0:	4b3b      	ldr	r3, [pc, #236]	@ (1ec0 <pvPortMalloc+0x150>)
    1dd2:	681b      	ldr	r3, [r3, #0]
    1dd4:	2b00      	cmp	r3, #0
    1dd6:	d101      	bne.n	1ddc <pvPortMalloc+0x6c>
        {
            prvHeapInit();
    1dd8:	f000 f90e 	bl	1ff8 <prvHeapInit>

        /* Check the block size we are trying to allocate is not so large that the
         * top bit is set.  The top bit of the block size member of the BlockLink_t
         * structure is used to determine who owns the block - the application or
         * the kernel, so it must be free. */
        if( heapBLOCK_SIZE_IS_VALID( xWantedSize ) != 0 )
    1ddc:	687b      	ldr	r3, [r7, #4]
    1dde:	2b00      	cmp	r3, #0
    1de0:	db67      	blt.n	1eb2 <pvPortMalloc+0x142>
        {
            if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    1de2:	687b      	ldr	r3, [r7, #4]
    1de4:	2b00      	cmp	r3, #0
    1de6:	d064      	beq.n	1eb2 <pvPortMalloc+0x142>
    1de8:	4b36      	ldr	r3, [pc, #216]	@ (1ec4 <pvPortMalloc+0x154>)
    1dea:	681b      	ldr	r3, [r3, #0]
    1dec:	687a      	ldr	r2, [r7, #4]
    1dee:	429a      	cmp	r2, r3
    1df0:	d85f      	bhi.n	1eb2 <pvPortMalloc+0x142>
            {
                /* Traverse the list from the start (lowest address) block until
                 * one of adequate size is found. */
                pxPreviousBlock = &xStart;
    1df2:	4b35      	ldr	r3, [pc, #212]	@ (1ec8 <pvPortMalloc+0x158>)
    1df4:	61bb      	str	r3, [r7, #24]
                pxBlock = heapPROTECT_BLOCK_POINTER( xStart.pxNextFreeBlock );
    1df6:	4b34      	ldr	r3, [pc, #208]	@ (1ec8 <pvPortMalloc+0x158>)
    1df8:	681b      	ldr	r3, [r3, #0]
    1dfa:	61fb      	str	r3, [r7, #28]
                heapVALIDATE_BLOCK_POINTER( pxBlock );

                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != heapPROTECT_BLOCK_POINTER( NULL ) ) )
    1dfc:	e004      	b.n	1e08 <pvPortMalloc+0x98>
                {
                    pxPreviousBlock = pxBlock;
    1dfe:	69fb      	ldr	r3, [r7, #28]
    1e00:	61bb      	str	r3, [r7, #24]
                    pxBlock = heapPROTECT_BLOCK_POINTER( pxBlock->pxNextFreeBlock );
    1e02:	69fb      	ldr	r3, [r7, #28]
    1e04:	681b      	ldr	r3, [r3, #0]
    1e06:	61fb      	str	r3, [r7, #28]
                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != heapPROTECT_BLOCK_POINTER( NULL ) ) )
    1e08:	69fb      	ldr	r3, [r7, #28]
    1e0a:	685b      	ldr	r3, [r3, #4]
    1e0c:	687a      	ldr	r2, [r7, #4]
    1e0e:	429a      	cmp	r2, r3
    1e10:	d903      	bls.n	1e1a <pvPortMalloc+0xaa>
    1e12:	69fb      	ldr	r3, [r7, #28]
    1e14:	681b      	ldr	r3, [r3, #0]
    1e16:	2b00      	cmp	r3, #0
    1e18:	d1f1      	bne.n	1dfe <pvPortMalloc+0x8e>
                    heapVALIDATE_BLOCK_POINTER( pxBlock );
                }

                /* If the end marker was reached then a block of adequate size
                 * was not found. */
                if( pxBlock != pxEnd )
    1e1a:	4b29      	ldr	r3, [pc, #164]	@ (1ec0 <pvPortMalloc+0x150>)
    1e1c:	681b      	ldr	r3, [r3, #0]
    1e1e:	69fa      	ldr	r2, [r7, #28]
    1e20:	429a      	cmp	r2, r3
    1e22:	d046      	beq.n	1eb2 <pvPortMalloc+0x142>
                {
                    /* Return the memory space pointed to - jumping over the
                     * BlockLink_t structure at its start. */
                    pvReturn = ( void * ) ( ( ( uint8_t * ) heapPROTECT_BLOCK_POINTER( pxPreviousBlock->pxNextFreeBlock ) ) + xHeapStructSize );
    1e24:	69bb      	ldr	r3, [r7, #24]
    1e26:	681b      	ldr	r3, [r3, #0]
    1e28:	2208      	movs	r2, #8
    1e2a:	4413      	add	r3, r2
    1e2c:	617b      	str	r3, [r7, #20]
                    heapVALIDATE_BLOCK_POINTER( pvReturn );

                    /* This block is being returned for use so must be taken out
                     * of the list of free blocks. */
                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1e2e:	69fb      	ldr	r3, [r7, #28]
    1e30:	681a      	ldr	r2, [r3, #0]
    1e32:	69bb      	ldr	r3, [r7, #24]
    1e34:	601a      	str	r2, [r3, #0]

                    /* If the block is larger than required it can be split into
                     * two. */
                    configASSERT( heapSUBTRACT_WILL_UNDERFLOW( pxBlock->xBlockSize, xWantedSize ) == 0 );

                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1e36:	69fb      	ldr	r3, [r7, #28]
    1e38:	685a      	ldr	r2, [r3, #4]
    1e3a:	687b      	ldr	r3, [r7, #4]
    1e3c:	1ad2      	subs	r2, r2, r3
    1e3e:	2308      	movs	r3, #8
    1e40:	005b      	lsls	r3, r3, #1
    1e42:	429a      	cmp	r2, r3
    1e44:	d913      	bls.n	1e6e <pvPortMalloc+0xfe>
                    {
                        /* This block is to be split into two.  Create a new
                         * block following the number of bytes requested. The void
                         * cast is used to prevent byte alignment warnings from the
                         * compiler. */
                        pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    1e46:	69fa      	ldr	r2, [r7, #28]
    1e48:	687b      	ldr	r3, [r7, #4]
    1e4a:	4413      	add	r3, r2
    1e4c:	60bb      	str	r3, [r7, #8]
                        configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

                        /* Calculate the sizes of two blocks split from the
                         * single block. */
                        pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1e4e:	69fb      	ldr	r3, [r7, #28]
    1e50:	685a      	ldr	r2, [r3, #4]
    1e52:	687b      	ldr	r3, [r7, #4]
    1e54:	1ad2      	subs	r2, r2, r3
    1e56:	68bb      	ldr	r3, [r7, #8]
    1e58:	605a      	str	r2, [r3, #4]
                        pxBlock->xBlockSize = xWantedSize;
    1e5a:	69fb      	ldr	r3, [r7, #28]
    1e5c:	687a      	ldr	r2, [r7, #4]
    1e5e:	605a      	str	r2, [r3, #4]

                        /* Insert the new block into the list of free blocks. */
                        pxNewBlockLink->pxNextFreeBlock = pxPreviousBlock->pxNextFreeBlock;
    1e60:	69bb      	ldr	r3, [r7, #24]
    1e62:	681a      	ldr	r2, [r3, #0]
    1e64:	68bb      	ldr	r3, [r7, #8]
    1e66:	601a      	str	r2, [r3, #0]
                        pxPreviousBlock->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxNewBlockLink );
    1e68:	69bb      	ldr	r3, [r7, #24]
    1e6a:	68ba      	ldr	r2, [r7, #8]
    1e6c:	601a      	str	r2, [r3, #0]
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    xFreeBytesRemaining -= pxBlock->xBlockSize;
    1e6e:	4b15      	ldr	r3, [pc, #84]	@ (1ec4 <pvPortMalloc+0x154>)
    1e70:	681a      	ldr	r2, [r3, #0]
    1e72:	69fb      	ldr	r3, [r7, #28]
    1e74:	685b      	ldr	r3, [r3, #4]
    1e76:	1ad3      	subs	r3, r2, r3
    1e78:	4a12      	ldr	r2, [pc, #72]	@ (1ec4 <pvPortMalloc+0x154>)
    1e7a:	6013      	str	r3, [r2, #0]

                    if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    1e7c:	4b11      	ldr	r3, [pc, #68]	@ (1ec4 <pvPortMalloc+0x154>)
    1e7e:	681a      	ldr	r2, [r3, #0]
    1e80:	4b12      	ldr	r3, [pc, #72]	@ (1ecc <pvPortMalloc+0x15c>)
    1e82:	681b      	ldr	r3, [r3, #0]
    1e84:	429a      	cmp	r2, r3
    1e86:	d203      	bcs.n	1e90 <pvPortMalloc+0x120>
                    {
                        xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    1e88:	4b0e      	ldr	r3, [pc, #56]	@ (1ec4 <pvPortMalloc+0x154>)
    1e8a:	681b      	ldr	r3, [r3, #0]
    1e8c:	4a0f      	ldr	r2, [pc, #60]	@ (1ecc <pvPortMalloc+0x15c>)
    1e8e:	6013      	str	r3, [r2, #0]
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    xAllocatedBlockSize = pxBlock->xBlockSize;
    1e90:	69fb      	ldr	r3, [r7, #28]
    1e92:	685b      	ldr	r3, [r3, #4]
    1e94:	613b      	str	r3, [r7, #16]

                    /* The block is being returned - it is allocated and owned
                     * by the application and has no "next" block. */
                    heapALLOCATE_BLOCK( pxBlock );
    1e96:	69fb      	ldr	r3, [r7, #28]
    1e98:	685b      	ldr	r3, [r3, #4]
    1e9a:	f043 4200 	orr.w	r2, r3, #2147483648	@ 0x80000000
    1e9e:	69fb      	ldr	r3, [r7, #28]
    1ea0:	605a      	str	r2, [r3, #4]
                    pxBlock->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( NULL );
    1ea2:	69fb      	ldr	r3, [r7, #28]
    1ea4:	2200      	movs	r2, #0
    1ea6:	601a      	str	r2, [r3, #0]
                    xNumberOfSuccessfulAllocations++;
    1ea8:	4b09      	ldr	r3, [pc, #36]	@ (1ed0 <pvPortMalloc+0x160>)
    1eaa:	681b      	ldr	r3, [r3, #0]
    1eac:	3301      	adds	r3, #1
    1eae:	4a08      	ldr	r2, [pc, #32]	@ (1ed0 <pvPortMalloc+0x160>)
    1eb0:	6013      	str	r3, [r2, #0]
        traceMALLOC( pvReturn, xAllocatedBlockSize );

        /* Prevent compiler warnings when trace macros are not used. */
        ( void ) xAllocatedBlockSize;
    }
    ( void ) xTaskResumeAll();
    1eb2:	f7fe fc39 	bl	728 <xTaskResumeAll>
        }
    }
    #endif /* if ( configUSE_MALLOC_FAILED_HOOK == 1 ) */

    configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
    return pvReturn;
    1eb6:	697b      	ldr	r3, [r7, #20]
}
    1eb8:	4618      	mov	r0, r3
    1eba:	3720      	adds	r7, #32
    1ebc:	46bd      	mov	sp, r7
    1ebe:	bd80      	pop	{r7, pc}
    1ec0:	200010e4 	andcs	r1, r0, r4, ror #1
    1ec4:	200010e8 	andcs	r1, r0, r8, ror #1
    1ec8:	200010dc 	ldrdcs	r1, [r0], -ip
    1ecc:	200010ec 	andcs	r1, r0, ip, ror #1
    1ed0:	200010f0 	strdcs	r1, [r0], -r0

00001ed4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
    1ed4:	b580      	push	{r7, lr}
    1ed6:	b084      	sub	sp, #16
    1ed8:	af00      	add	r7, sp, #0
    1eda:	6078      	str	r0, [r7, #4]
    uint8_t * puc = ( uint8_t * ) pv;
    1edc:	687b      	ldr	r3, [r7, #4]
    1ede:	60fb      	str	r3, [r7, #12]
    BlockLink_t * pxLink;

    if( pv != NULL )
    1ee0:	687b      	ldr	r3, [r7, #4]
    1ee2:	2b00      	cmp	r3, #0
    1ee4:	d027      	beq.n	1f36 <vPortFree+0x62>
    {
        /* The memory being freed will have an BlockLink_t structure immediately
         * before it. */
        puc -= xHeapStructSize;
    1ee6:	2308      	movs	r3, #8
    1ee8:	425b      	negs	r3, r3
    1eea:	68fa      	ldr	r2, [r7, #12]
    1eec:	4413      	add	r3, r2
    1eee:	60fb      	str	r3, [r7, #12]

        /* This casting is to keep the compiler from issuing warnings. */
        pxLink = ( void * ) puc;
    1ef0:	68fb      	ldr	r3, [r7, #12]
    1ef2:	60bb      	str	r3, [r7, #8]

        heapVALIDATE_BLOCK_POINTER( pxLink );
        configASSERT( heapBLOCK_IS_ALLOCATED( pxLink ) != 0 );
        configASSERT( pxLink->pxNextFreeBlock == heapPROTECT_BLOCK_POINTER( NULL ) );

        if( heapBLOCK_IS_ALLOCATED( pxLink ) != 0 )
    1ef4:	68bb      	ldr	r3, [r7, #8]
    1ef6:	685b      	ldr	r3, [r3, #4]
    1ef8:	2b00      	cmp	r3, #0
    1efa:	da1c      	bge.n	1f36 <vPortFree+0x62>
        {
            if( pxLink->pxNextFreeBlock == heapPROTECT_BLOCK_POINTER( NULL ) )
    1efc:	68bb      	ldr	r3, [r7, #8]
    1efe:	681b      	ldr	r3, [r3, #0]
    1f00:	2b00      	cmp	r3, #0
    1f02:	d118      	bne.n	1f36 <vPortFree+0x62>
            {
                /* The block is being returned to the heap - it is no longer
                 * allocated. */
                heapFREE_BLOCK( pxLink );
    1f04:	68bb      	ldr	r3, [r7, #8]
    1f06:	685b      	ldr	r3, [r3, #4]
    1f08:	f023 4200 	bic.w	r2, r3, #2147483648	@ 0x80000000
    1f0c:	68bb      	ldr	r3, [r7, #8]
    1f0e:	605a      	str	r2, [r3, #4]
                        ( void ) memset( puc + xHeapStructSize, 0, pxLink->xBlockSize - xHeapStructSize );
                    }
                }
                #endif

                vTaskSuspendAll();
    1f10:	f7fe fbfc 	bl	70c <vTaskSuspendAll>
                {
                    /* Add this block to the list of free blocks. */
                    xFreeBytesRemaining += pxLink->xBlockSize;
    1f14:	68bb      	ldr	r3, [r7, #8]
    1f16:	685a      	ldr	r2, [r3, #4]
    1f18:	4b09      	ldr	r3, [pc, #36]	@ (1f40 <vPortFree+0x6c>)
    1f1a:	681b      	ldr	r3, [r3, #0]
    1f1c:	4413      	add	r3, r2
    1f1e:	4a08      	ldr	r2, [pc, #32]	@ (1f40 <vPortFree+0x6c>)
    1f20:	6013      	str	r3, [r2, #0]
                    traceFREE( pv, pxLink->xBlockSize );
                    prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    1f22:	68b8      	ldr	r0, [r7, #8]
    1f24:	f000 f8c2 	bl	20ac <prvInsertBlockIntoFreeList>
                    xNumberOfSuccessfulFrees++;
    1f28:	4b06      	ldr	r3, [pc, #24]	@ (1f44 <vPortFree+0x70>)
    1f2a:	681b      	ldr	r3, [r3, #0]
    1f2c:	3301      	adds	r3, #1
    1f2e:	4a05      	ldr	r2, [pc, #20]	@ (1f44 <vPortFree+0x70>)
    1f30:	6013      	str	r3, [r2, #0]
                }
                ( void ) xTaskResumeAll();
    1f32:	f7fe fbf9 	bl	728 <xTaskResumeAll>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
}
    1f36:	bf00      	nop
    1f38:	3710      	adds	r7, #16
    1f3a:	46bd      	mov	sp, r7
    1f3c:	bd80      	pop	{r7, pc}
    1f3e:	bf00      	nop
    1f40:	200010e8 	andcs	r1, r0, r8, ror #1
    1f44:	200010f4 	strdcs	r1, [r0], -r4

00001f48 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1f48:	b480      	push	{r7}
    1f4a:	af00      	add	r7, sp, #0
    return xFreeBytesRemaining;
    1f4c:	4b02      	ldr	r3, [pc, #8]	@ (1f58 <xPortGetFreeHeapSize+0x10>)
    1f4e:	681b      	ldr	r3, [r3, #0]
}
    1f50:	4618      	mov	r0, r3
    1f52:	46bd      	mov	sp, r7
    1f54:	bc80      	pop	{r7}
    1f56:	4770      	bx	lr
    1f58:	200010e8 	andcs	r1, r0, r8, ror #1

00001f5c <xPortGetMinimumEverFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetMinimumEverFreeHeapSize( void )
{
    1f5c:	b480      	push	{r7}
    1f5e:	af00      	add	r7, sp, #0
    return xMinimumEverFreeBytesRemaining;
    1f60:	4b02      	ldr	r3, [pc, #8]	@ (1f6c <xPortGetMinimumEverFreeHeapSize+0x10>)
    1f62:	681b      	ldr	r3, [r3, #0]
}
    1f64:	4618      	mov	r0, r3
    1f66:	46bd      	mov	sp, r7
    1f68:	bc80      	pop	{r7}
    1f6a:	4770      	bx	lr
    1f6c:	200010ec 	andcs	r1, r0, ip, ror #1

00001f70 <xPortResetHeapMinimumEverFreeHeapSize>:
/*-----------------------------------------------------------*/

void xPortResetHeapMinimumEverFreeHeapSize( void )
{
    1f70:	b480      	push	{r7}
    1f72:	af00      	add	r7, sp, #0
    xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    1f74:	4b03      	ldr	r3, [pc, #12]	@ (1f84 <xPortResetHeapMinimumEverFreeHeapSize+0x14>)
    1f76:	681b      	ldr	r3, [r3, #0]
    1f78:	4a03      	ldr	r2, [pc, #12]	@ (1f88 <xPortResetHeapMinimumEverFreeHeapSize+0x18>)
    1f7a:	6013      	str	r3, [r2, #0]
}
    1f7c:	bf00      	nop
    1f7e:	46bd      	mov	sp, r7
    1f80:	bc80      	pop	{r7}
    1f82:	4770      	bx	lr
    1f84:	200010e8 	andcs	r1, r0, r8, ror #1
    1f88:	200010ec 	andcs	r1, r0, ip, ror #1

00001f8c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    1f8c:	b480      	push	{r7}
    1f8e:	af00      	add	r7, sp, #0
    /* This just exists to keep the linker quiet. */
}
    1f90:	bf00      	nop
    1f92:	46bd      	mov	sp, r7
    1f94:	bc80      	pop	{r7}
    1f96:	4770      	bx	lr

00001f98 <pvPortCalloc>:
/*-----------------------------------------------------------*/

void * pvPortCalloc( size_t xNum,
                     size_t xSize )
{
    1f98:	b580      	push	{r7, lr}
    1f9a:	b084      	sub	sp, #16
    1f9c:	af00      	add	r7, sp, #0
    1f9e:	6078      	str	r0, [r7, #4]
    1fa0:	6039      	str	r1, [r7, #0]
    void * pv = NULL;
    1fa2:	2300      	movs	r3, #0
    1fa4:	60fb      	str	r3, [r7, #12]

    if( heapMULTIPLY_WILL_OVERFLOW( xNum, xSize ) == 0 )
    1fa6:	687b      	ldr	r3, [r7, #4]
    1fa8:	2b00      	cmp	r3, #0
    1faa:	d009      	beq.n	1fc0 <pvPortCalloc+0x28>
    1fac:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
    1fb0:	687b      	ldr	r3, [r7, #4]
    1fb2:	fbb2 f3f3 	udiv	r3, r2, r3
    1fb6:	683a      	ldr	r2, [r7, #0]
    1fb8:	429a      	cmp	r2, r3
    1fba:	d901      	bls.n	1fc0 <pvPortCalloc+0x28>
    1fbc:	2301      	movs	r3, #1
    1fbe:	e000      	b.n	1fc2 <pvPortCalloc+0x2a>
    1fc0:	2300      	movs	r3, #0
    1fc2:	2b00      	cmp	r3, #0
    1fc4:	d113      	bne.n	1fee <pvPortCalloc+0x56>
    {
        pv = pvPortMalloc( xNum * xSize );
    1fc6:	687b      	ldr	r3, [r7, #4]
    1fc8:	683a      	ldr	r2, [r7, #0]
    1fca:	fb02 f303 	mul.w	r3, r2, r3
    1fce:	4618      	mov	r0, r3
    1fd0:	f7ff fece 	bl	1d70 <pvPortMalloc>
    1fd4:	60f8      	str	r0, [r7, #12]

        if( pv != NULL )
    1fd6:	68fb      	ldr	r3, [r7, #12]
    1fd8:	2b00      	cmp	r3, #0
    1fda:	d008      	beq.n	1fee <pvPortCalloc+0x56>
        {
            ( void ) memset( pv, 0, xNum * xSize );
    1fdc:	687b      	ldr	r3, [r7, #4]
    1fde:	683a      	ldr	r2, [r7, #0]
    1fe0:	fb02 f303 	mul.w	r3, r2, r3
    1fe4:	461a      	mov	r2, r3
    1fe6:	2100      	movs	r1, #0
    1fe8:	68f8      	ldr	r0, [r7, #12]
    1fea:	f7fe f97b 	bl	2e4 <memset>
        }
    }

    return pv;
    1fee:	68fb      	ldr	r3, [r7, #12]
}
    1ff0:	4618      	mov	r0, r3
    1ff2:	3710      	adds	r7, #16
    1ff4:	46bd      	mov	sp, r7
    1ff6:	bd80      	pop	{r7, pc}

00001ff8 <prvHeapInit>:
/*-----------------------------------------------------------*/

static void prvHeapInit( void ) /* PRIVILEGED_FUNCTION */
{
    1ff8:	b480      	push	{r7}
    1ffa:	b085      	sub	sp, #20
    1ffc:	af00      	add	r7, sp, #0
    BlockLink_t * pxFirstFreeBlock;
    portPOINTER_SIZE_TYPE uxStartAddress, uxEndAddress;
    size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
    1ffe:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
    2002:	60bb      	str	r3, [r7, #8]

    /* Ensure the heap starts on a correctly aligned boundary. */
    uxStartAddress = ( portPOINTER_SIZE_TYPE ) ucHeap;
    2004:	4b24      	ldr	r3, [pc, #144]	@ (2098 <prvHeapInit+0xa0>)
    2006:	60fb      	str	r3, [r7, #12]

    if( ( uxStartAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
    2008:	68fb      	ldr	r3, [r7, #12]
    200a:	f003 0307 	and.w	r3, r3, #7
    200e:	2b00      	cmp	r3, #0
    2010:	d00c      	beq.n	202c <prvHeapInit+0x34>
    {
        uxStartAddress += ( portBYTE_ALIGNMENT - 1 );
    2012:	68fb      	ldr	r3, [r7, #12]
    2014:	3307      	adds	r3, #7
    2016:	60fb      	str	r3, [r7, #12]
        uxStartAddress &= ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK );
    2018:	68fb      	ldr	r3, [r7, #12]
    201a:	f023 0307 	bic.w	r3, r3, #7
    201e:	60fb      	str	r3, [r7, #12]
        xTotalHeapSize -= ( size_t ) ( uxStartAddress - ( portPOINTER_SIZE_TYPE ) ucHeap );
    2020:	68ba      	ldr	r2, [r7, #8]
    2022:	68fb      	ldr	r3, [r7, #12]
    2024:	1ad3      	subs	r3, r2, r3
    2026:	4a1c      	ldr	r2, [pc, #112]	@ (2098 <prvHeapInit+0xa0>)
    2028:	4413      	add	r3, r2
    202a:	60bb      	str	r3, [r7, #8]
    }
    #endif

    /* xStart is used to hold a pointer to the first item in the list of free
     * blocks.  The void cast is used to prevent compiler warnings. */
    xStart.pxNextFreeBlock = ( void * ) heapPROTECT_BLOCK_POINTER( uxStartAddress );
    202c:	68fb      	ldr	r3, [r7, #12]
    202e:	4a1b      	ldr	r2, [pc, #108]	@ (209c <prvHeapInit+0xa4>)
    2030:	6013      	str	r3, [r2, #0]
    xStart.xBlockSize = ( size_t ) 0;
    2032:	4b1a      	ldr	r3, [pc, #104]	@ (209c <prvHeapInit+0xa4>)
    2034:	2200      	movs	r2, #0
    2036:	605a      	str	r2, [r3, #4]

    /* pxEnd is used to mark the end of the list of free blocks and is inserted
     * at the end of the heap space. */
    uxEndAddress = uxStartAddress + ( portPOINTER_SIZE_TYPE ) xTotalHeapSize;
    2038:	68fa      	ldr	r2, [r7, #12]
    203a:	68bb      	ldr	r3, [r7, #8]
    203c:	4413      	add	r3, r2
    203e:	607b      	str	r3, [r7, #4]
    uxEndAddress -= ( portPOINTER_SIZE_TYPE ) xHeapStructSize;
    2040:	2208      	movs	r2, #8
    2042:	687b      	ldr	r3, [r7, #4]
    2044:	1a9b      	subs	r3, r3, r2
    2046:	607b      	str	r3, [r7, #4]
    uxEndAddress &= ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK );
    2048:	687b      	ldr	r3, [r7, #4]
    204a:	f023 0307 	bic.w	r3, r3, #7
    204e:	607b      	str	r3, [r7, #4]
    pxEnd = ( BlockLink_t * ) uxEndAddress;
    2050:	687b      	ldr	r3, [r7, #4]
    2052:	4a13      	ldr	r2, [pc, #76]	@ (20a0 <prvHeapInit+0xa8>)
    2054:	6013      	str	r3, [r2, #0]
    pxEnd->xBlockSize = 0;
    2056:	4b12      	ldr	r3, [pc, #72]	@ (20a0 <prvHeapInit+0xa8>)
    2058:	681b      	ldr	r3, [r3, #0]
    205a:	2200      	movs	r2, #0
    205c:	605a      	str	r2, [r3, #4]
    pxEnd->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( NULL );
    205e:	4b10      	ldr	r3, [pc, #64]	@ (20a0 <prvHeapInit+0xa8>)
    2060:	681b      	ldr	r3, [r3, #0]
    2062:	2200      	movs	r2, #0
    2064:	601a      	str	r2, [r3, #0]

    /* To start with there is a single free block that is sized to take up the
     * entire heap space, minus the space taken by pxEnd. */
    pxFirstFreeBlock = ( BlockLink_t * ) uxStartAddress;
    2066:	68fb      	ldr	r3, [r7, #12]
    2068:	603b      	str	r3, [r7, #0]
    pxFirstFreeBlock->xBlockSize = ( size_t ) ( uxEndAddress - ( portPOINTER_SIZE_TYPE ) pxFirstFreeBlock );
    206a:	683b      	ldr	r3, [r7, #0]
    206c:	687a      	ldr	r2, [r7, #4]
    206e:	1ad2      	subs	r2, r2, r3
    2070:	683b      	ldr	r3, [r7, #0]
    2072:	605a      	str	r2, [r3, #4]
    pxFirstFreeBlock->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxEnd );
    2074:	4b0a      	ldr	r3, [pc, #40]	@ (20a0 <prvHeapInit+0xa8>)
    2076:	681a      	ldr	r2, [r3, #0]
    2078:	683b      	ldr	r3, [r7, #0]
    207a:	601a      	str	r2, [r3, #0]

    /* Only one block exists - and it covers the entire usable heap space. */
    xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    207c:	683b      	ldr	r3, [r7, #0]
    207e:	685b      	ldr	r3, [r3, #4]
    2080:	4a08      	ldr	r2, [pc, #32]	@ (20a4 <prvHeapInit+0xac>)
    2082:	6013      	str	r3, [r2, #0]
    xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    2084:	683b      	ldr	r3, [r7, #0]
    2086:	685b      	ldr	r3, [r3, #4]
    2088:	4a07      	ldr	r2, [pc, #28]	@ (20a8 <prvHeapInit+0xb0>)
    208a:	6013      	str	r3, [r2, #0]
}
    208c:	bf00      	nop
    208e:	3714      	adds	r7, #20
    2090:	46bd      	mov	sp, r7
    2092:	bc80      	pop	{r7}
    2094:	4770      	bx	lr
    2096:	bf00      	nop
    2098:	200000dc 	ldrdcs	r0, [r0], -ip
    209c:	200010dc 	ldrdcs	r1, [r0], -ip
    20a0:	200010e4 	andcs	r1, r0, r4, ror #1
    20a4:	200010ec 	andcs	r1, r0, ip, ror #1
    20a8:	200010e8 	andcs	r1, r0, r8, ror #1

000020ac <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t * pxBlockToInsert ) /* PRIVILEGED_FUNCTION */
{
    20ac:	b480      	push	{r7}
    20ae:	b085      	sub	sp, #20
    20b0:	af00      	add	r7, sp, #0
    20b2:	6078      	str	r0, [r7, #4]
    BlockLink_t * pxIterator;
    uint8_t * puc;

    /* Iterate through the list until a block is found that has a higher address
     * than the block being inserted. */
    for( pxIterator = &xStart; heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) < pxBlockToInsert; pxIterator = heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) )
    20b4:	4b27      	ldr	r3, [pc, #156]	@ (2154 <prvInsertBlockIntoFreeList+0xa8>)
    20b6:	60fb      	str	r3, [r7, #12]
    20b8:	e002      	b.n	20c0 <prvInsertBlockIntoFreeList+0x14>
    20ba:	68fb      	ldr	r3, [r7, #12]
    20bc:	681b      	ldr	r3, [r3, #0]
    20be:	60fb      	str	r3, [r7, #12]
    20c0:	68fb      	ldr	r3, [r7, #12]
    20c2:	681b      	ldr	r3, [r3, #0]
    20c4:	687a      	ldr	r2, [r7, #4]
    20c6:	429a      	cmp	r2, r3
    20c8:	d8f7      	bhi.n	20ba <prvInsertBlockIntoFreeList+0xe>
        heapVALIDATE_BLOCK_POINTER( pxIterator );
    }

    /* Do the block being inserted, and the block it is being inserted after
     * make a contiguous block of memory? */
    puc = ( uint8_t * ) pxIterator;
    20ca:	68fb      	ldr	r3, [r7, #12]
    20cc:	60bb      	str	r3, [r7, #8]

    if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    20ce:	68fb      	ldr	r3, [r7, #12]
    20d0:	685b      	ldr	r3, [r3, #4]
    20d2:	68ba      	ldr	r2, [r7, #8]
    20d4:	4413      	add	r3, r2
    20d6:	687a      	ldr	r2, [r7, #4]
    20d8:	429a      	cmp	r2, r3
    20da:	d108      	bne.n	20ee <prvInsertBlockIntoFreeList+0x42>
    {
        pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    20dc:	68fb      	ldr	r3, [r7, #12]
    20de:	685a      	ldr	r2, [r3, #4]
    20e0:	687b      	ldr	r3, [r7, #4]
    20e2:	685b      	ldr	r3, [r3, #4]
    20e4:	441a      	add	r2, r3
    20e6:	68fb      	ldr	r3, [r7, #12]
    20e8:	605a      	str	r2, [r3, #4]
        pxBlockToInsert = pxIterator;
    20ea:	68fb      	ldr	r3, [r7, #12]
    20ec:	607b      	str	r3, [r7, #4]
        mtCOVERAGE_TEST_MARKER();
    }

    /* Do the block being inserted, and the block it is being inserted before
     * make a contiguous block of memory? */
    puc = ( uint8_t * ) pxBlockToInsert;
    20ee:	687b      	ldr	r3, [r7, #4]
    20f0:	60bb      	str	r3, [r7, #8]

    if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) )
    20f2:	687b      	ldr	r3, [r7, #4]
    20f4:	685b      	ldr	r3, [r3, #4]
    20f6:	68ba      	ldr	r2, [r7, #8]
    20f8:	441a      	add	r2, r3
    20fa:	68fb      	ldr	r3, [r7, #12]
    20fc:	681b      	ldr	r3, [r3, #0]
    20fe:	429a      	cmp	r2, r3
    2100:	d118      	bne.n	2134 <prvInsertBlockIntoFreeList+0x88>
    {
        if( heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) != pxEnd )
    2102:	68fb      	ldr	r3, [r7, #12]
    2104:	681a      	ldr	r2, [r3, #0]
    2106:	4b14      	ldr	r3, [pc, #80]	@ (2158 <prvInsertBlockIntoFreeList+0xac>)
    2108:	681b      	ldr	r3, [r3, #0]
    210a:	429a      	cmp	r2, r3
    210c:	d00d      	beq.n	212a <prvInsertBlockIntoFreeList+0x7e>
        {
            /* Form one big block from the two blocks. */
            pxBlockToInsert->xBlockSize += heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock )->xBlockSize;
    210e:	687b      	ldr	r3, [r7, #4]
    2110:	685a      	ldr	r2, [r3, #4]
    2112:	68fb      	ldr	r3, [r7, #12]
    2114:	681b      	ldr	r3, [r3, #0]
    2116:	685b      	ldr	r3, [r3, #4]
    2118:	441a      	add	r2, r3
    211a:	687b      	ldr	r3, [r7, #4]
    211c:	605a      	str	r2, [r3, #4]
            pxBlockToInsert->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock )->pxNextFreeBlock;
    211e:	68fb      	ldr	r3, [r7, #12]
    2120:	681b      	ldr	r3, [r3, #0]
    2122:	681a      	ldr	r2, [r3, #0]
    2124:	687b      	ldr	r3, [r7, #4]
    2126:	601a      	str	r2, [r3, #0]
    2128:	e008      	b.n	213c <prvInsertBlockIntoFreeList+0x90>
        }
        else
        {
            pxBlockToInsert->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxEnd );
    212a:	4b0b      	ldr	r3, [pc, #44]	@ (2158 <prvInsertBlockIntoFreeList+0xac>)
    212c:	681a      	ldr	r2, [r3, #0]
    212e:	687b      	ldr	r3, [r7, #4]
    2130:	601a      	str	r2, [r3, #0]
    2132:	e003      	b.n	213c <prvInsertBlockIntoFreeList+0x90>
        }
    }
    else
    {
        pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    2134:	68fb      	ldr	r3, [r7, #12]
    2136:	681a      	ldr	r2, [r3, #0]
    2138:	687b      	ldr	r3, [r7, #4]
    213a:	601a      	str	r2, [r3, #0]

    /* If the block being inserted plugged a gap, so was merged with the block
     * before and the block after, then it's pxNextFreeBlock pointer will have
     * already been set, and should not be set here as that would make it point
     * to itself. */
    if( pxIterator != pxBlockToInsert )
    213c:	68fa      	ldr	r2, [r7, #12]
    213e:	687b      	ldr	r3, [r7, #4]
    2140:	429a      	cmp	r2, r3
    2142:	d002      	beq.n	214a <prvInsertBlockIntoFreeList+0x9e>
    {
        pxIterator->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxBlockToInsert );
    2144:	68fb      	ldr	r3, [r7, #12]
    2146:	687a      	ldr	r2, [r7, #4]
    2148:	601a      	str	r2, [r3, #0]
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    214a:	bf00      	nop
    214c:	3714      	adds	r7, #20
    214e:	46bd      	mov	sp, r7
    2150:	bc80      	pop	{r7}
    2152:	4770      	bx	lr
    2154:	200010dc 	ldrdcs	r1, [r0], -ip
    2158:	200010e4 	andcs	r1, r0, r4, ror #1

0000215c <vPortGetHeapStats>:
/*-----------------------------------------------------------*/

void vPortGetHeapStats( HeapStats_t * pxHeapStats )
{
    215c:	b580      	push	{r7, lr}
    215e:	b086      	sub	sp, #24
    2160:	af00      	add	r7, sp, #0
    2162:	6078      	str	r0, [r7, #4]
    BlockLink_t * pxBlock;
    size_t xBlocks = 0, xMaxSize = 0, xMinSize = portMAX_DELAY; /* portMAX_DELAY used as a portable way of getting the maximum value. */
    2164:	2300      	movs	r3, #0
    2166:	613b      	str	r3, [r7, #16]
    2168:	2300      	movs	r3, #0
    216a:	60fb      	str	r3, [r7, #12]
    216c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
    2170:	60bb      	str	r3, [r7, #8]

    vTaskSuspendAll();
    2172:	f7fe facb 	bl	70c <vTaskSuspendAll>
    {
        pxBlock = heapPROTECT_BLOCK_POINTER( xStart.pxNextFreeBlock );
    2176:	4b22      	ldr	r3, [pc, #136]	@ (2200 <vPortGetHeapStats+0xa4>)
    2178:	681b      	ldr	r3, [r3, #0]
    217a:	617b      	str	r3, [r7, #20]

        /* pxBlock will be NULL if the heap has not been initialised.  The heap
         * is initialised automatically when the first allocation is made. */
        if( pxBlock != NULL )
    217c:	697b      	ldr	r3, [r7, #20]
    217e:	2b00      	cmp	r3, #0
    2180:	d01b      	beq.n	21ba <vPortGetHeapStats+0x5e>
        {
            while( pxBlock != pxEnd )
    2182:	e015      	b.n	21b0 <vPortGetHeapStats+0x54>
            {
                /* Increment the number of blocks and record the largest block seen
                 * so far. */
                xBlocks++;
    2184:	693b      	ldr	r3, [r7, #16]
    2186:	3301      	adds	r3, #1
    2188:	613b      	str	r3, [r7, #16]

                if( pxBlock->xBlockSize > xMaxSize )
    218a:	697b      	ldr	r3, [r7, #20]
    218c:	685b      	ldr	r3, [r3, #4]
    218e:	68fa      	ldr	r2, [r7, #12]
    2190:	429a      	cmp	r2, r3
    2192:	d202      	bcs.n	219a <vPortGetHeapStats+0x3e>
                {
                    xMaxSize = pxBlock->xBlockSize;
    2194:	697b      	ldr	r3, [r7, #20]
    2196:	685b      	ldr	r3, [r3, #4]
    2198:	60fb      	str	r3, [r7, #12]
                }

                if( pxBlock->xBlockSize < xMinSize )
    219a:	697b      	ldr	r3, [r7, #20]
    219c:	685b      	ldr	r3, [r3, #4]
    219e:	68ba      	ldr	r2, [r7, #8]
    21a0:	429a      	cmp	r2, r3
    21a2:	d902      	bls.n	21aa <vPortGetHeapStats+0x4e>
                {
                    xMinSize = pxBlock->xBlockSize;
    21a4:	697b      	ldr	r3, [r7, #20]
    21a6:	685b      	ldr	r3, [r3, #4]
    21a8:	60bb      	str	r3, [r7, #8]
                }

                /* Move to the next block in the chain until the last block is
                 * reached. */
                pxBlock = heapPROTECT_BLOCK_POINTER( pxBlock->pxNextFreeBlock );
    21aa:	697b      	ldr	r3, [r7, #20]
    21ac:	681b      	ldr	r3, [r3, #0]
    21ae:	617b      	str	r3, [r7, #20]
            while( pxBlock != pxEnd )
    21b0:	4b14      	ldr	r3, [pc, #80]	@ (2204 <vPortGetHeapStats+0xa8>)
    21b2:	681b      	ldr	r3, [r3, #0]
    21b4:	697a      	ldr	r2, [r7, #20]
    21b6:	429a      	cmp	r2, r3
    21b8:	d1e4      	bne.n	2184 <vPortGetHeapStats+0x28>
            }
        }
    }
    ( void ) xTaskResumeAll();
    21ba:	f7fe fab5 	bl	728 <xTaskResumeAll>

    pxHeapStats->xSizeOfLargestFreeBlockInBytes = xMaxSize;
    21be:	687b      	ldr	r3, [r7, #4]
    21c0:	68fa      	ldr	r2, [r7, #12]
    21c2:	605a      	str	r2, [r3, #4]
    pxHeapStats->xSizeOfSmallestFreeBlockInBytes = xMinSize;
    21c4:	687b      	ldr	r3, [r7, #4]
    21c6:	68ba      	ldr	r2, [r7, #8]
    21c8:	609a      	str	r2, [r3, #8]
    pxHeapStats->xNumberOfFreeBlocks = xBlocks;
    21ca:	687b      	ldr	r3, [r7, #4]
    21cc:	693a      	ldr	r2, [r7, #16]
    21ce:	60da      	str	r2, [r3, #12]

    taskENTER_CRITICAL();
    21d0:	f000 f8de 	bl	2390 <vPortEnterCritical>
    {
        pxHeapStats->xAvailableHeapSpaceInBytes = xFreeBytesRemaining;
    21d4:	4b0c      	ldr	r3, [pc, #48]	@ (2208 <vPortGetHeapStats+0xac>)
    21d6:	681a      	ldr	r2, [r3, #0]
    21d8:	687b      	ldr	r3, [r7, #4]
    21da:	601a      	str	r2, [r3, #0]
        pxHeapStats->xNumberOfSuccessfulAllocations = xNumberOfSuccessfulAllocations;
    21dc:	4b0b      	ldr	r3, [pc, #44]	@ (220c <vPortGetHeapStats+0xb0>)
    21de:	681a      	ldr	r2, [r3, #0]
    21e0:	687b      	ldr	r3, [r7, #4]
    21e2:	615a      	str	r2, [r3, #20]
        pxHeapStats->xNumberOfSuccessfulFrees = xNumberOfSuccessfulFrees;
    21e4:	4b0a      	ldr	r3, [pc, #40]	@ (2210 <vPortGetHeapStats+0xb4>)
    21e6:	681a      	ldr	r2, [r3, #0]
    21e8:	687b      	ldr	r3, [r7, #4]
    21ea:	619a      	str	r2, [r3, #24]
        pxHeapStats->xMinimumEverFreeBytesRemaining = xMinimumEverFreeBytesRemaining;
    21ec:	4b09      	ldr	r3, [pc, #36]	@ (2214 <vPortGetHeapStats+0xb8>)
    21ee:	681a      	ldr	r2, [r3, #0]
    21f0:	687b      	ldr	r3, [r7, #4]
    21f2:	611a      	str	r2, [r3, #16]
    }
    taskEXIT_CRITICAL();
    21f4:	f000 f8e6 	bl	23c4 <vPortExitCritical>
}
    21f8:	bf00      	nop
    21fa:	3718      	adds	r7, #24
    21fc:	46bd      	mov	sp, r7
    21fe:	bd80      	pop	{r7, pc}
    2200:	200010dc 	ldrdcs	r1, [r0], -ip
    2204:	200010e4 	andcs	r1, r0, r4, ror #1
    2208:	200010e8 	andcs	r1, r0, r8, ror #1
    220c:	200010f0 	strdcs	r1, [r0], -r0
    2210:	200010f4 	strdcs	r1, [r0], -r4
    2214:	200010ec 	andcs	r1, r0, ip, ror #1

00002218 <vPortHeapResetState>:
 * Reset the state in this file. This state is normally initialized at start up.
 * This function must be called by the application before restarting the
 * scheduler.
 */
void vPortHeapResetState( void )
{
    2218:	b480      	push	{r7}
    221a:	af00      	add	r7, sp, #0
    pxEnd = NULL;
    221c:	4b09      	ldr	r3, [pc, #36]	@ (2244 <vPortHeapResetState+0x2c>)
    221e:	2200      	movs	r2, #0
    2220:	601a      	str	r2, [r3, #0]

    xFreeBytesRemaining = ( size_t ) 0U;
    2222:	4b09      	ldr	r3, [pc, #36]	@ (2248 <vPortHeapResetState+0x30>)
    2224:	2200      	movs	r2, #0
    2226:	601a      	str	r2, [r3, #0]
    xMinimumEverFreeBytesRemaining = ( size_t ) 0U;
    2228:	4b08      	ldr	r3, [pc, #32]	@ (224c <vPortHeapResetState+0x34>)
    222a:	2200      	movs	r2, #0
    222c:	601a      	str	r2, [r3, #0]
    xNumberOfSuccessfulAllocations = ( size_t ) 0U;
    222e:	4b08      	ldr	r3, [pc, #32]	@ (2250 <vPortHeapResetState+0x38>)
    2230:	2200      	movs	r2, #0
    2232:	601a      	str	r2, [r3, #0]
    xNumberOfSuccessfulFrees = ( size_t ) 0U;
    2234:	4b07      	ldr	r3, [pc, #28]	@ (2254 <vPortHeapResetState+0x3c>)
    2236:	2200      	movs	r2, #0
    2238:	601a      	str	r2, [r3, #0]
}
    223a:	bf00      	nop
    223c:	46bd      	mov	sp, r7
    223e:	bc80      	pop	{r7}
    2240:	4770      	bx	lr
    2242:	bf00      	nop
    2244:	200010e4 	andcs	r1, r0, r4, ror #1
    2248:	200010e8 	andcs	r1, r0, r8, ror #1
    224c:	200010ec 	andcs	r1, r0, ip, ror #1
    2250:	200010f0 	strdcs	r1, [r0], -r0
    2254:	200010f4 	strdcs	r1, [r0], -r4

00002258 <pxPortInitialiseStack>:
 * See header file for description.
 */
StackType_t * pxPortInitialiseStack( StackType_t * pxTopOfStack,
                                     TaskFunction_t pxCode,
                                     void * pvParameters )
{
    2258:	b480      	push	{r7}
    225a:	b085      	sub	sp, #20
    225c:	af00      	add	r7, sp, #0
    225e:	60f8      	str	r0, [r7, #12]
    2260:	60b9      	str	r1, [r7, #8]
    2262:	607a      	str	r2, [r7, #4]
    /* Simulate the stack frame as it would be created by a context switch
     * interrupt. */
    pxTopOfStack--;                                                      /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
    2264:	68fb      	ldr	r3, [r7, #12]
    2266:	3b04      	subs	r3, #4
    2268:	60fb      	str	r3, [r7, #12]
    *pxTopOfStack = portINITIAL_XPSR;                                    /* xPSR */
    226a:	68fb      	ldr	r3, [r7, #12]
    226c:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
    2270:	601a      	str	r2, [r3, #0]
    pxTopOfStack--;
    2272:	68fb      	ldr	r3, [r7, #12]
    2274:	3b04      	subs	r3, #4
    2276:	60fb      	str	r3, [r7, #12]
    *pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK; /* PC */
    2278:	68bb      	ldr	r3, [r7, #8]
    227a:	f023 0201 	bic.w	r2, r3, #1
    227e:	68fb      	ldr	r3, [r7, #12]
    2280:	601a      	str	r2, [r3, #0]
    pxTopOfStack--;
    2282:	68fb      	ldr	r3, [r7, #12]
    2284:	3b04      	subs	r3, #4
    2286:	60fb      	str	r3, [r7, #12]
    *pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;             /* LR */
    2288:	4a08      	ldr	r2, [pc, #32]	@ (22ac <pxPortInitialiseStack+0x54>)
    228a:	68fb      	ldr	r3, [r7, #12]
    228c:	601a      	str	r2, [r3, #0]
    pxTopOfStack -= 5;                                                   /* R12, R3, R2 and R1. */
    228e:	68fb      	ldr	r3, [r7, #12]
    2290:	3b14      	subs	r3, #20
    2292:	60fb      	str	r3, [r7, #12]
    *pxTopOfStack = ( StackType_t ) pvParameters;                        /* R0 */
    2294:	687a      	ldr	r2, [r7, #4]
    2296:	68fb      	ldr	r3, [r7, #12]
    2298:	601a      	str	r2, [r3, #0]
    pxTopOfStack -= 8;                                                   /* R11, R10, R9, R8, R7, R6, R5 and R4. */
    229a:	68fb      	ldr	r3, [r7, #12]
    229c:	3b20      	subs	r3, #32
    229e:	60fb      	str	r3, [r7, #12]

    return pxTopOfStack;
    22a0:	68fb      	ldr	r3, [r7, #12]
}
    22a2:	4618      	mov	r0, r3
    22a4:	3714      	adds	r7, #20
    22a6:	46bd      	mov	sp, r7
    22a8:	bc80      	pop	{r7}
    22aa:	4770      	bx	lr
    22ac:	000022b1 			@ <UNDEFINED> instruction: 0x000022b1

000022b0 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
    22b0:	b480      	push	{r7}
    22b2:	b083      	sub	sp, #12
    22b4:	af00      	add	r7, sp, #0
    volatile uint32_t ulDummy = 0UL;
    22b6:	2300      	movs	r3, #0
    22b8:	603b      	str	r3, [r7, #0]
    __asm volatile
    22ba:	f04f 0301 	mov.w	r3, #1
    22be:	f383 8811 	msr	BASEPRI, r3
    22c2:	f3bf 8f6f 	isb	sy
    22c6:	f3bf 8f4f 	dsb	sy
    22ca:	607b      	str	r3, [r7, #4]
}
    22cc:	bf00      	nop
     * Artificially force an assert() to be triggered if configASSERT() is
     * defined, then stop here so application writers can catch the error. */
    configASSERT( uxCriticalNesting == ~0UL );
    portDISABLE_INTERRUPTS();

    while( ulDummy == 0 )
    22ce:	bf00      	nop
    22d0:	683b      	ldr	r3, [r7, #0]
    22d2:	2b00      	cmp	r3, #0
    22d4:	d0fc      	beq.n	22d0 <prvTaskExitError+0x20>
         * about code appearing after this function is called - making ulDummy
         * volatile makes the compiler think the function could return and
         * therefore not output an 'unreachable code' warning for code that appears
         * after it. */
    }
}
    22d6:	bf00      	nop
    22d8:	bf00      	nop
    22da:	370c      	adds	r7, #12
    22dc:	46bd      	mov	sp, r7
    22de:	bc80      	pop	{r7}
    22e0:	4770      	bx	lr

000022e2 <vPortSVCHandler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
    __asm volatile (
    22e2:	4b08      	ldr	r3, [pc, #32]	@ (2304 <vPortSVCHandler+0x22>)
    22e4:	6819      	ldr	r1, [r3, #0]
    22e6:	6808      	ldr	r0, [r1, #0]
    22e8:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
    22ec:	f380 8809 	msr	PSP, r0
    22f0:	f3bf 8f6f 	isb	sy
    22f4:	f04f 0000 	mov.w	r0, #0
    22f8:	f380 8811 	msr	BASEPRI, r0
    22fc:	f04e 0e0d 	orr.w	lr, lr, #13
    2300:	4770      	bx	lr
    2302:	00040000 	andeq	r0, r4, r0
    2306:	bf002000 	svclt	0x00002000

0000230a <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
    __asm volatile (
    230a:	4806      	ldr	r0, [pc, #24]	@ (2324 <prvPortStartFirstTask+0x1a>)
    230c:	6800      	ldr	r0, [r0, #0]
    230e:	6800      	ldr	r0, [r0, #0]
    2310:	f380 8808 	msr	MSP, r0
    2314:	b662      	cpsie	i
    2316:	b661      	cpsie	f
    2318:	f3bf 8f4f 	dsb	sy
    231c:	f3bf 8f6f 	isb	sy
    2320:	df00      	svc	0
    2322:	bf00      	nop
    2324:	e000ed08 	and	lr, r0, r8, lsl #26
        " isb                   \n"
        " svc 0                 \n" /* System call to start first task. */
        " nop                   \n"
        " .ltorg                \n"
        );
}
    2328:	bf00      	nop

0000232a <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
    232a:	b580      	push	{r7, lr}
    232c:	b082      	sub	sp, #8
    232e:	af00      	add	r7, sp, #0
     * configCHECK_HANDLER_INSTALLATION to 0 in their FreeRTOSConfig.h. Direct
     * routing, which is validated here when configCHECK_HANDLER_INSTALLATION
     * is 1, should be preferred when possible. */
    #if ( configCHECK_HANDLER_INSTALLATION == 1 )
    {
        const portISR_t * const pxVectorTable = portSCB_VTOR_REG;
    2330:	4b10      	ldr	r3, [pc, #64]	@ (2374 <xPortStartScheduler+0x4a>)
    2332:	681b      	ldr	r3, [r3, #0]
    2334:	607b      	str	r3, [r7, #4]
    }
    #endif /* configASSERT_DEFINED */

    /* Make PendSV and SysTick the lowest priority interrupts, and make SVCall
     * the highest priority. */
    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;
    2336:	4b10      	ldr	r3, [pc, #64]	@ (2378 <xPortStartScheduler+0x4e>)
    2338:	681b      	ldr	r3, [r3, #0]
    233a:	4a0f      	ldr	r2, [pc, #60]	@ (2378 <xPortStartScheduler+0x4e>)
    233c:	f443 037f 	orr.w	r3, r3, #16711680	@ 0xff0000
    2340:	6013      	str	r3, [r2, #0]
    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;
    2342:	4b0d      	ldr	r3, [pc, #52]	@ (2378 <xPortStartScheduler+0x4e>)
    2344:	681b      	ldr	r3, [r3, #0]
    2346:	4a0c      	ldr	r2, [pc, #48]	@ (2378 <xPortStartScheduler+0x4e>)
    2348:	f043 437f 	orr.w	r3, r3, #4278190080	@ 0xff000000
    234c:	6013      	str	r3, [r2, #0]
    portNVIC_SHPR2_REG = 0;
    234e:	4b0b      	ldr	r3, [pc, #44]	@ (237c <xPortStartScheduler+0x52>)
    2350:	2200      	movs	r2, #0
    2352:	601a      	str	r2, [r3, #0]

    /* Start the timer that generates the tick ISR.  Interrupts are disabled
     * here already. */
    vPortSetupTimerInterrupt();
    2354:	f000 f896 	bl	2484 <vPortSetupTimerInterrupt>

    /* Initialise the critical nesting count ready for the first task. */
    uxCriticalNesting = 0;
    2358:	4b09      	ldr	r3, [pc, #36]	@ (2380 <xPortStartScheduler+0x56>)
    235a:	2200      	movs	r2, #0
    235c:	601a      	str	r2, [r3, #0]

    /* Start the first task. */
    prvPortStartFirstTask();
    235e:	f7ff ffd4 	bl	230a <prvPortStartFirstTask>
     * exit error function to prevent compiler warnings about a static function
     * not being called in the case that the application writer overrides this
     * functionality by defining configTASK_RETURN_ADDRESS.  Call
     * vTaskSwitchContext() so link time optimisation does not remove the
     * symbol. */
    vTaskSwitchContext();
    2362:	f7fe fc39 	bl	bd8 <vTaskSwitchContext>
    prvTaskExitError();
    2366:	f7ff ffa3 	bl	22b0 <prvTaskExitError>

    /* Should not get here! */
    return 0;
    236a:	2300      	movs	r3, #0
}
    236c:	4618      	mov	r0, r3
    236e:	3708      	adds	r7, #8
    2370:	46bd      	mov	sp, r7
    2372:	bd80      	pop	{r7, pc}
    2374:	e000ed08 	and	lr, r0, r8, lsl #26
    2378:	e000ed20 	and	lr, r0, r0, lsr #26
    237c:	e000ed1c 	and	lr, r0, ip, lsl sp
    2380:	20000000 	andcs	r0, r0, r0

00002384 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2384:	b480      	push	{r7}
    2386:	af00      	add	r7, sp, #0
    /* Not implemented in ports where there is nothing to return to.
     * Artificially force an assert. */
    configASSERT( uxCriticalNesting == 1000UL );
}
    2388:	bf00      	nop
    238a:	46bd      	mov	sp, r7
    238c:	bc80      	pop	{r7}
    238e:	4770      	bx	lr

00002390 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
    2390:	b480      	push	{r7}
    2392:	b083      	sub	sp, #12
    2394:	af00      	add	r7, sp, #0
    __asm volatile
    2396:	f04f 0301 	mov.w	r3, #1
    239a:	f383 8811 	msr	BASEPRI, r3
    239e:	f3bf 8f6f 	isb	sy
    23a2:	f3bf 8f4f 	dsb	sy
    23a6:	607b      	str	r3, [r7, #4]
}
    23a8:	bf00      	nop
    portDISABLE_INTERRUPTS();
    uxCriticalNesting++;
    23aa:	4b05      	ldr	r3, [pc, #20]	@ (23c0 <vPortEnterCritical+0x30>)
    23ac:	681b      	ldr	r3, [r3, #0]
    23ae:	3301      	adds	r3, #1
    23b0:	4a03      	ldr	r2, [pc, #12]	@ (23c0 <vPortEnterCritical+0x30>)
    23b2:	6013      	str	r3, [r2, #0]
     * assert function also uses a critical section. */
    if( uxCriticalNesting == 1 )
    {
        configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
    }
}
    23b4:	bf00      	nop
    23b6:	370c      	adds	r7, #12
    23b8:	46bd      	mov	sp, r7
    23ba:	bc80      	pop	{r7}
    23bc:	4770      	bx	lr
    23be:	bf00      	nop
    23c0:	20000000 	andcs	r0, r0, r0

000023c4 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
    23c4:	b480      	push	{r7}
    23c6:	b083      	sub	sp, #12
    23c8:	af00      	add	r7, sp, #0
    configASSERT( uxCriticalNesting );
    uxCriticalNesting--;
    23ca:	4b0a      	ldr	r3, [pc, #40]	@ (23f4 <vPortExitCritical+0x30>)
    23cc:	681b      	ldr	r3, [r3, #0]
    23ce:	3b01      	subs	r3, #1
    23d0:	4a08      	ldr	r2, [pc, #32]	@ (23f4 <vPortExitCritical+0x30>)
    23d2:	6013      	str	r3, [r2, #0]

    if( uxCriticalNesting == 0 )
    23d4:	4b07      	ldr	r3, [pc, #28]	@ (23f4 <vPortExitCritical+0x30>)
    23d6:	681b      	ldr	r3, [r3, #0]
    23d8:	2b00      	cmp	r3, #0
    23da:	d105      	bne.n	23e8 <vPortExitCritical+0x24>
    23dc:	2300      	movs	r3, #0
    23de:	607b      	str	r3, [r7, #4]
    __asm volatile
    23e0:	687b      	ldr	r3, [r7, #4]
    23e2:	f383 8811 	msr	BASEPRI, r3
}
    23e6:	bf00      	nop
    {
        portENABLE_INTERRUPTS();
    }
}
    23e8:	bf00      	nop
    23ea:	370c      	adds	r7, #12
    23ec:	46bd      	mov	sp, r7
    23ee:	bc80      	pop	{r7}
    23f0:	4770      	bx	lr
    23f2:	bf00      	nop
    23f4:	20000000 	andcs	r0, r0, r0

000023f8 <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
    /* This is a naked function. */

    __asm volatile
    23f8:	f3ef 8009 	mrs	r0, PSP
    23fc:	f3bf 8f6f 	isb	sy
    2400:	4b0d      	ldr	r3, [pc, #52]	@ (2438 <xPortPendSVHandler+0x40>)
    2402:	681a      	ldr	r2, [r3, #0]
    2404:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
    2408:	6010      	str	r0, [r2, #0]
    240a:	e92d 4008 	stmdb	sp!, {r3, lr}
    240e:	f04f 0001 	mov.w	r0, #1
    2412:	f380 8811 	msr	BASEPRI, r0
    2416:	f7fe fbdf 	bl	bd8 <vTaskSwitchContext>
    241a:	f04f 0000 	mov.w	r0, #0
    241e:	f380 8811 	msr	BASEPRI, r0
    2422:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    2426:	6819      	ldr	r1, [r3, #0]
    2428:	6808      	ldr	r0, [r1, #0]
    242a:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
    242e:	f380 8809 	msr	PSP, r0
    2432:	f3bf 8f6f 	isb	sy
    2436:	4770      	bx	lr
    2438:	20000004 	andcs	r0, r0, r4
        "   bx r14                              \n"
        "                                       \n"
        "   .ltorg                              \n"
        ::"i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
    );
}
    243c:	bf00      	nop

0000243e <xPortSysTickHandler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
    243e:	b580      	push	{r7, lr}
    2440:	b082      	sub	sp, #8
    2442:	af00      	add	r7, sp, #0
    __asm volatile
    2444:	f04f 0301 	mov.w	r3, #1
    2448:	f383 8811 	msr	BASEPRI, r3
    244c:	f3bf 8f6f 	isb	sy
    2450:	f3bf 8f4f 	dsb	sy
    2454:	607b      	str	r3, [r7, #4]
}
    2456:	bf00      	nop
     * known. */
    portDISABLE_INTERRUPTS();
    traceISR_ENTER();
    {
        /* Increment the RTOS tick. */
        if( xTaskIncrementTick() != pdFALSE )
    2458:	f7fe fab6 	bl	9c8 <xTaskIncrementTick>
    245c:	4603      	mov	r3, r0
    245e:	2b00      	cmp	r3, #0
    2460:	d003      	beq.n	246a <xPortSysTickHandler+0x2c>
        {
            traceISR_EXIT_TO_SCHEDULER();

            /* A context switch is required.  Context switching is performed in
             * the PendSV interrupt.  Pend the PendSV interrupt. */
            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
    2462:	4b07      	ldr	r3, [pc, #28]	@ (2480 <xPortSysTickHandler+0x42>)
    2464:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
    2468:	601a      	str	r2, [r3, #0]
    246a:	2300      	movs	r3, #0
    246c:	603b      	str	r3, [r7, #0]
    __asm volatile
    246e:	683b      	ldr	r3, [r7, #0]
    2470:	f383 8811 	msr	BASEPRI, r3
}
    2474:	bf00      	nop
        {
            traceISR_EXIT();
        }
    }
    portENABLE_INTERRUPTS();
}
    2476:	bf00      	nop
    2478:	3708      	adds	r7, #8
    247a:	46bd      	mov	sp, r7
    247c:	bd80      	pop	{r7, pc}
    247e:	bf00      	nop
    2480:	e000ed04 	and	lr, r0, r4, lsl #26

00002484 <vPortSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
__attribute__( ( weak ) ) void vPortSetupTimerInterrupt( void )
{
    2484:	b480      	push	{r7}
    2486:	af00      	add	r7, sp, #0
        ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
    }
    #endif /* configUSE_TICKLESS_IDLE */

    /* Stop and clear the SysTick. */
    portNVIC_SYSTICK_CTRL_REG = 0UL;
    2488:	4b07      	ldr	r3, [pc, #28]	@ (24a8 <vPortSetupTimerInterrupt+0x24>)
    248a:	2200      	movs	r2, #0
    248c:	601a      	str	r2, [r3, #0]
    portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
    248e:	4b07      	ldr	r3, [pc, #28]	@ (24ac <vPortSetupTimerInterrupt+0x28>)
    2490:	2200      	movs	r2, #0
    2492:	601a      	str	r2, [r3, #0]

    /* Configure SysTick to interrupt at the requested rate. */
    portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
    2494:	4b06      	ldr	r3, [pc, #24]	@ (24b0 <vPortSetupTimerInterrupt+0x2c>)
    2496:	4a07      	ldr	r2, [pc, #28]	@ (24b4 <vPortSetupTimerInterrupt+0x30>)
    2498:	601a      	str	r2, [r3, #0]
    portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT_CONFIG | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
    249a:	4b03      	ldr	r3, [pc, #12]	@ (24a8 <vPortSetupTimerInterrupt+0x24>)
    249c:	2207      	movs	r2, #7
    249e:	601a      	str	r2, [r3, #0]
}
    24a0:	bf00      	nop
    24a2:	46bd      	mov	sp, r7
    24a4:	bc80      	pop	{r7}
    24a6:	4770      	bx	lr
    24a8:	e000e010 	and	lr, r0, r0, lsl r0
    24ac:	e000e018 	and	lr, r0, r8, lsl r0
    24b0:	e000e014 	and	lr, r0, r4, lsl r0
    24b4:	0001193f 	andeq	r1, r1, pc, lsr r9
    24b8:	00003154 	andeq	r3, r0, r4, asr r1
    24bc:	00003254 	andeq	r3, r0, r4, asr r2

000024c0 <uxTopUsedPriority>:
    24c0:	00000004 	andeq	r0, r0, r4
    24c4:	454c4449 	strbmi	r4, [ip, #-1097]	@ 0xfffffbb7
    24c8:	00000000 	andeq	r0, r0, r0

000024cc <xHeapStructSize>:
    24cc:	00000008 	andeq	r0, r0, r8

Disassembly of section .data:

20000000 <uxCriticalNesting>:
20000000:	aaaaaaaa 	bge	1eaaaab0 <_etext+0x1eaa85e0>

Disassembly of section .ARM.attributes:

00000000 <.ARM.attributes>:
   0:	00002e41 	andeq	r2, r0, r1, asr #28
   4:	61656100 	cmnvs	r5, r0, lsl #2
   8:	01006962 	tsteq	r0, r2, ror #18
   c:	00000024 	andeq	r0, r0, r4, lsr #32
  10:	726f4305 	rsbvc	r4, pc, #335544320	@ 0x14000000
  14:	2d786574 	cfldr64cs	mvdx6, [r8, #-464]!	@ 0xfffffe30
  18:	0600334d 	streq	r3, [r0], -sp, asr #6
  1c:	094d070a 	stmdbeq	sp, {r1, r3, r8, r9, sl}^
  20:	14041202 	strne	r1, [r4], #-514	@ 0xfffffdfe
  24:	17011501 	strne	r1, [r1, -r1, lsl #10]
  28:	1a011803 	bne	4603c <_etext+0x43b6c>
  2c:	Address 0x2c is out of bounds.


Disassembly of section .comment:

00000000 <.comment>:
   0:	3a434347 	bcc	10d0d24 <_etext+0x10ce854>
   4:	35312820 	ldrcc	r2, [r1, #-2080]!	@ 0xfffff7e0
   8:	2e33313a 	mrccs	1, 1, r3, cr3, cr10, {1}
   c:	65722e32 	ldrbvs	r2, [r2, #-3634]!	@ 0xfffff1ce
  10:	322d316c 	eorcc	r3, sp, #108, 2
  14:	33312029 	teqcc	r1, #41	@ 0x29
  18:	312e322e 			@ <UNDEFINED> instruction: 0x312e322e
  1c:	32303220 	eorscc	r3, r0, #32, 4
  20:	30303133 	eorscc	r3, r0, r3, lsr r1
  24:	Address 0x24 is out of bounds.


Disassembly of section .debug_line:

00000000 <.debug_line>:
       0:	0000004f 	andeq	r0, r0, pc, asr #32
       4:	001a0002 	andseq	r0, sl, r2
       8:	01020000 	mrseq	r0, (UNDEF: 2)
       c:	000a0efb 	strdeq	r0, [sl], -fp
      10:	01010101 	tsteq	r1, r1, lsl #2
      14:	01000000 	mrseq	r0, (UNDEF: 0)
      18:	6f6f6200 	svcvs	0x006f6200
      1c:	00532e74 	subseq	r2, r3, r4, ror lr
      20:	00000000 	andeq	r0, r0, r0
      24:	d0020500 	andle	r0, r2, r0, lsl #10
      28:	03000001 	movweq	r0, #1
      2c:	1e1e0124 	mufneep	f0, f6, f4
      30:	2c1e1e20 	ldccs	14, cr1, [lr], {32}
      34:	201e202c 	andscs	r2, lr, ip, lsr #32
      38:	2c1e1e1e 	ldccs	14, cr1, [lr], {30}
      3c:	22242d21 	eorcs	r2, r4, #2112	@ 0x840
      40:	22222222 	eorcs	r2, r2, #536870914	@ 0x20000002
      44:	1d420321 	stclne	3, cr0, [r2, #-132]	@ 0xffffff7c
      48:	0a032c2c 	beq	cb100 <_etext+0xc8c30>
      4c:	02022c2b 	andeq	r2, r2, #11008	@ 0x2b00
      50:	31010100 	mrscc	r0, (UNDEF: 17)
      54:	03000001 	movweq	r0, #1
      58:	0000cc00 	andeq	ip, r0, r0, lsl #24
      5c:	fb010200 	blx	40866 <_etext+0x3e396>
      60:	01000d0e 	tsteq	r0, lr, lsl #26
      64:	00010101 	andeq	r0, r1, r1, lsl #2
      68:	00010000 	andeq	r0, r1, r0
      6c:	752f0100 	strvc	r0, [pc, #-256]!	@ ffffff74 <__StackTop+0xdfffdf74>
      70:	6c2f7273 	sfmvs	f7, 4, [pc], #-460	@ fffffeac <__StackTop+0xdfffdeac>
      74:	672f6269 	strvs	r6, [pc, -r9, ror #4]!
      78:	612f6363 			@ <UNDEFINED> instruction: 0x612f6363
      7c:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
      80:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	@ 0xfffffe44
      84:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
      88:	2e33312f 	rsfcssp	f3, f3, #10.0
      8c:	2f312e32 	svccs	0x00312e32
      90:	6c636e69 	stclvs	14, cr6, [r3], #-420	@ 0xfffffe5c
      94:	00656475 	rsbeq	r6, r5, r5, ror r4
      98:	462f2e2e 	strtmi	r2, [pc], -lr, lsr #28
      9c:	52656572 	rsbpl	r6, r5, #478150656	@ 0x1c800000
      a0:	2d534f54 	ldclcs	15, cr4, [r3, #-336]	@ 0xfffffeb0
      a4:	6e72654b 	cdpvs	5, 7, cr6, cr2, cr11, {2}
      a8:	692f6c65 	stmdbvs	pc!, {r0, r2, r5, r6, sl, fp, sp, lr}	@ <UNPREDICTABLE>
      ac:	756c636e 	strbvc	r6, [ip, #-878]!	@ 0xfffffc92
      b0:	2e006564 	cfsh32cs	mvfx6, mvfx0, #52
      b4:	72462f2e 	subvc	r2, r6, #46, 30	@ 0xb8
      b8:	54526565 	ldrbpl	r6, [r2], #-1381	@ 0xfffffa9b
      bc:	4b2d534f 	blmi	b54e00 <_etext+0xb52930>
      c0:	656e7265 	strbvs	r7, [lr, #-613]!	@ 0xfffffd9b
      c4:	6f702f6c 	svcvs	0x00702f6c
      c8:	62617472 	rsbvs	r7, r1, #1912602624	@ 0x72000000
      cc:	472f656c 	strmi	r6, [pc, -ip, ror #10]!
      d0:	412f4343 			@ <UNDEFINED> instruction: 0x412f4343
      d4:	435f4d52 	cmpmi	pc, #5248	@ 0x1480
      d8:	0000334d 	andeq	r3, r0, sp, asr #6
      dc:	72617473 	rsbvc	r7, r1, #1929379840	@ 0x73000000
      e0:	00632e74 	rsbeq	r2, r3, r4, ror lr
      e4:	73000000 	movwvc	r0, #0
      e8:	6e696474 	mcrvs	4, 3, r6, cr9, cr4, {3}
      ec:	00682e74 	rsbeq	r2, r8, r4, ror lr
      f0:	70000001 	andvc	r0, r0, r1
      f4:	646a6f72 	strbtvs	r6, [sl], #-3954	@ 0xfffff08e
      f8:	2e736665 	cdpcs	6, 7, cr6, cr3, cr5, {3}
      fc:	00020068 	andeq	r0, r2, r8, rrx
     100:	726f7000 	rsbvc	r7, pc, #0
     104:	63616d74 	cmnvs	r1, #116, 26	@ 0x1d00
     108:	682e6f72 	stmdavs	lr!, {r1, r4, r5, r6, r8, r9, sl, fp, sp, lr}
     10c:	00000300 	andeq	r0, r0, r0, lsl #6
     110:	6b736174 	blvs	1cd86e8 <_etext+0x1cd6218>
     114:	0200682e 	andeq	r6, r0, #3014656	@ 0x2e0000
     118:	6f700000 	svcvs	0x00700000
     11c:	62617472 	rsbvs	r7, r1, #1912602624	@ 0x72000000
     120:	682e656c 	stmdavs	lr!, {r2, r3, r5, r6, r8, sl, sp, lr}
     124:	00000200 	andeq	r0, r0, r0, lsl #4
     128:	00270500 	eoreq	r0, r7, r0, lsl #10
     12c:	021c0205 	andseq	r0, ip, #1342177280	@ 0x50000000
     130:	05160000 	ldreq	r0, [r6, #-0]
     134:	0a054b12 	beq	152d84 <_etext+0x1508b4>
     138:	01040200 	mrseq	r0, R12_usr
     13c:	053c0631 	ldreq	r0, [ip, #-1585]!	@ 0xfffff9cf
     140:	05240627 	streq	r0, [r4, #-1575]!	@ 0xfffff9d9
     144:	0a054b12 	beq	152d94 <_etext+0x1508c4>
     148:	01040200 	mrseq	r0, R12_usr
     14c:	053c0631 	ldreq	r0, [ip, #-1585]!	@ 0xfffff9cf
     150:	1103060d 	tstne	r3, sp, lsl #12
     154:	3f0f0520 	svccc	0x000f0520
     158:	2f0a052f 	svccs	0x000a052f
     15c:	05211605 	streq	r1, [r1, #-1541]!	@ 0xfffff9fb
     160:	12053c0d 	andne	r3, r5, #3328	@ 0xd00
     164:	2010053c 	andscs	r0, r0, ip, lsr r5
     168:	051f0f05 	ldreq	r0, [pc, #-3845]	@ fffff26b <__StackTop+0xdfffd26b>
     16c:	0a054f09 	beq	153d98 <_etext+0x1518c8>
     170:	210d052f 	tstcs	sp, pc, lsr #10
     174:	053c1005 	ldreq	r1, [ip, #-5]!
     178:	bb4d2d0f 	bllt	134b5bc <_etext+0x13490ec>
     17c:	2fbc0505 	svccs	0x00bc0505
     180:	02210105 	eoreq	r0, r1, #1073741825	@ 0x40000001
     184:	01010015 	tsteq	r1, r5, lsl r0
     188:	00000097 	muleq	r0, r7, r0
     18c:	005c0003 	subseq	r0, ip, r3
     190:	01020000 	mrseq	r0, (UNDEF: 2)
     194:	000d0efb 	strdeq	r0, [sp], -fp
     198:	01010101 	tsteq	r1, r1, lsl #2
     19c:	01000000 	mrseq	r0, (UNDEF: 0)
     1a0:	2f010000 	svccs	0x00010000
     1a4:	2f727375 	svccs	0x00727375
     1a8:	2f62696c 	svccs	0x0062696c
     1ac:	2f636367 	svccs	0x00636367
     1b0:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
     1b4:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
     1b8:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
     1bc:	33312f69 	teqcc	r1, #420	@ 0x1a4
     1c0:	312e322e 			@ <UNDEFINED> instruction: 0x312e322e
     1c4:	636e692f 	cmnvs	lr, #770048	@ 0xbc000
     1c8:	6564756c 	strbvs	r7, [r4, #-1388]!	@ 0xfffffa94
     1cc:	6f700000 	svcvs	0x00700000
    ldr r0, =_sidata            /* Address of init values in flash */
     1d0:	75467472 	strbvc	r7, [r6, #-1138]	@ 0xfffffb8e
    ldr r2, =_edata             /* End of .data in RAM */
     1d4:	6974636e 	ldmdbvs	r4!, {r1, r2, r3, r5, r6, r8, r9, sp, lr}^
    bcs zero_bss
     1d8:	2e736e6f 	cdpcs	14, 7, cr6, cr3, cr15, {3}
    ldr r3, [r0], #4
     1dc:	00000063 	andeq	r0, r0, r3, rrx
    str r3, [r1], #4
     1e0:	64747300 	ldrbtvs	r7, [r4], #-768	@ 0xfffffd00
    ldr r0, =_sbss              /* Start of .bss */
     1e4:	2e666564 	cdpcs	5, 6, cr6, cr6, cr4, {3}
    cmp r0, r1
     1e8:	00010068 	andeq	r0, r1, r8, rrx
    movs r2, #0
     1ec:	2f050000 	svccs	0x00050000
    str r2, [r0], #4
     1f0:	e4020500 	str	r0, [r2], #-1280	@ 0xfffffb00
    bl start                    /* Call main/start function */
     1f4:	13000002 	movwne	r0, #2
    b hang                      /* If it returns, hang forever */
     1f8:	05691405 	strbeq	r1, [r9, #-1029]!	@ 0xfffffbfb
    b .
     1fc:	11053213 	tstne	r5, r3, lsl r2
    b .
     200:	2e050531 	mcrcs	5, 0, r0, cr5, cr1, {1}
    b .
     204:	05220c05 	streq	r0, [r2, #-3077]!	@ 0xfffff3fb
    ldr r0, =_sidata            /* Address of init values in flash */
     208:	24053c10 	strcs	r3, [r5], #-3088	@ 0xfffff3f0
    ldr r1, =_sdata             /* Start of .data in RAM */
     20c:	03040200 	movweq	r0, #16896	@ 0x4200
    ldr r2, =_edata             /* End of .data in RAM */
     210:	001a052c 	andseq	r0, sl, ip, lsr #10
    ldr r0, =_sbss              /* Start of .bss */
     214:	3c010402 	cfstrscc	mvf0, [r1], {2}
    ldr r1, =_ebss              /* End of .bss */
     218:	05500c05 	ldrbeq	r0, [r0, #-3077]	@ 0xfffff3fb
static void vTask1(void *pvParameters){
     21c:	05022101 	streq	r2, [r2, #-257]	@ 0xfffffeff
     220:	1e010100 	adfnes	f0, f1, f0
    volatile int a =0;
     224:	0300000a 	movweq	r0, #10
        a++;
     228:	00011500 	andeq	r1, r1, r0, lsl #10
     22c:	fb010200 	blx	40a36 <_etext+0x3e566>
static void vTask2(void *pvParameters){
     230:	01000d0e 	tsteq	r0, lr, lsl #26
     234:	00010101 	andeq	r0, r1, r1, lsl #2
    volatile int b =0;
     238:	00010000 	andeq	r0, r1, r0
        b++;
     23c:	2e2e0100 	sufcse	f0, f6, f0
     240:	6572462f 	ldrbvs	r4, [r2, #-1583]!	@ 0xfffff9d1
void start(){
     244:	4f545265 	svcmi	0x00545265
     248:	654b2d53 	strbvs	r2, [fp, #-3411]	@ 0xfffff2ad
    uint32_t *src = &_sidata;//Source flash
     24c:	6c656e72 	stclvs	14, cr6, [r5], #-456	@ 0xfffffe38
    uint32_t *dst = &_sdata;//Destination RAM
     250:	2f2e2e00 	svccs	0x002e2e00
        *dst++ = *src++; //copy word and increment pointer
     254:	65657246 	strbvs	r7, [r5, #-582]!	@ 0xfffffdba
     258:	534f5452 	movtpl	r5, #62546	@ 0xf452
     25c:	72654b2d 	rsbvc	r4, r5, #46080	@ 0xb400
     260:	2f6c656e 	svccs	0x006c656e
    while(dst < &_edata){
     264:	74726f70 	ldrbtvc	r6, [r2], #-3952	@ 0xfffff090
     268:	656c6261 	strbvs	r6, [ip, #-609]!	@ 0xfffffd9f
    dst = &_sbss;
     26c:	4343472f 	movtmi	r4, #14127	@ 0x372f
    while(dst < &_ebss){
     270:	4d52412f 	ldfmie	f4, [r2, #-188]	@ 0xffffff44
        *dst++ = 0; //zero word and increment pointer
     274:	334d435f 	movtcc	r4, #54111	@ 0xd35f
     278:	73752f00 	cmnvc	r5, #0, 30
    while(dst < &_ebss){
     27c:	696c2f72 	stmdbvs	ip!, {r1, r4, r5, r6, r8, r9, sl, fp, sp}^
     280:	63672f62 	cmnvs	r7, #392	@ 0x188
    xReturn = xTaskCreate(vTask1,"T1",configMINIMAL_STACK_SIZE,NULL,1,NULL);  // 256*4 = 1k stack size
     284:	72612f63 	rsbvc	r2, r1, #396	@ 0x18c
     288:	6f6e2d6d 	svcvs	0x006e2d6d
     28c:	652d656e 	strvs	r6, [sp, #-1390]!	@ 0xfffffa92
     290:	2f696261 	svccs	0x00696261
     294:	322e3331 	eorcc	r3, lr, #-1006632960	@ 0xc4000000
     298:	692f312e 	stmdbvs	pc!, {r1, r2, r3, r5, r8, ip, sp}	@ <UNPREDICTABLE>
    xReturn = xTaskCreate(vTask2,"T2",configMINIMAL_STACK_SIZE,NULL,1,NULL);
     29c:	756c636e 	strbvc	r6, [ip, #-878]!	@ 0xfffffc92
     2a0:	2e006564 	cfsh32cs	mvfx6, mvfx0, #52
     2a4:	72462f2e 	subvc	r2, r6, #46, 30	@ 0xb8
     2a8:	54526565 	ldrbpl	r6, [r2], #-1381	@ 0xfffffa9b
     2ac:	4b2d534f 	blmi	b54ff0 <_etext+0xb52b20>
     2b0:	656e7265 	strbvs	r7, [lr, #-613]!	@ 0xfffffd9b
    xPortStartScheduler();
     2b4:	6e692f6c 	cdpvs	15, 6, cr2, cr9, cr12, {3}
    return;
     2b8:	64756c63 	ldrbtvs	r6, [r5], #-3171	@ 0xfffff39d
     2bc:	752f0065 	strvc	r0, [pc, #-101]!	@ 25f <start+0x1b>
     2c0:	692f7273 	stmdbvs	pc!, {r0, r1, r4, r5, r6, r9, ip, sp, lr}	@ <UNPREDICTABLE>
     2c4:	756c636e 	strbvc	r6, [ip, #-878]!	@ 0xfffffc92
     2c8:	6e2f6564 	cfsh64vs	mvdx6, mvdx15, #52
     2cc:	696c7765 	stmdbvs	ip!, {r0, r2, r5, r6, r8, r9, sl, ip, sp, lr}^
     2d0:	74000062 	strvc	r0, [r0], #-98	@ 0xffffff9e
     2d4:	736b7361 	cmnvc	fp, #-2080374783	@ 0x84000001
     2d8:	0100632e 	tsteq	r0, lr, lsr #6
     2dc:	6f700000 	svcvs	0x00700000
     2e0:	616d7472 	smcvs	55106	@ 0xd742
void *memset(void *dest, int c, size_t count) {
     2e4:	2e6f7263 	cdpcs	2, 6, cr7, cr15, cr3, {3}
     2e8:	00020068 	andeq	r0, r2, r8, rrx
     2ec:	64747300 	ldrbtvs	r7, [r4], #-768	@ 0xfffffd00
    unsigned char *ptr = (unsigned char *)dest;
     2f0:	2e666564 	cdpcs	5, 6, cr6, cr6, cr4, {3}
    unsigned char value = (unsigned char)c;
     2f4:	00030068 	andeq	r0, r3, r8, rrx
    for (size_t i = 0; i < count; i++) {
     2f8:	64747300 	ldrbtvs	r7, [r4], #-768	@ 0xfffffd00
     2fc:	2e746e69 	cdpcs	14, 7, cr6, cr4, cr9, {3}
        ptr[i] = value;
     300:	00030068 	andeq	r0, r3, r8, rrx
     304:	6f727000 	svcvs	0x00727000
    for (size_t i = 0; i < count; i++) {
     308:	6665646a 	strbtvs	r6, [r5], -sl, ror #8
     30c:	00682e73 	rsbeq	r2, r8, r3, ror lr
     310:	6c000004 	stcvs	0, cr0, [r0], {4}
     314:	2e747369 	cdpcs	3, 7, cr7, cr4, cr9, {3}
     318:	00040068 	andeq	r0, r4, r8, rrx
     31c:	73617400 	cmnvc	r1, #0, 8
     320:	00682e6b 	rsbeq	r2, r8, fp, ror #28
    {
     324:	70000004 	andvc	r0, r0, r4
     328:	6174726f 	cmnvs	r4, pc, ror #4
     32c:	2e656c62 	cdpcs	12, 6, cr6, cr5, cr2, {3}
     330:	00040068 	andeq	r0, r4, r8, rrx
            pxStack = pvPortMallocStack( ( ( ( size_t ) uxStackDepth ) * sizeof( StackType_t ) ) );
     334:	72747300 	rsbsvc	r7, r4, #0, 6
     338:	2e676e69 	cdpcs	14, 6, cr6, cr7, cr9, {3}
     33c:	00050068 	andeq	r0, r5, r8, rrx
            if( pxStack != NULL )
     340:	05050000 	streq	r0, [r5, #-0]
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
     344:	24020500 	strcs	r0, [r2], #-1280	@ 0xfffffb00
     348:	03000003 	movweq	r0, #3
                if( pxNewTCB != NULL )
     34c:	05010cef 	streq	r0, [r1, #-3311]	@ 0xfffff311
     350:	742c0317 	strtvc	r0, [ip], #-791	@ 0xfffffce9
                    ( void ) memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
     354:	05680f05 	strbeq	r0, [r8, #-3845]!	@ 0xfffff0fb
     358:	13054228 	movwne	r4, #21032	@ 0x5228
                    pxNewTCB->pxStack = pxStack;
     35c:	3e1e054c 	cfmac32cc	mvfx0, mvfx14, mvfx12
     360:	055b2705 	ldrbeq	r2, [fp, #-1797]	@ 0xfffff8fb
                    vPortFreeStack( pxStack );
     364:	1a055015 	bne	1543c0 <_etext+0x151ef0>
     368:	330b054f 	movwcc	r0, #46415	@ 0xb54f
                pxNewTCB = NULL;
     36c:	0a030d05 	beq	c3788 <_etext+0xc12b8>
        if( pxNewTCB != NULL )
     370:	d910053c 	ldmdble	r0, {r2, r3, r4, r5, r8, sl}
     374:	03210505 			@ <UNDEFINED> instruction: 0x03210505
            prvInitialiseNewTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
     378:	14054a09 	strne	r4, [r5], #-2569	@ 0xfffff5f7
     37c:	ae0b057a 	cfrshl64ge	mvdx11, mvdx10, r0
     380:	09030d05 	stmdbeq	r3, {r0, r2, r8, sl, fp}
     384:	3d15053c 	cfldr32cc	mvfx0, [r5, #-240]	@ 0xffffff10
     388:	41100540 	tstmi	r0, r0, asr #10
     38c:	05210505 	streq	r0, [r1, #-1285]!	@ 0xfffffafb
     390:	4a310301 	bmi	c40f9c <_etext+0xc3eacc>
    }
     394:	21032305 	tstcs	r3, r5, lsl #6
     398:	2e2c0574 	mcrcs	5, 1, r0, cr12, cr4, {3}
    {
     39c:	05581605 	ldrbeq	r1, [r8, #-1541]	@ 0xfffff9fb
     3a0:	57052f2e 	strpl	r2, [r5, -lr, lsr #30]
     3a4:	2e160520 	cfmul64cs	mvdx0, mvdx6, mvdx0
     3a8:	1c030705 	stcne	7, cr0, [r3], {5}
        pxNewTCB = prvCreateTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask );
     3ac:	3e100520 	cfmul64cc	mvdx0, mvdx0, mvdx0
     3b0:	052e0905 	streq	r0, [lr, #-2309]!	@ 0xfffff6fb
     3b4:	2705222f 	strcs	r2, [r5, -pc, lsr #4]
     3b8:	6b17054a 	blvs	5c18e8 <_etext+0x5bf418>
     3bc:	054a0f05 	strbeq	r0, [sl, #-3845]	@ 0xfffff0fb
        if( pxNewTCB != NULL )
     3c0:	04020053 	streq	r0, [r2], #-83	@ 0xffffffad
     3c4:	2e790302 	cdpcs	3, 7, cr0, cr9, cr2, {0}
            prvAddNewTaskToReadyList( pxNewTCB );
     3c8:	02002705 	andeq	r2, r0, #1310720	@ 0x140000
            xReturn = pdPASS;
     3cc:	053c0104 	ldreq	r0, [ip, #-260]!	@ 0xfffffefc
     3d0:	4a090311 	bmi	24101c <_etext+0x23eb4c>
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     3d4:	0a033e05 	beq	cfbf0 <_etext+0xcd720>
        return xReturn;
     3d8:	03070520 	movweq	r0, #29984	@ 0x7520
    }
     3dc:	14054a0a 	strne	r4, [r5], #-2570	@ 0xfffff5f6
     3e0:	351a053e 	ldrcc	r0, [sl, #-1342]	@ 0xfffffac2
{
     3e4:	59430505 	stmdbpl	r3, {r0, r2, r8, sl}^
     3e8:	05593f5c 	ldrbeq	r3, [r9, #-3932]	@ 0xfffff0a4
     3ec:	00c20326 	sbceq	r0, r2, r6, lsr #6
        pxTopOfStack = &( pxNewTCB->pxStack[ uxStackDepth - ( configSTACK_DEPTH_TYPE ) 1 ] );
     3f0:	0024053c 	eoreq	r0, r4, ip, lsr r5
     3f4:	66010402 	strvs	r0, [r1], -r2, lsl #8
     3f8:	13030705 	movwne	r0, #14085	@ 0x3705
     3fc:	4018052e 	andsmi	r0, r8, lr, lsr #10
     400:	05420105 	strbeq	r0, [r2, #-261]	@ 0xfffffefb
        pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     404:	09055005 	stmdbeq	r5, {r0, r2, ip, lr}
     408:	3026054d 	eorcc	r0, r6, sp, asr #10
    if( pcName != NULL )
     40c:	053c2405 	ldreq	r2, [ip, #-1029]!	@ 0xfffffbfb
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     410:	0f05301e 	svceq	0x0005301e
     414:	321e052e 	andscc	r0, lr, #192937984	@ 0xb800000
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     418:	053e2c05 	ldreq	r2, [lr, #-3077]!	@ 0xfffff3fb
     41c:	15052e13 	strne	r2, [r5, #-3603]	@ 0xfffff1ed
     420:	03270533 			@ <UNDEFINED> instruction: 0x03270533
     424:	13053c0c 	movwne	r3, #23564	@ 0x5c0c
     428:	3025052e 	eorcc	r0, r5, lr, lsr #10
            if( pcName[ x ] == ( char ) 0x00 )
     42c:	053c3d05 	ldreq	r3, [ip, #-3333]!	@ 0xfffff2fb
     430:	26052e17 			@ <UNDEFINED> instruction: 0x26052e17
     434:	03190530 	tsteq	r9, #48, 10	@ 0xc000000
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     438:	0d053c0d 	stceq	12, cr3, [r5, #-52]	@ 0xffffffcc
     43c:	05580a03 	ldrbeq	r0, [r8, #-2563]	@ 0xfffff5fd
     440:	16410209 	strbne	r0, [r1], -r9, lsl #4
                break;
     444:	05301f05 	ldreq	r1, [r0, #-3845]!	@ 0xfffff0fb
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1U ] = '\0';
     448:	0d052e0b 	stceq	14, cr2, [r5, #-44]	@ 0xffffffd4
     44c:	04020032 	streq	r0, [r2], #-50	@ 0xffffffce
    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
     450:	05740601 	ldrbeq	r0, [r4, #-1537]!	@ 0xfffff9ff
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
     454:	05880605 	streq	r0, [r8, #1541]	@ 0x605
    pxNewTCB->uxPriority = uxPriority;
     458:	0b920301 	bleq	fe481064 <__StackTop+0xde47f064>
     45c:	10052008 	andne	r2, r5, r8
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     460:	300a053d 	andcc	r0, sl, sp, lsr r5
     464:	05671405 	strbeq	r1, [r7, #-1029]!	@ 0xfffffbfb
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     468:	0505341d 	streq	r3, [r5, #-1053]	@ 0xfffffbe3
     46c:	253f052e 	ldrcs	r0, [pc, #-1326]!	@ ffffff46 <__StackTop+0xdfffdf46>
     470:	054a2905 	strbeq	r2, [sl, #-2309]	@ 0xfffff6fb
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     474:	0b055a16 	bleq	156cd4 <_etext+0x154804>
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority );
     478:	0187054a 	orreq	r0, r7, sl, asr #10
     47c:	02040200 	andeq	r0, r4, #0, 4
     480:	052e7903 	streq	r7, [lr, #-2307]!	@ 0xfffff6fd
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     484:	04020036 	streq	r0, [r2], #-54	@ 0xffffffca
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     488:	0d053c01 	stceq	12, cr3, [r5, #-4]
     48c:	054a0903 	strbeq	r0, [sl, #-2307]	@ 0xfffff6fd
     490:	20090325 	andcs	r0, r9, r5, lsr #6
     494:	055b1205 	ldrbeq	r1, [fp, #-517]	@ 0xfffffdfb
    if( pxCreatedTask != NULL )
     498:	20052e05 	andcs	r2, r5, r5, lsl #28
     49c:	03170524 	tsteq	r7, #36, 10	@ 0x9000000
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     4a0:	052e00ce 	streq	r0, [lr, #-206]!	@ 0xffffff32
}
     4a4:	e40a030b 	str	r0, [sl], #-779	@ 0xfffffcf5
     4a8:	02005d05 	andeq	r5, r0, #320	@ 0x140
    {
     4ac:	a4030204 	strge	r0, [r3], #-516	@ 0xfffffdfc
     4b0:	2e053c7f 	mcrcs	12, 0, r3, cr5, cr15, {3}
        taskENTER_CRITICAL();
     4b4:	01040200 	mrseq	r0, R12_usr
            uxCurrentNumberOfTasks = ( UBaseType_t ) ( uxCurrentNumberOfTasks + 1U );
     4b8:	030d053c 	movweq	r0, #54588	@ 0xd53c
     4bc:	054a00de 	strbeq	r0, [sl, #-222]	@ 0xffffff22
     4c0:	2012030c 	andscs	r0, r2, ip, lsl #6
            if( pxCurrentTCB == NULL )
     4c4:	a3210105 			@ <UNDEFINED> instruction: 0xa3210105
     4c8:	0d030f05 	stceq	15, cr0, [r3, #-20]	@ 0xffffffec
                pxCurrentTCB = pxNewTCB;
     4cc:	0307053c 	movweq	r0, #30012	@ 0x753c
                if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     4d0:	02043c0f 	andeq	r3, r4, #3840	@ 0xf00
     4d4:	d2030505 	andle	r0, r3, #20971520	@ 0x1400000
                    prvInitialiseTaskLists();
     4d8:	01053c64 	tsteq	r5, r4, ror #24
     4dc:	05010498 	streq	r0, [r1, #-1176]	@ 0xfffffb68
                if( xSchedulerRunning == pdFALSE )
     4e0:	1bc0031e 	blne	ff001160 <__StackTop+0xdefff160>
     4e4:	4b1b0520 	blmi	6c196c <_etext+0x6bf49c>
                    if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     4e8:	053d1405 	ldreq	r1, [sp, #-1029]!	@ 0xfffffbfb
     4ec:	3c130312 	ldccc	3, cr0, [r3], {18}
     4f0:	17030505 	strne	r0, [r3, -r5, lsl #10]
                        pxCurrentTCB = pxNewTCB;
     4f4:	3101052e 	tstcc	r1, lr, lsr #10
     4f8:	050204cc 	streq	r0, [r2, #-1228]	@ 0xfffffb34
            uxTaskNumber++;
     4fc:	64850305 	strvs	r0, [r5], #773	@ 0x305
     500:	9801053c 	stmdals	r1, {r2, r3, r4, r5, r8, sl}
            prvAddTaskToReadyList( pxNewTCB );
     504:	17050104 	strne	r0, [r5, -r4, lsl #2]
     508:	201c9303 	andscs	r9, ip, r3, lsl #6
     50c:	05400505 	strbeq	r0, [r0, #-1285]	@ 0xfffffafb
     510:	056a3101 	strbeq	r3, [sl, #-257]!	@ 0xfffffeff
     514:	2e250320 	cdpcs	3, 2, cr0, cr5, cr0, {1}
     518:	053c1e05 	ldreq	r1, [ip, #-3589]!	@ 0xfffff1fb
     51c:	01053209 	tsteq	r5, r9, lsl #4
     520:	0100c003 	tsteq	r0, r3
     524:	7400c503 	strvc	ip, [r0], #-1283	@ 0xfffffafd
     528:	053d0d05 	ldreq	r0, [sp, #-3333]!	@ 0xfffff2fb
     52c:	09052f10 	stmdbeq	r5, {r4, r8, r9, sl, fp, sp}
     530:	052e0d03 	streq	r0, [lr, #-3331]!	@ 0xfffff2fd
     534:	2405301e 	strcs	r3, [r5], #-30	@ 0xffffffe2
     538:	3c220534 	cfstr32cc	mvfx0, [r2], #-208	@ 0xffffff30
     53c:	05312605 	ldreq	r2, [r1, #-1541]!	@ 0xfffff9fb
     540:	2c052e0f 	stccs	14, cr2, [r5], {15}
     544:	2e13053e 	mrccs	5, 0, r0, cr3, cr14, {1}
     548:	05401a05 	strbeq	r1, [r0, #-2565]	@ 0xfffff5fb
     54c:	1f052521 	svcne	0x00052521
     550:	2f19052e 	svccs	0x0019052e
     554:	01040200 	mrseq	r0, R12_usr
     558:	002e0806 	eoreq	r0, lr, r6, lsl #16
     55c:	4a030402 	bmi	c156c <_etext+0xbf09c>
     560:	00138306 	andseq	r8, r3, r6, lsl #6
     564:	06010402 	streq	r0, [r1], -r2, lsl #8
     568:	02002e08 	andeq	r2, r0, #8, 28	@ 0x80
     56c:	064a0304 	strbeq	r0, [sl], -r4, lsl #6
     570:	02260583 	eoreq	r0, r6, #549453824	@ 0x20c00000
     574:	41051841 	tstmi	r5, r1, asr #16
     578:	3c1f052e 	cfldr32cc	mvfx0, [pc], {46}	@ 0x2e
     57c:	05303b05 	ldreq	r3, [r0, #-2821]!	@ 0xfffff4fb
     580:	586f031c 	stmdapl	pc!, {r2, r3, r4, r8, r9}^	@ <UNPREDICTABLE>
     584:	052e4405 	streq	r4, [lr, #-1029]!	@ 0xfffffbfb
        taskEXIT_CRITICAL();
     588:	3c210317 	stccc	3, cr0, [r1], #-92	@ 0xffffffa4
        if( xSchedulerRunning != pdFALSE )
     58c:	05441905 	strbeq	r1, [r4, #-2309]	@ 0xfffff6fb
     590:	2e0d0324 	cdpcs	3, 0, cr0, cr13, cr4, {1}
            taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxNewTCB );
     594:	053e1b05 	ldreq	r1, [lr, #-2821]!	@ 0xfffff4fb
     598:	23054025 	movwcs	r4, #20517	@ 0x5025
     59c:	01040200 	mrseq	r0, R12_usr
     5a0:	323f053c 	eorscc	r0, pc, #60, 10	@ 0xf000000
     5a4:	055f2105 	ldrbeq	r2, [pc, #-261]	@ 4a7 <prvInitialiseNewTask+0xc5>
     5a8:	2a053d34 	bcs	14fa80 <_etext+0x14d5b0>
     5ac:	4427053e 	strtmi	r0, [r7], #-1342	@ 0xfffffac2
    }
     5b0:	054a1705 	strbeq	r1, [sl, #-1797]	@ 0xfffff8fb
     5b4:	1d05322d 	sfmne	f3, 4, [r5, #-180]	@ 0xffffff4c
     5b8:	03090534 	movweq	r0, #38196	@ 0x9534
     5bc:	0c059e0f 	stceq	14, cr9, [r5], {15}
     5c0:	21010533 	tstcs	r1, r3, lsr r5
     5c4:	10055c08 	andne	r5, r5, r8, lsl #24
     5c8:	420c0544 	andmi	r0, ip, #68, 10	@ 0x11000000
     5cc:	78210105 	stmdavc	r1!, {r0, r2, r8}
     5d0:	16031c05 	strne	r1, [r3], -r5, lsl #24
{
     5d4:	3011053c 	andscc	r0, r1, ip, lsr r5
     5d8:	05420c05 	strbeq	r0, [r2, #-3077]	@ 0xfffff3fb
    BaseType_t xReturn = pdPASS;
     5dc:	05782101 	ldrbeq	r2, [r8, #-257]!	@ 0xfffffeff
    char cIdleName[ configMAX_TASK_NAME_LEN ] = { 0 };
     5e0:	0105350c 	tsteq	r5, ip, lsl #10
     5e4:	0d056a2f 	vstreq	s12, [r5, #-188]	@ 0xffffff44
     5e8:	04020051 	streq	r0, [r2], #-81	@ 0xffffffaf
    TaskFunction_t pxIdleTaskFunction = NULL;
     5ec:	003c0601 	eorseq	r0, ip, r1, lsl #12
    for( xIdleTaskNameIndex = 0U; xIdleTaskNameIndex < ( configMAX_TASK_NAME_LEN - taskRESERVED_TASK_NAME_LENGTH ); xIdleTaskNameIndex++ )
     5f0:	3c020402 	cfstrscc	mvf0, [r2], {2}
        cIdleName[ xIdleTaskNameIndex ] = configIDLE_TASK_NAME[ xIdleTaskNameIndex ];
     5f4:	02000b05 	andeq	r0, r0, #5120	@ 0x1400
     5f8:	20060404 	andcs	r0, r6, r4, lsl #8
     5fc:	05250c05 	streq	r0, [r5, #-3077]!	@ 0xfffff3fb
     600:	ea032f01 	b	cc20c <_etext+0xc9d3c>
     604:	05058202 	streq	r8, [r5, #-514]	@ 0xfffffdfe
        if( cIdleName[ xIdleTaskNameIndex ] == ( char ) 0x00 )
     608:	314a0b03 	cmpcc	sl, r3, lsl #22
     60c:	05301605 	ldreq	r1, [r0, #-1541]!	@ 0xfffff9fb
     610:	16056805 	strne	r6, [r5], -r5, lsl #16
    for( xIdleTaskNameIndex = 0U; xIdleTaskNameIndex < ( configMAX_TASK_NAME_LEN - taskRESERVED_TASK_NAME_LENGTH ); xIdleTaskNameIndex++ )
     614:	400c052f 	andmi	r0, ip, pc, lsr #10
     618:	03210105 			@ <UNDEFINED> instruction: 0x03210105
     61c:	056600e4 	strbeq	r0, [r6, #-228]!	@ 0xffffff1c
            break;
     620:	1e053f10 	mcrne	15, 0, r3, cr5, cr0, {0}
    cIdleName[ xIdleTaskNameIndex ] = '\0';
     624:	052e0d03 	streq	r0, [lr, #-3331]!	@ 0xfffff2fd
     628:	37052e07 	strcc	r2, [r5, -r7, lsl #28]
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
     62c:	2e1a0540 	cfmac32cs	mvfx0, mvfx10, mvfx0
     630:	05321405 	ldreq	r1, [r2, #-1029]!	@ 0xfffffbfb
            pxIdleTaskFunction = &prvIdleTask;
     634:	0d053e0b 	stceq	14, cr3, [r5, #-44]	@ 0xffffffd4
            xReturn = xTaskCreate( pxIdleTaskFunction,
     638:	031d053e 	tsteq	sp, #260046848	@ 0xf800000
     63c:	0512080b 	ldreq	r0, [r2, #-2059]	@ 0xfffff7f5
     640:	15052e0b 	strne	r2, [r5, #-3595]	@ 0xfffff1f5
     644:	3c13054e 	cfldr32cc	mvfx0, [r3], {78}	@ 0x4e
     648:	05352a05 	ldreq	r2, [r5, #-2565]!	@ 0xfffff5fb
     64c:	1d054b15 	vstrne	d4, [r5, #-84]	@ 0xffffffac
     650:	05200b03 	streq	r0, [r0, #-2819]!	@ 0xfffff4fd
        if( xReturn != pdPASS )
     654:	20053c1b 	andcs	r3, r5, fp, lsl ip
     658:	3e17052f 	cfmul64cc	mvdx0, mvdx7, mvdx15
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
     65c:	05512e05 	ldrbeq	r2, [r1, #-3589]	@ 0xfffff1fb
     660:	15053d19 	strne	r3, [r5, #-3353]	@ 0xfffff2e7
     664:	04020028 	streq	r0, [r2], #-40	@ 0xffffffd8
            break;
     668:	2e080601 	cfmadd32cs	mvax0, mvfx0, mvfx8, mvfx1
}
     66c:	03040200 	movweq	r0, #16896	@ 0x4200
     670:	0619054a 	ldreq	r0, [r9], -sl, asr #10
     674:	2e170586 	cdpcs	5, 1, cr0, cr7, cr6, {4}
     678:	00301905 	eorseq	r1, r0, r5, lsl #18
     67c:	06010402 	streq	r0, [r1], -r2, lsl #8
{
     680:	02002e08 	andeq	r2, r0, #8, 28	@ 0x80
     684:	054a0304 	strbeq	r0, [sl, #-772]	@ 0xfffffcfc
    xReturn = prvCreateIdleTasks();
     688:	09030615 	stmdbeq	r3, {r0, r2, r4, r9, sl}
    if( xReturn == pdPASS )
     68c:	03260582 			@ <UNDEFINED> instruction: 0x03260582
     690:	01410210 	cmpeq	r1, r0, lsl r2
    __asm volatile
     694:	052e4105 	streq	r4, [lr, #-261]!	@ 0xfffffefb
     698:	31053c1f 	tstcc	r5, pc, lsl ip
     69c:	0313053e 	tsteq	r3, #260046848	@ 0xf800000
     6a0:	052e7fb9 	streq	r7, [lr, #-4025]!	@ 0xfffff047
}
     6a4:	00e00315 	rsceq	r0, r0, r5, lsl r3
        xNextTaskUnblockTime = portMAX_DELAY;
     6a8:	9e130520 	cfmul64ls	mvdx0, mvdx3, mvdx0
     6ac:	05302505 	ldreq	r2, [r0, #-1285]!	@ 0xfffffafb
        xSchedulerRunning = pdTRUE;
     6b0:	2e2f0323 	cdpcs	3, 2, cr0, cr15, cr3, {1}
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
     6b4:	052e1305 	streq	r1, [lr, #-773]!	@ 0xfffffcfb
     6b8:	16053025 	strne	r3, [r5], -r5, lsr #32
        ( void ) xPortStartScheduler();
     6bc:	053c2a03 	ldreq	r2, [ip, #-2563]!	@ 0xfffff5fd
    ( void ) uxTopUsedPriority;
     6c0:	580d030c 	stmdapl	sp, {r2, r3, r8, r9}
}
     6c4:	05210105 	streq	r0, [r1, #-261]!	@ 0xfffffefb
     6c8:	018a0305 	orreq	r0, sl, r5, lsl #6
     6cc:	22059008 	andcs	r9, r5, #8
     6d0:	2e0b053f 	mcrcs	5, 0, r0, cr11, cr15, {1}
     6d4:	05322105 	ldreq	r2, [r2, #-261]!	@ 0xfffffefb
     6d8:	00cb0305 	sbceq	r0, fp, r5, lsl #6
{
     6dc:	0321053c 			@ <UNDEFINED> instruction: 0x0321053c
     6e0:	05207fb9 	streq	r7, [r0, #-4025]!	@ 0xfffff047
    __asm volatile
     6e4:	3c2e030d 	stccc	3, cr0, [lr], #-52	@ 0xffffffcc
     6e8:	09050204 	stmdbeq	r5, {r2, r9}
     6ec:	3c58e903 	mrrccc	9, 0, lr, r8, cr3	@ <UNPREDICTABLE>
     6f0:	044c1005 	strbeq	r1, [ip], #-5
}
     6f4:	000d0501 	andeq	r0, sp, r1, lsl #10
    xSchedulerRunning = pdFALSE;
     6f8:	03010402 	movweq	r0, #5122	@ 0x1402
    vPortEndScheduler();
     6fc:	00202795 	mlaeq	r0, r5, r7, r2
}
     700:	06030402 	streq	r0, [r3], -r2, lsl #8
     704:	5e069008 	cdppl	0, 0, cr9, cr6, cr8, {0}
     708:	13030505 	movwne	r0, #13573	@ 0x3505
{
     70c:	0301052e 	movweq	r0, #5422	@ 0x152e
        uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended + 1U );
     710:	05e400ea 	strbeq	r0, [r4, #234]!	@ 0xea
     714:	5813032e 	ldmdapl	r3, {r1, r2, r3, r5, r8, r9}
     718:	5a2e0505 	bpl	b81b34 <_etext+0xb7f664>
}
     71c:	6c4d0105 	stfvse	f0, [sp], {5}
     720:	0c030505 	cfstr32eq	mvfx0, [r3], {5}
     724:	f4086d66 			@ <UNDEFINED> instruction: 0xf4086d66
{
     728:	034d0105 	movteq	r0, #53509	@ 0xd105
     72c:	1605742b 	strne	r7, [r5], -fp, lsr #8
    TCB_t * pxTCB = NULL;
     730:	054a1603 	strbeq	r1, [sl, #-1539]	@ 0xfffff9fd
    BaseType_t xAlreadyYielded = pdFALSE;
     734:	05052e14 	streq	r2, [r5, #-3604]	@ 0xfffff1ec
        taskENTER_CRITICAL();
     738:	04020030 	streq	r0, [r2], #-48	@ 0xffffffd0
            const BaseType_t xCoreID = ( BaseType_t ) portGET_CORE_ID();
     73c:	2e080601 	cfmadd32cs	mvax0, mvfx0, mvfx8, mvfx1
            uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended - 1U );
     740:	03040200 	movweq	r0, #16896	@ 0x4200
     744:	061e054a 	ldreq	r0, [lr], -sl, asr #10
            if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
     748:	2e070584 	cfsh32cs	mvfx0, mvfx7, #-60
     74c:	00300905 	eorseq	r0, r0, r5, lsl #18
     750:	06010402 	streq	r0, [r1], -r2, lsl #8
                if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     754:	02002e08 	andeq	r2, r0, #8, 28	@ 0x80
     758:	064a0304 	strbeq	r0, [sl], -r4, lsl #6
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     75c:	02140383 	andseq	r0, r4, #201326594	@ 0xc000002
                        pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     760:	1b050142 	blne	140c70 <_etext+0x13e7a0>
     764:	3605b108 	strcc	fp, [r5], -r8, lsl #2
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
     768:	3c0b052e 	cfstr32cc	mvfx0, [fp], {46}	@ 0x2e
     76c:	05331505 	ldreq	r1, [r3, #-1285]!	@ 0xfffffafb
     770:	15053221 	strne	r3, [r5, #-545]	@ 0xfffffddf
     774:	030c054e 	movweq	r0, #50510	@ 0xc54e
     778:	01052e15 	tsteq	r5, r5, lsl lr
     77c:	05250821 	streq	r0, [r5, #-2081]!	@ 0xfffff7df
     780:	580a0305 	stmdapl	sl, {r0, r2, r8, r9}
     784:	055f1405 	ldrbeq	r1, [pc, #-1029]	@ 387 <prvCreateTask+0x63>
     788:	02003e05 	andeq	r3, r0, #5, 28	@ 0x50
     78c:	08060104 	stmdaeq	r6, {r2, r8}
     790:	04020020 	streq	r0, [r2], #-32	@ 0xffffffe0
     794:	03064a03 	movweq	r4, #27139	@ 0x6a03
     798:	02008213 	andeq	r8, r0, #805306369	@ 0x30000001
     79c:	08060104 	stmdaeq	r6, {r2, r8}
     7a0:	0402002e 	streq	r0, [r2], #-46	@ 0xffffffd2
                        listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
     7a4:	83064a03 	movwhi	r4, #27139	@ 0x6a03
     7a8:	41021b05 	tstmi	r2, r5, lsl #22
     7ac:	2e360516 	mrccs	5, 1, r0, cr6, cr6, {0}
     7b0:	053c0b05 	ldreq	r0, [ip, #-2821]!	@ 0xfffff4fb
     7b4:	01053421 	tsteq	r5, r1, lsr #8
     7b8:	cc3c1203 	lfmgt	f1, 4, [ip], #-12
     7bc:	054e0505 	strbeq	r0, [lr, #-1285]	@ 0xfffffafb
     7c0:	24053023 	strcs	r3, [r5], #-35	@ 0xffffffdd
     7c4:	4c05054b 	cfstr32mi	mvfx0, [r5], {75}	@ 0x4b
     7c8:	86310105 	ldrthi	r0, [r1], -r5, lsl #2
     7cc:	054e1f05 	strbeq	r1, [lr, #-3845]	@ 0xfffff0fb
     7d0:	01054b20 	tsteq	r5, r0, lsr #22
     7d4:	0505a34d 	streq	sl, [r5, #-845]	@ 0xfffffcb3
     7d8:	311a0560 	tstcc	sl, r0, ror #10
     7dc:	053d4405 	ldreq	r4, [sp, #-1029]!	@ 0xfffffbfb
     7e0:	2b052e1a 	blcs	14c050 <_etext+0x149b80>
                        prvAddTaskToReadyList( pxTCB );
     7e4:	053c1803 	ldreq	r1, [ip, #-2051]!	@ 0xfffff7fd
     7e8:	0b052e1f 	bleq	14c06c <_etext+0x149b9c>
     7ec:	005f052e 	subseq	r0, pc, lr, lsr #10
     7f0:	2e010402 	cdpcs	4, 0, cr0, cr1, cr2, {0}
     7f4:	02003e05 	andeq	r3, r0, #5, 28	@ 0x50
     7f8:	052e0104 	streq	r0, [lr, #-260]!	@ 0xfffffefc
     7fc:	1c054315 	stcne	3, cr4, [r5], {21}
     800:	4c21052f 	cfstr32mi	mvfx0, [r1], #-188	@ 0xffffff44
     804:	052e1005 	streq	r1, [lr, #-5]!
     808:	1c053f0d 	stcne	15, cr3, [r5], {13}
     80c:	4b0d052e 	blmi	341ccc <_etext+0x33f7fc>
     810:	053d1505 	ldreq	r1, [sp, #-1285]!	@ 0xfffffafb
     814:	1505401c 	strne	r4, [r5, #-28]	@ 0xffffffe4
     818:	3105053d 	tstcc	r5, sp, lsr r5
     81c:	05320c05 	ldreq	r0, [r2, #-3077]!	@ 0xfffff3fb
     820:	05942101 	ldreq	r2, [r4, #257]	@ 0x101
     824:	01053229 	tsteq	r5, r9, lsr #4
     828:	018a033f 	orreq	r0, sl, pc, lsr r3
     82c:	03090574 	movweq	r0, #38260	@ 0x9574
     830:	11054a18 	tstne	r5, r8, lsl sl
     834:	052e1803 	streq	r1, [lr, #-2051]!	@ 0xfffff7fd
     838:	11052e0f 	tstne	r5, pc, lsl #28
     83c:	03090530 	movweq	r0, #38192	@ 0x9530
     840:	01058266 	tsteq	r5, r6, ror #4
     844:	6601f203 	strvs	pc, [r1], -r3, lsl #4
     848:	053f1505 	ldreq	r1, [pc, #-1285]!	@ 34b <prvCreateTask+0x27>
     84c:	09052e05 	stmdbeq	r5, {r0, r2, r9, sl, fp, sp}
     850:	00680522 	rsbeq	r0, r8, r2, lsr #10
     854:	9c030402 	cfstrsls	mvf0, [r3], {2}
     858:	02003605 	andeq	r3, r0, #5242880	@ 0x500000
     85c:	053c0104 	ldreq	r0, [ip, #-260]!	@ 0xfffffefc
     860:	3d3d4105 	ldfccs	f4, [sp, #-20]!	@ 0xffffffec
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     864:	10031705 	andne	r1, r3, r5, lsl #14
     868:	3d1f053c 	cfldr32cc	mvfx0, [pc, #-240]	@ 780 <xTaskResumeAll+0x58>
     86c:	083d0105 	ldmdaeq	sp!, {r0, r2, r8}
     870:	00c80316 	sbceq	r0, r8, r6, lsl r3
                                xYieldPendings[ xCoreID ] = pdTRUE;
     874:	02d8032e 	sbcseq	r0, r8, #-1207959552	@ 0xb8000000
     878:	2f09054a 	svccs	0x0009054a
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     87c:	053c0705 	ldreq	r0, [ip, #-1797]!	@ 0xfffff8fb
     880:	0105341e 	tsteq	r5, lr, lsl r4
     884:	054a0a03 	strbeq	r0, [sl, #-2563]	@ 0xfffff5fd
                    if( pxTCB != NULL )
     888:	1e051e20 	cdpne	14, 0, cr1, cr5, cr0, {1}
                        prvResetNextTaskUnblockTime();
     88c:	3001054a 	andcc	r0, r1, sl, asr #10
                        TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
     890:	05890905 	streq	r0, [r9, #2309]	@ 0x905
     894:	14054415 	strne	r4, [r5], #-1045	@ 0xfffffbeb
                        if( xPendedCounts > ( TickType_t ) 0U )
     898:	21090540 	tstcs	r9, r0, asr #10
                                if( xTaskIncrementTick() != pdFALSE )
     89c:	16030505 	strne	r0, [r3], -r5, lsl #10
     8a0:	4b160574 	blmi	581e78 <_etext+0x57f9a8>
     8a4:	05320b05 	ldreq	r0, [r2, #-2821]!	@ 0xfffff4fb
                                    xYieldPendings[ xCoreID ] = pdTRUE;
     8a8:	0402002a 	streq	r0, [r2], #-42	@ 0xffffffd6
     8ac:	19053c01 	stmdbne	r5, {r0, sl, fp, ip, sp}
                                --xPendedCounts;
     8b0:	4410053f 	ldrmi	r0, [r0], #-1343	@ 0xfffffac1
     8b4:	05210505 	streq	r0, [r1, #-1285]!	@ 0xfffffafb
                            } while( xPendedCounts > ( TickType_t ) 0U );
     8b8:	089f0301 	ldmeq	pc, {r0, r8, r9}	@ <UNPREDICTABLE>
                            xPendedTicks = 0;
     8bc:	41100582 	tstmi	r0, r2, lsl #11
     8c0:	052e0e05 	streq	r0, [lr, #-3589]!	@ 0xfffff1fb
                    if( xYieldPendings[ xCoreID ] != pdFALSE )
     8c4:	0c053205 	sfmeq	f3, 4, [r5], {5}
     8c8:	21010586 	smlabbcs	r1, r6, r5, r0
     8cc:	21030505 	tstcs	r3, r5, lsl #10
                            xAlreadyYielded = pdTRUE;
     8d0:	68250582 	stmdavs	r5!, {r1, r7, r8, sl}
                            taskYIELD_TASK_CORE_IF_USING_PREEMPTION( pxCurrentTCB );
     8d4:	05361b05 	ldreq	r1, [r6, #-2821]!	@ 0xfffff4fb
     8d8:	0b052e2c 	bleq	14c190 <_etext+0x149cc0>
     8dc:	00480558 	subeq	r0, r8, r8, asr r5
     8e0:	2e010402 	cdpcs	4, 0, cr0, cr1, cr2, {0}
     8e4:	05400d05 	strbeq	r0, [r0, #-3333]	@ 0xfffff2fb
        taskEXIT_CRITICAL();
     8e8:	25053411 	strcs	r3, [r5, #-1041]	@ 0xfffffbef
}
     8ec:	2e360531 	mrccs	5, 1, r0, cr6, cr1, {1}
     8f0:	05581705 	ldrbeq	r1, [r8, #-1797]	@ 0xfffff8fb
     8f4:	48053125 	stmdami	r5, {r0, r2, r5, r8, ip, sp}
     8f8:	5b26052e 	blpl	981db8 <_etext+0x97f8e8>
     8fc:	05351105 	ldreq	r1, [r5, #-261]!	@ 0xfffffefb
     900:	15053313 	strne	r3, [r5, #-787]	@ 0xfffffced
     904:	511f053f 	tstpl	pc, pc, lsr r5	@ <UNPREDICTABLE>
     908:	053f0f05 	ldreq	r0, [pc, #-3845]!	@ fffffa0b <__StackTop+0xdfffda0b>
     90c:	0402002c 	streq	r0, [r2], #-44	@ 0xffffffd4
     910:	11053c01 	tstne	r5, r1, lsl #24
     914:	8a09053e 	bhi	241e14 <_etext+0x23f944>
{
     918:	05312405 	ldreq	r2, [r1, #-1029]!	@ 0xfffffbfb
     91c:	0f052e16 	svceq	0x00052e16
        xTicks = xTickCount;
     920:	3e130568 	cfmsc32cc	mvfx0, mvfx3, mvfx8
    return xTicks;
     924:	053e2105 	ldreq	r2, [lr, #-261]!	@ 0xfffffefb
}
     928:	21052e46 	tstcs	r5, r6, asr #28
     92c:	2e510578 	mrccs	5, 2, r0, cr1, cr8, {3}
     930:	052e4605 	streq	r4, [lr, #-1541]!	@ 0xfffff9fb
{
     934:	3c056019 	stccc	0, cr6, [r5], {25}
     938:	5a09052e 	bpl	241df8 <_etext+0x23f928>
    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
     93c:	05321005 	ldreq	r1, [r2, #-5]!
        xReturn = xTickCount;
     940:	0c032105 	stfeqs	f2, [r3], {5}
    return xReturn;
     944:	752e0582 	strvc	r0, [lr, #-1410]!	@ 0xfffffa7e
}
     948:	05361b05 	ldreq	r1, [r6, #-2821]!	@ 0xfffff4fb
     94c:	0b052e2a 	bleq	14c1fc <_etext+0x149d2c>
     950:	005d0558 	subseq	r0, sp, r8, asr r5
{
     954:	2e010402 	cdpcs	4, 0, cr0, cr1, cr2, {0}
    return uxCurrentNumberOfTasks;
     958:	05400d05 	strbeq	r0, [r0, #-3333]	@ 0xfffff2fb
}
     95c:	25053311 	strcs	r3, [r5, #-785]	@ 0xfffffcef
     960:	2e340531 	mrccs	5, 1, r0, cr4, cr1, {1}
     964:	05581705 	ldrbeq	r1, [r8, #-1797]	@ 0xfffff8fb
{
     968:	36053325 	strcc	r3, [r5], -r5, lsr #6
     96c:	584d052e 	stmdapl	sp, {r1, r2, r3, r5, r8, sl}^
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     970:	052e4a05 	streq	r4, [lr, #-2565]!	@ 0xfffff5fb
     974:	48056925 	stmdami	r5, {r0, r2, r5, r8, fp, sp, lr}
     978:	5b26052e 	blpl	981e38 <_etext+0x97f968>
     97c:	05351105 	ldreq	r1, [r5, #-261]!	@ 0xfffffefb
    return &( pxTCB->pcTaskName[ 0 ] );
     980:	15053313 	strne	r3, [r5, #-787]	@ 0xfffffced
}
     984:	511f053f 	tstpl	pc, pc, lsr r5	@ <UNPREDICTABLE>
     988:	053f0f05 	ldreq	r0, [pc, #-3845]!	@ fffffa8b <__StackTop+0xdfffda8b>
     98c:	0402002c 	streq	r0, [r2], #-44	@ 0xffffffd4
     990:	11053c01 	tstne	r5, r1, lsl #24
{
     994:	8a09053e 	bhi	241e94 <_etext+0x23f9c4>
     998:	05320f05 	ldreq	r0, [r2, #-3845]!	@ 0xfffff0fb
    vTaskSuspendAll();
     99c:	46054035 			@ <UNDEFINED> instruction: 0x46054035
    taskENTER_CRITICAL();
     9a0:	5827052e 	stmdapl	r7!, {r1, r2, r3, r5, r8, sl}
        xPendedTicks += xTicksToCatchUp;
     9a4:	05351d05 	ldreq	r1, [r5, #-3333]!	@ 0xfffff2fb
     9a8:	0f052e2c 	svceq	0x00052e2c
     9ac:	31190558 	tstcc	r9, r8, asr r5
    taskEXIT_CRITICAL();
     9b0:	05421d05 	strbeq	r1, [r2, #-3333]	@ 0xfffff2fb
    xYieldOccurred = xTaskResumeAll();
     9b4:	45052e2e 	strmi	r2, [r5, #-3630]	@ 0xfffff1d2
     9b8:	2e420558 	mcrcs	5, 2, r0, cr2, cr8, {2}
}
     9bc:	31671905 	cmncc	r7, r5, lsl #18
     9c0:	052e3c05 	streq	r3, [lr, #-3077]!	@ 0xfffff3fb
     9c4:	10055a09 	andne	r5, r5, r9, lsl #20
{
     9c8:	21050532 	tstcs	r5, r2, lsr r5
     9cc:	05900c03 	ldreq	r0, [r0, #3075]	@ 0xc03
    BaseType_t xSwitchRequired = pdFALSE;
     9d0:	0f057614 	svceq	0x00057614
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
     9d4:	30090535 	andcc	r0, r9, r5, lsr r5
     9d8:	05300f05 	ldreq	r0, [r0, #-3845]!	@ 0xfffff0fb
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     9dc:	2f053e47 	svccs	0x00053e47
     9e0:	31230566 			@ <UNDEFINED> instruction: 0x31230566
        xTickCount = xConstTickCount;
     9e4:	05683505 	strbeq	r3, [r8, #-1285]!	@ 0xfffffafb
     9e8:	2b05680d 	blcs	15aa24 <_etext+0x158554>
        if( xConstTickCount == ( TickType_t ) 0U )
     9ec:	663f05f5 			@ <UNDEFINED> instruction: 0x663f05f5
            taskSWITCH_DELAYED_LISTS();
     9f0:	05831505 	streq	r1, [r3, #1285]	@ 0x505
     9f4:	4205232d 	andmi	r2, r5, #-1275068416	@ 0xb4000000
     9f8:	75150566 	ldrvc	r0, [r5, #-1382]	@ 0xfffffa9a
     9fc:	05233f05 	streq	r3, [r3, #-3845]!	@ 0xfffff0fb
     a00:	17057515 	smladne	r5, r5, r5, r7
     a04:	3e430524 	cdpcc	5, 4, cr0, cr3, cr4, {1}
     a08:	057c1505 	ldrbeq	r1, [ip, #-1285]!	@ 0xfffffafb
     a0c:	15051d21 	strne	r1, [r5, #-3361]	@ 0xfffff2df
     a10:	200f0331 	andcs	r0, pc, r1, lsr r3	@ <UNPREDICTABLE>
        if( xConstTickCount >= xNextTaskUnblockTime )
     a14:	05270f05 	streq	r0, [r7, #-3845]!	@ 0xfffff0fb
     a18:	02003e11 	andeq	r3, r0, #272	@ 0x110
     a1c:	08060104 	stmdaeq	r6, {r2, r8}
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     a20:	0402002e 	streq	r0, [r2], #-46	@ 0xffffffd2
     a24:	83064a03 	movwhi	r4, #27139	@ 0x6a03
                    xNextTaskUnblockTime = portMAX_DELAY;
     a28:	41021703 	tstmi	r2, r3, lsl #14
     a2c:	04020001 	streq	r0, [r2], #-1
                    break;
     a30:	05740601 	ldrbeq	r0, [r4, #-1537]!	@ 0xfffff9ff
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     a34:	05890609 	streq	r0, [r9, #1545]	@ 0x609
     a38:	05053210 	streq	r3, [r5, #-528]	@ 0xfffffdf0
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     a3c:	c80d0321 	stmdagt	sp, {r0, r5, r8, r9}
     a40:	05771405 	ldrbeq	r1, [r7, #-1029]!	@ 0xfffffbfb
                    if( xConstTickCount < xItemValue )
     a44:	2e1a030f 	cdpcs	3, 1, cr0, cr10, cr15, {0}
     a48:	05050204 	streq	r0, [r5, #-516]	@ 0xfffffdfc
                        xNextTaskUnblockTime = xItemValue;
     a4c:	2e42ea03 	vmlacs.f32	s29, s4, s6
                        break;
     a50:	0c030c05 	stceq	12, cr0, [r3], {5}
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
     a54:	050104ba 	streq	r0, [r1, #-1210]	@ 0xfffffb46
     a58:	3d8f0332 	stccc	3, cr0, [pc, #200]	@ b28 <xTaskIncrementTick+0x160>
     a5c:	220f0520 	andcs	r0, pc, #32, 10	@ 0x8000000
     a60:	053e4705 	ldreq	r4, [lr, #-1797]!	@ 0xfffff8fb
     a64:	2305662f 	movwcs	r6, #22063	@ 0x562f
     a68:	75350531 	ldrvc	r0, [r5, #-1329]!	@ 0xfffffacf
     a6c:	05680d05 	strbeq	r0, [r8, #-3333]!	@ 0xfffff2fb
     a70:	0515082b 	ldreq	r0, [r5, #-2091]	@ 0xfffff7d5
     a74:	1505663f 	strne	r6, [r5, #-1599]	@ 0xfffff9c1
     a78:	232d0583 			@ <UNDEFINED> instruction: 0x232d0583
     a7c:	05664205 	strbeq	r4, [r6, #-517]!	@ 0xfffffdfb
     a80:	3f057515 	svccc	0x00057515
     a84:	75150523 	ldrvc	r0, [r5, #-1315]	@ 0xfffffadd
     a88:	05241705 	streq	r1, [r4, #-1797]!	@ 0xfffff8fb
     a8c:	15054c43 	strne	r4, [r5, #-3139]	@ 0xfffff3bd
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     a90:	1d21057c 	cfstr32ne	mvfx0, [r1, #-496]!	@ 0xfffffe10
     a94:	03311505 	teqeq	r1, #20971520	@ 0x1400000
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
     a98:	0f05200e 	svceq	0x0005200e
     a9c:	5d2a0527 	cfstr32pl	mvfx0, [sl, #-156]!	@ 0xffffff64
     aa0:	052e1305 	streq	r1, [lr, #-773]!	@ 0xfffffcfb
     aa4:	02003015 	andeq	r3, r0, #21
     aa8:	08060104 	stmdaeq	r6, {r2, r8}
     aac:	0402002e 	streq	r0, [r2], #-46	@ 0xffffffd2
     ab0:	83064a03 	movwhi	r4, #27139	@ 0x6a03
     ab4:	42021603 	andmi	r1, r2, #3145728	@ 0x300000
     ab8:	081e0501 	ldmdaeq	lr, {r0, r8, sl}
     abc:	2e3905b1 	mrccs	5, 1, r0, cr9, cr1, {5}
     ac0:	053c1705 	ldreq	r1, [ip, #-1797]!	@ 0xfffff8fb
     ac4:	3805321b 	stmdacc	r5, {r0, r1, r3, r4, r9, ip, sp}
     ac8:	422d053e 	eormi	r0, sp, #260046848	@ 0xf800000
     acc:	05050204 	streq	r0, [r5, #-516]	@ 0xfffffdfc
     ad0:	58428f03 	stmdapl	r2, {r0, r1, r8, r9, sl, fp, pc}^
     ad4:	04400105 	strbeq	r0, [r0], #-261	@ 0xfffffefb
                    prvAddTaskToReadyList( pxTCB );
     ad8:	03100501 	tsteq	r0, #4194304	@ 0x400000
     adc:	05203e8b 	streq	r3, [r0, #-3723]!	@ 0xfffff175
     ae0:	0a032105 	beq	c8efc <_etext+0xc6a2c>
     ae4:	0f052008 	svceq	0x00052008
     ae8:	04661c03 	strbteq	r1, [r6], #-3075	@ 0xfffff3fd
     aec:	03050502 	movweq	r0, #21762	@ 0x5502
     af0:	052e41b8 	streq	r4, [lr, #-440]!	@ 0xfffffe48
     af4:	ba0c030c 	blt	30172c <_etext+0x2ff25c>
     af8:	32050104 	andcc	r0, r5, #4, 2
     afc:	203ec103 	eorscs	ip, lr, r3, lsl #2
     b00:	05222305 	streq	r2, [r2, #-773]!	@ 0xfffffcfb
     b04:	25057535 	strcs	r7, [r5, #-1333]	@ 0xfffffacb
     b08:	663a056a 	ldrtvs	r0, [sl], -sl, ror #10
     b0c:	057a0f05 	ldrbeq	r0, [sl, #-3845]!	@ 0xfffff0fb
     b10:	13055d2a 	movwne	r5, #23850	@ 0x5d2a
     b14:	3015052e 	andscc	r0, r5, lr, lsr #10
     b18:	01040200 	mrseq	r0, R12_usr
     b1c:	002e0806 	eoreq	r0, lr, r6, lsl #16
     b20:	4a030402 	bmi	c1b30 <_etext+0xbf660>
     b24:	16038306 	strne	r8, [r3], -r6, lsl #6
     b28:	05014202 	streq	r4, [r1, #-514]	@ 0xfffffdfe
     b2c:	05b1081e 	ldreq	r0, [r1, #2078]!	@ 0x81e
     b30:	17052e39 	smladxne	r5, r9, lr, r2
     b34:	321b053c 	andscc	r0, fp, #60, 10	@ 0xf000000
     b38:	053e3805 	ldreq	r3, [lr, #-2053]!	@ 0xfffff7fb
     b3c:	0204422d 	andeq	r4, r4, #-805306366	@ 0xd0000002
     b40:	89030505 	stmdbhi	r3, {r0, r2, r8, sl}
     b44:	01055841 	tsteq	r5, r1, asr #16
     b48:	05010440 	streq	r0, [r1, #-1088]	@ 0xfffffbc0
     b4c:	3f900305 	svccc	0x00900305
     b50:	08090320 	stmdaeq	r9, {r5, r8, r9}
     b54:	03110520 	tsteq	r1, #32, 10	@ 0x8000000
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     b58:	0200580a 	andeq	r5, r0, #655360	@ 0xa0000
     b5c:	3c060104 	stfccs	f0, [r6], {4}
     b60:	02040200 	andeq	r0, r4, #0, 4
     b64:	000f053c 	andeq	r0, pc, ip, lsr r5	@ <UNPREDICTABLE>
                                xSwitchRequired = pdTRUE;
     b68:	06040402 	streq	r0, [r4], -r2, lsl #8
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     b6c:	23090520 	movwcs	r0, #38176	@ 0x9520
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > 1U )
     b70:	05302505 	ldreq	r2, [r0, #-1285]!	@ 0xfffffafb
     b74:	3805660f 	stmdacc	r5, {r0, r1, r2, r3, r9, sl, sp, lr}
     b78:	67190530 			@ <UNDEFINED> instruction: 0x67190530
     b7c:	31090540 	tstcc	r9, r0, asr #10
     b80:	05321005 	ldreq	r1, [r2, #-5]!
     b84:	0a032105 	beq	c8fa0 <_etext+0xc6ad0>
                    xSwitchRequired = pdTRUE;
     b88:	03110574 	tsteq	r1, #116, 10	@ 0x1d000000
                if( xYieldPendings[ 0 ] != pdFALSE )
     b8c:	0200660a 	andeq	r6, r0, #10485760	@ 0xa00000
     b90:	3c060104 	stfccs	f0, [r6], {4}
                    xSwitchRequired = pdTRUE;
     b94:	02040200 	andeq	r0, r4, #0, 4
        xPendedTicks += 1U;
     b98:	000f053c 	andeq	r0, pc, ip, lsr r5	@ <UNPREDICTABLE>
     b9c:	06040402 	streq	r0, [r4], -r2, lsl #8
     ba0:	23090520 	movwcs	r0, #38176	@ 0x9520
}
     ba4:	05321605 	ldreq	r1, [r2, #-1541]!	@ 0xfffff9fb
     ba8:	39057523 	stmdbcc	r5, {r0, r1, r5, r8, sl, ip, sp, lr}
     bac:	2e360566 	cdpcs	5, 3, cr0, cr6, cr6, {3}
     bb0:	05760905 	ldrbeq	r0, [r6, #-2309]!	@ 0xfffff6fb
     bb4:	05053210 	streq	r3, [r5, #-528]	@ 0xfffffdf0
     bb8:	03010521 	movweq	r0, #5409	@ 0x1521
     bbc:	057401ad 	ldrbeq	r0, [r4, #-429]!	@ 0xfffffe53
     bc0:	14055a16 	strne	r5, [r5], #-2582	@ 0xfffff5ea
     bc4:	26053d3d 			@ <UNDEFINED> instruction: 0x26053d3d
     bc8:	053c0d03 	ldreq	r0, [ip, #-3331]!	@ 0xfffff2fd
     bcc:	07052e09 	streq	r2, [r5, -r9, lsl #28]
     bd0:	01040200 	mrseq	r0, R12_usr
     bd4:	32090558 	andcc	r0, r9, #88, 10	@ 0x16000000
    {
     bd8:	3b031505 	blcc	c5ff4 <_etext+0xc3b24>
     bdc:	4d0905ba 	cfstr32mi	mvfx0, [r9, #-744]	@ 0xfffffd18
        if( uxSchedulerSuspended != ( UBaseType_t ) 0U )
     be0:	054c0b05 	strbeq	r0, [ip, #-2821]	@ 0xfffff4fb
     be4:	0d054e40 	stceq	14, cr4, [r5, #-256]	@ 0xffffff00
            xYieldPendings[ 0 ] = pdTRUE;
     be8:	0301052e 	movweq	r0, #5422	@ 0x152e
    }
     bec:	38055819 	stmdacc	r5, {r0, r3, r4, fp, ip, lr}
            xYieldPendings[ 0 ] = pdFALSE;
     bf0:	05206d03 	streq	r6, [r0, #-3331]!	@ 0xfffff2fd
            taskSELECT_HIGHEST_PRIORITY_TASK();
     bf4:	1d052e0d 	stcne	14, cr2, [r5, #-52]	@ 0xffffffcc
     bf8:	2e0f055d 	cfrshl32cs	mvfx15, mvfx13, r0
        __asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
     bfc:	053e2605 	ldreq	r2, [lr, #-1541]!	@ 0xfffff9fb
     c00:	3c0c0301 	stccc	3, cr0, [ip], {1}
     c04:	f200f403 	vshl.s8	d15, d3, d0
     c08:	05421605 	strbeq	r1, [r2, #-1541]	@ 0xfffff9fb
     c0c:	3c11031c 	ldccc	3, cr0, [r1], {28}
     c10:	053d1005 	ldreq	r1, [sp, #-5]!
     c14:	17053d18 	smladne	r5, r8, sp, r3
     c18:	3d12053d 	cfldr32cc	mvfx0, [r2, #-244]	@ 0xffffff0c
     c1c:	2e05053e 	mcrcs	5, 0, r0, cr5, cr14, {1}
     c20:	05222305 	streq	r2, [r2, #-773]!	@ 0xfffffcfb
     c24:	0402003f 	streq	r0, [r2], #-63	@ 0xffffffc1
     c28:	1f055603 	svcne	0x00055603
     c2c:	01040200 	mrseq	r0, R12_usr
     c30:	4115053c 	tstmi	r5, ip, lsr r5
     c34:	053d1205 	ldreq	r1, [sp, #-517]!	@ 0xfffffdfb
     c38:	053e3d1a 	ldreq	r3, [lr, #-3354]!	@ 0xfffff2e6
     c3c:	3c0b0301 	stccc	3, cr0, [fp], {1}
     c40:	01001b02 	tsteq	r0, r2, lsl #22
            portTASK_SWITCH_HOOK( pxCurrentTCB );
     c44:	0001ac01 	andeq	sl, r1, r1, lsl #24
    }
     c48:	c2000300 	andgt	r0, r0, #0, 6
     c4c:	02000000 	andeq	r0, r0, #0
     c50:	0d0efb01 	vstreq	d15, [lr, #-4]
     c54:	01010100 	mrseq	r0, (UNDEF: 17)
     c58:	00000001 	andeq	r0, r0, r1
     c5c:	01000001 	tsteq	r0, r1
     c60:	462f2e2e 	strtmi	r2, [pc], -lr, lsr #28
{
     c64:	52656572 	rsbpl	r6, r5, #478150656	@ 0x1c800000
     c68:	2d534f54 	ldclcs	15, cr4, [r3, #-336]	@ 0xfffffeb0
     c6c:	6e72654b 	cdpvs	5, 7, cr6, cr2, cr11, {2}
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     c70:	2f006c65 	svccs	0x00006c65
     c74:	2f727375 	svccs	0x00727375
     c78:	2f62696c 	svccs	0x0062696c
    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     c7c:	2f636367 	svccs	0x00636367
     c80:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
}
     c84:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
     c88:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
     c8c:	33312f69 	teqcc	r1, #420	@ 0x1a4
{
     c90:	312e322e 			@ <UNDEFINED> instruction: 0x312e322e
     c94:	636e692f 	cmnvs	lr, #770048	@ 0xbc000
     c98:	6564756c 	strbvs	r7, [r4, #-1388]!	@ 0xfffffa94
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     c9c:	2f2e2e00 	svccs	0x002e2e00
     ca0:	65657246 	strbvs	r7, [r5, #-582]!	@ 0xfffffdba
     ca4:	534f5452 	movtpl	r5, #62546	@ 0xf452
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     ca8:	72654b2d 	rsbvc	r4, r5, #46080	@ 0xb400
     cac:	2f6c656e 	svccs	0x006c656e
     cb0:	74726f70 	ldrbtvc	r6, [r2], #-3952	@ 0xfffff090
     cb4:	656c6261 	strbvs	r6, [ip, #-609]!	@ 0xfffffd9f
     cb8:	4343472f 	movtmi	r4, #14127	@ 0x372f
     cbc:	4d52412f 	ldfmie	f4, [r2, #-188]	@ 0xffffff44
     cc0:	334d435f 	movtcc	r4, #54111	@ 0xd35f
     cc4:	2f2e2e00 	svccs	0x002e2e00
     cc8:	65657246 	strbvs	r7, [r5, #-582]!	@ 0xfffffdba
     ccc:	534f5452 	movtpl	r5, #62546	@ 0xf452
     cd0:	72654b2d 	rsbvc	r4, r5, #46080	@ 0xb400
     cd4:	2f6c656e 	svccs	0x006c656e
     cd8:	6c636e69 	stclvs	14, cr6, [r3], #-420	@ 0xfffffe5c
     cdc:	00656475 	rsbeq	r6, r5, r5, ror r4
     ce0:	73696c00 	cmnvc	r9, #0, 24
     ce4:	00632e74 	rsbeq	r2, r3, r4, ror lr
     ce8:	73000001 	movwvc	r0, #1
    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     cec:	6e696474 	mcrvs	4, 3, r6, cr9, cr4, {3}
     cf0:	00682e74 	rsbeq	r2, r8, r4, ror lr
}
     cf4:	70000002 	andvc	r0, r0, r2
     cf8:	6d74726f 	lfmvs	f7, 2, [r4, #-444]!	@ 0xfffffe44
     cfc:	6f726361 	svcvs	0x00726361
{
     d00:	0300682e 	movweq	r6, #2094	@ 0x82e
     d04:	696c0000 	stmdbvs	ip!, {}^	@ <UNPREDICTABLE>
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     d08:	682e7473 	stmdavs	lr!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}
     d0c:	00000400 	andeq	r0, r0, r0, lsl #8
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
     d10:	00010500 	andeq	r0, r1, r0, lsl #10
     d14:	1c100205 	lfmne	f0, 4, [r0], {5}
     d18:	31030000 	mrscc	r0, (UNDEF: 3)
     d1c:	50280501 	eorpl	r0, r8, r1, lsl #10
     d20:	053c1505 	ldreq	r1, [ip, #-1285]!	@ 0xfffffafb
     d24:	30053421 	andcc	r3, r5, r1, lsr #8
     d28:	3c1d054e 	cfldr32cc	mvfx0, [sp], {78}	@ 0x4e
     d2c:	052f3405 	streq	r3, [pc, #-1029]!	@ 92f <xTaskGetTickCount+0x17>
     d30:	1d053c21 	stcne	12, cr3, [r5, #-132]	@ 0xffffff7c
     d34:	052e0b03 	streq	r0, [lr, #-2819]!	@ 0xfffff4fd
     d38:	055c4401 	ldrbeq	r4, [ip, #-1025]	@ 0xfffffbff
     d3c:	01054e19 	tsteq	r5, r9, lsl lr
     d40:	18055d44 	stmdane	r5, {r2, r6, r8, sl, fp, ip, lr}
     d44:	031b0559 	tsteq	fp, #373293056	@ 0x16400000
     d48:	28053c0d 	stmdacs	r5, {r0, r2, r3, sl, fp, ip, sp}
     d4c:	2e1f053d 	mrccs	5, 0, r0, cr15, cr13, {1}
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
     d50:	05330c05 	ldreq	r0, [r3, #-3077]!	@ 0xfffff3fb
     d54:	19052e21 	stmdbne	r5, {r0, r5, r9, sl, fp, sp}
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
     d58:	3f20052f 	svccc	0x0020052f
     d5c:	053e3b05 	ldreq	r3, [lr, #-2821]!	@ 0xfffff4fb
     d60:	21052e23 	tstcs	r5, r3, lsr #28
     d64:	31010520 	tstcc	r1, r0, lsr #10
     d68:	5a16055d 	bpl	5822e4 <_etext+0x57fe14>
     d6c:	12030705 	andne	r0, r3, #1310720	@ 0x140000
     d70:	4c14053c 	cfldr32mi	mvfx0, [r4], {60}	@ 0x3c
     d74:	1d031905 	vstrne.16	s2, [r3, #-10]	@ <UNPREDICTABLE>
     d78:	3c09054a 	cfstr32cc	mvfx0, [r9], {74}	@ 0x4a
     d7c:	00018305 	andeq	r8, r1, r5, lsl #6
     d80:	20030402 	andcs	r0, r3, r2, lsl #8
     d84:	02004d05 	andeq	r4, r0, #320	@ 0x140
     d88:	053c0104 	ldreq	r0, [ip, #-260]!	@ 0xfffffefc
     d8c:	04020055 	streq	r0, [r2], #-85	@ 0xffffffab
     d90:	62052e01 	andvs	r2, r5, #1, 28
        prvAddTaskToReadyList( pxUnblockedTCB );
     d94:	01040200 	mrseq	r0, R12_usr
     d98:	03270520 			@ <UNDEFINED> instruction: 0x03270520
     d9c:	1b053c09 	blne	14fdc8 <_etext+0x14d8f8>
     da0:	2f12052e 	svccs	0x0012052e
     da4:	052e2705 	streq	r2, [lr, #-1797]!	@ 0xfffff8fb
     da8:	18052f1f 	stmdane	r5, {r0, r1, r2, r3, r4, r8, r9, sl, fp, sp}
     dac:	4020053d 	eormi	r0, r0, sp, lsr r5
     db0:	053e3b05 	ldreq	r3, [lr, #-2821]!	@ 0xfffff4fb
     db4:	21052e23 	tstcs	r5, r3, lsr #28
     db8:	31010520 	tstcc	r1, r0, lsr #10
     dbc:	4d14055d 	cfldr32mi	mvfx0, [r4, #-372]	@ 0xfffffe8c
     dc0:	05401305 	strbeq	r1, [r0, #-773]	@ 0xfffffcfb
     dc4:	28052e38 	stmdacs	r5, {r3, r4, r5, r9, sl, fp, sp}
     dc8:	2113052e 	tstcs	r3, lr, lsr #10
     dcc:	052e3805 	streq	r3, [lr, #-2053]!	@ 0xfffff7fb
     dd0:	0f052e28 	svceq	0x00052e28
     dd4:	2e070526 	cfsh32cs	mvfx0, mvfx7, #22
     dd8:	053e2905 	ldreq	r2, [lr, #-2309]!	@ 0xfffff6fb
     ddc:	21052e19 	tstcs	r5, r9, lsl lr
     de0:	3d3b0535 	cfldr32cc	mvfx0, [fp, #-212]!	@ 0xffffff2c
     de4:	052e2305 	streq	r2, [lr, #-773]!	@ 0xfffffcfb
     de8:	12052021 	andne	r2, r5, #33	@ 0x21
     dec:	2f010532 	svccs	0x00010532
     df0:	01000502 	tsteq	r0, r2, lsl #10
     df4:	0003ac01 	andeq	sl, r3, r1, lsl #24
     df8:	0f000300 	svceq	0x00000300
     dfc:	02000001 	andeq	r0, r0, #1
     e00:	0d0efb01 	vstreq	d15, [lr, #-4]
     e04:	01010100 	mrseq	r0, (UNDEF: 17)
     e08:	00000001 	andeq	r0, r0, r1
     e0c:	01000001 	tsteq	r0, r1
     e10:	462f2e2e 	strtmi	r2, [pc], -lr, lsr #28
     e14:	52656572 	rsbpl	r6, r5, #478150656	@ 0x1c800000
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     e18:	2d534f54 	ldclcs	15, cr4, [r3, #-336]	@ 0xfffffeb0
     e1c:	6e72654b 	cdpvs	5, 7, cr6, cr2, cr11, {2}
     e20:	702f6c65 	eorvc	r6, pc, r5, ror #24
     e24:	6174726f 	cmnvs	r4, pc, ror #4
     e28:	2f656c62 	svccs	0x00656c62
     e2c:	4d6d654d 	cfstr64mi	mvdx6, [sp, #-308]!	@ 0xfffffecc
     e30:	00676e61 	rsbeq	r6, r7, r1, ror #28
     e34:	7273752f 	rsbsvc	r7, r3, #197132288	@ 0xbc00000
     e38:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
     e3c:	6363672f 	cmnvs	r3, #12320768	@ 0xbc0000
     e40:	6d72612f 	ldfvse	f6, [r2, #-188]!	@ 0xffffff44
     e44:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
     e48:	61652d65 	cmnvs	r5, r5, ror #26
     e4c:	312f6962 			@ <UNDEFINED> instruction: 0x312f6962
        if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     e50:	2e322e33 	mrccs	14, 1, r2, cr2, cr3, {1}
     e54:	6e692f31 	mcrvs	15, 3, r2, cr9, cr1, {1}
     e58:	64756c63 	ldrbtvs	r6, [r5], #-3171	@ 0xfffff39d
     e5c:	2e2e0065 	cdpcs	0, 2, cr0, cr14, cr5, {3}
            xReturn = pdTRUE;
     e60:	6572462f 	ldrbvs	r4, [r2, #-1583]!	@ 0xfffff9d1
            xYieldPendings[ 0 ] = pdTRUE;
     e64:	4f545265 	svcmi	0x00545265
     e68:	654b2d53 	strbvs	r2, [fp, #-3411]	@ 0xfffff2ad
            xReturn = pdFALSE;
     e6c:	6c656e72 	stclvs	14, cr6, [r5], #-456	@ 0xfffffe38
}
     e70:	726f702f 	rsbvc	r7, pc, #47	@ 0x2f
     e74:	6c626174 	stfvse	f6, [r2], #-464	@ 0xfffffe30
     e78:	43472f65 	movtmi	r2, #32613	@ 0x7f65
     e7c:	52412f43 	subpl	r2, r1, #268	@ 0x10c
     e80:	4d435f4d 	stclmi	15, cr5, [r3, #-308]	@ 0xfffffecc
     e84:	2e2e0033 	mcrcs	0, 1, r0, cr14, cr3, {1}
     e88:	6572462f 	ldrbvs	r4, [r2, #-1583]!	@ 0xfffff9d1
     e8c:	4f545265 	svcmi	0x00545265
     e90:	654b2d53 	strbvs	r2, [fp, #-3411]	@ 0xfffff2ad
{
     e94:	6c656e72 	stclvs	14, cr6, [r5], #-456	@ 0xfffffe38
     e98:	636e692f 	cmnvs	lr, #770048	@ 0xbc000
     e9c:	6564756c 	strbvs	r7, [r4, #-1388]!	@ 0xfffffa94
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     ea0:	73752f00 	cmnvc	r5, #0, 30
     ea4:	6e692f72 	mcrvs	15, 3, r2, cr9, cr2, {3}
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem );
     ea8:	64756c63 	ldrbtvs	r6, [r5], #-3171	@ 0xfffff39d
     eac:	656e2f65 	strbvs	r2, [lr, #-3941]!	@ 0xfffff09b
    listREMOVE_ITEM( pxEventListItem );
     eb0:	62696c77 	rsbvs	r6, r9, #30464	@ 0x7700
     eb4:	65680000 	strbvs	r0, [r8, #-0]!
     eb8:	345f7061 	ldrbcc	r7, [pc], #-97	@ ec0 <vTaskRemoveFromUnorderedEventList+0x2c>
     ebc:	0100632e 	tsteq	r0, lr, lsr #6
     ec0:	74730000 	ldrbtvc	r0, [r3], #-0
     ec4:	66656464 	strbtvs	r6, [r5], -r4, ror #8
     ec8:	0200682e 	andeq	r6, r0, #3014656	@ 0x2e0000
     ecc:	74730000 	ldrbtvc	r0, [r3], #-0
     ed0:	746e6964 	strbtvc	r6, [lr], #-2404	@ 0xfffff69c
     ed4:	0200682e 	andeq	r6, r0, #3014656	@ 0x2e0000
     ed8:	6f700000 	svcvs	0x00700000
     edc:	616d7472 	smcvs	55106	@ 0xd742
     ee0:	2e6f7263 	cdpcs	2, 6, cr7, cr15, cr3, {3}
     ee4:	00030068 	andeq	r0, r3, r8, rrx
     ee8:	726f7000 	rsbvc	r7, pc, #0
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
     eec:	6c626174 	stfvse	f6, [r2], #-464	@ 0xfffffe30
     ef0:	00682e65 	rsbeq	r2, r8, r5, ror #28
     ef4:	74000004 	strvc	r0, [r0], #-4
     ef8:	2e6b7361 	cdpcs	3, 6, cr7, cr11, cr1, {3}
     efc:	00040068 	andeq	r0, r4, r8, rrx
     f00:	72747300 	rsbsvc	r7, r4, #0, 6
     f04:	2e676e69 	cdpcs	14, 6, cr6, cr7, cr9, {3}
     f08:	00050068 	andeq	r0, r5, r8, rrx
     f0c:	01050000 	mrseq	r0, (UNDEF: 5)
     f10:	70020500 	andvc	r0, r2, r0, lsl #10
     f14:	0300001d 	movweq	r0, #29
     f18:	050101ad 	streq	r0, [r1, #-429]	@ 0xfffffe53
     f1c:	05304e0c 	ldreq	r4, [r0, #-3596]!	@ 0xfffff1f4
     f20:	0d053007 	stceq	0, cr3, [r5, #-28]	@ 0xffffffe4
     f24:	2e0b0540 	cfsh32cs	mvfx0, mvfx11, #32
    prvAddTaskToReadyList( pxUnblockedTCB );
     f28:	053e1905 	ldreq	r1, [lr, #-2309]!	@ 0xfffff6fb
     f2c:	0f054e1f 	svceq	0x00054e1f
     f30:	314e053c 	cmpcc	lr, ip, lsr r5
     f34:	053c2905 	ldreq	r2, [ip, #-2309]!	@ 0xfffff6fb
     f38:	13053e15 	movwne	r3, #24085	@ 0x5e15
     f3c:	3e21052e 	cfsh64cc	mvdx0, mvdx1, #30
     f40:	0319055c 	tsteq	r9, #92, 10	@ 0x17000000
     f44:	05053c0a 	streq	r3, [r5, #-3082]	@ 0xfffff3f6
     f48:	32130536 	andscc	r0, r3, #226492416	@ 0xd800000
     f4c:	052e0b05 	streq	r0, [lr, #-2821]!	@ 0xfffff4fb
     f50:	0b03300d 	bleq	ccf8c <_etext+0xcaabc>
     f54:	200b052e 	andcs	r0, fp, lr, lsr #10
     f58:	05300f05 	ldreq	r0, [r0, #-3845]!	@ 0xfffff0fb
     f5c:	04020036 	streq	r0, [r2], #-54	@ 0xffffffca
     f60:	25053c01 	strcs	r3, [r5, #-3073]	@ 0xfffff3ff
     f64:	01040200 	mrseq	r0, R12_usr
     f68:	4021052e 	eormi	r0, r1, lr, lsr #10
     f6c:	052f1905 	streq	r1, [pc, #-2309]!	@ 66f <prvCreateIdleTasks+0x9b>
     f70:	25053f16 	strcs	r3, [r5, #-3862]	@ 0xfffff0ea
     f74:	2f1d0522 	svccs	0x001d0522
     f78:	05392105 	ldreq	r2, [r9, #-261]!	@ 0xfffffefb
     f7c:	4a052e3e 	bmi	14c87c <_etext+0x14a3ac>
     f80:	01040200 	mrseq	r0, R12_usr
     f84:	003e053c 	eorseq	r0, lr, ip, lsr r5
     f88:	2e010402 	cdpcs	4, 0, cr0, cr1, cr2, {0}
     f8c:	09031d05 	stmdbeq	r3, {r0, r2, r8, sl, fp, ip}
     f90:	2e13052e 	cfmul64cs	mvdx0, mvdx3, mvdx14
     f94:	05403d05 	strbeq	r3, [r0, #-3333]	@ 0xfffff2fb
     f98:	1e052e20 	cdpne	14, 0, cr2, cr5, cr0, {1}
     f9c:	333f0520 	teqcc	pc, #32, 10	@ 0x8000000
     fa0:	052e3605 	streq	r3, [lr, #-1541]!	@ 0xfffff9fb
     fa4:	2f053422 	svccs	0x00053422
     fa8:	2e41052e 	cdpcs	5, 4, cr0, cr1, cr14, {1}
        if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     fac:	052e1705 	streq	r1, [lr, #-1797]!	@ 0xfffff8fb
     fb0:	3d053428 	cfstrscc	mvf3, [r5, #-160]	@ 0xffffff60
     fb4:	2e4a054f 	cdpcs	5, 4, cr0, cr10, cr15, {2}
            xYieldPendings[ 0 ] = pdTRUE;
     fb8:	052e3405 	streq	r3, [lr, #-1029]!	@ 0xfffffbfb
     fbc:	4a052f2d 	bmi	14cc78 <_etext+0x14a7a8>
}
     fc0:	2e39053f 	mrccs	5, 1, r0, cr9, cr15, {1}
     fc4:	052f3a05 	streq	r3, [pc, #-2565]!	@ 5c7 <prvAddNewTaskToReadyList+0x11b>
     fc8:	33054329 	movwcc	r4, #21289	@ 0x5329
     fcc:	2e29052e 	cfsh64cs	mvdx0, mvdx9, #30
     fd0:	053e2d05 	ldreq	r2, [lr, #-3333]!	@ 0xfffff2fb
     fd4:	38054a17 	stmdacc	r5, {r0, r1, r2, r4, r9, fp, lr}
{
     fd8:	51290530 			@ <UNDEFINED> instruction: 0x51290530
     fdc:	05401505 	strbeq	r1, [r0, #-1285]	@ 0xfffffafb
    taskENTER_CRITICAL();
     fe0:	3305672e 	movwcc	r6, #22318	@ 0x572e
        pxTimeOut->xOverflowCount = xNumOfOverflows;
     fe4:	030e053d 	movweq	r0, #58685	@ 0xe53d
     fe8:	0c055816 	stceq	8, cr5, [r5], {22}
        pxTimeOut->xTimeOnEntering = xTickCount;
     fec:	052e1003 	streq	r1, [lr, #-3]!
     ff0:	05da2101 	ldrbeq	r2, [sl, #257]	@ 0x101
    taskEXIT_CRITICAL();
     ff4:	07054b0f 	streq	r4, [r5, -pc, lsl #22]
}
     ff8:	400d0531 	andmi	r0, sp, r1, lsr r5
     ffc:	055b1005 	ldrbeq	r1, [fp, #-5]
    1000:	0b05340d 	bleq	14e03c <_etext+0x14bb6c>
    1004:	3017052e 	andscc	r0, r7, lr, lsr #10
{
    1008:	052e0f05 	streq	r0, [lr, #-3845]!	@ 0xfffff0fb
    100c:	0c033211 	sfmeq	f3, 4, [r3], {17}
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    1010:	31320566 	teqcc	r2, r6, ror #10
    1014:	052e2905 	streq	r2, [lr, #-2309]!	@ 0xfffff6fb
    pxTimeOut->xTimeOnEntering = xTickCount;
    1018:	2d055a15 	vstrcs	s10, [r5, #-84]	@ 0xffffffac
    101c:	5a1a053d 	bpl	682518 <_etext+0x680048>
}
    1020:	0c030105 	stfeqs	f0, [r3], {5}
    1024:	0c05942e 	cfstrseq	mvf9, [r5], {46}	@ 0x2e
    1028:	2f01052f 	svccs	0x0001052f
    102c:	2f0c056a 	svccs	0x000c056a
    1030:	6a2f0105 	bvs	bc144c <_etext+0xbbef7c>
{
    1034:	052f2405 	streq	r2, [pc, #-1029]!	@ c37 <vTaskSwitchContext+0x5f>
    1038:	30864b01 	addcc	r4, r6, r1, lsl #22
    103c:	590c054f 	stmdbpl	ip, {r0, r1, r2, r3, r6, r8, sl}
    taskENTER_CRITICAL();
    1040:	00300905 	eorseq	r0, r0, r5, lsl #18
        const TickType_t xConstTickCount = xTickCount;
    1044:	06010402 	streq	r0, [r1], -r2, lsl #8
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    1048:	0402003c 	streq	r0, [r2], #-60	@ 0xffffffc4
    104c:	00208203 	eoreq	r8, r0, r3, lsl #4
    1050:	20040402 	andcs	r0, r4, r2, lsl #8
        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) )
    1054:	02000705 	andeq	r0, r0, #1310720	@ 0x140000
    1058:	20060604 	andcs	r0, r6, r4, lsl #12
    105c:	05300e05 	ldreq	r0, [r0, #-3589]!	@ 0xfffff1fb
    1060:	1605840b 	strne	r8, [r5], -fp, lsl #8
    1064:	940c053e 	strls	r0, [ip], #-1342	@ 0xfffffac2
            xReturn = pdTRUE;
    1068:	4e210105 	sufmis	f0, f1, f5
            *pxTicksToWait = ( TickType_t ) 0;
    106c:	053f0c05 	ldreq	r0, [pc, #-3077]!	@ 46f <prvInitialiseNewTask+0x8d>
    1070:	1a053f14 	bne	150cc8 <_etext+0x14e7f8>
        else if( xElapsedTime < *pxTicksToWait )
    1074:	3c070530 	cfstr32cc	mvfx0, [r7], {48}	@ 0x30
    1078:	3d301805 	ldccc	8, cr1, [r0, #-20]!	@ 0xffffffec
    107c:	031e054b 	tsteq	lr, #314572800	@ 0x12c00000
            *pxTicksToWait -= xElapsedTime;
    1080:	1c05660b 	stcne	6, cr6, [r5], {11}
    1084:	2f170520 	svccs	0x00170520
    1088:	05401205 	strbeq	r1, [r0, #-517]	@ 0xfffffdfb
            vTaskInternalSetTimeOutState( pxTimeOut );
    108c:	12054b15 	andne	r4, r5, #21504	@ 0x5400
            xReturn = pdFALSE;
    1090:	0d053d20 	stceq	13, cr3, [r5, #-128]	@ 0xffffff80
    1094:	200b054b 	andcs	r0, fp, fp, asr #10
            *pxTicksToWait = ( TickType_t ) 0;
    1098:	052f0a05 	streq	r0, [pc, #-2565]!	@ 69b <vTaskStartScheduler+0x1b>
            xReturn = pdTRUE;
    109c:	0a052e17 	beq	14c900 <_etext+0x14a430>
    taskEXIT_CRITICAL();
    10a0:	2e1c052f 	cfmul64cs	mvdx0, mvdx12, mvdx15
    return xReturn;
    10a4:	05321605 	ldreq	r1, [r2, #-1541]!	@ 0xfffff9fb
}
    10a8:	3e052f40 	cdpcc	15, 0, cr2, cr5, cr0, {2}
    10ac:	2e220520 	cfsh64cs	mvdx0, mvdx2, #16
    10b0:	052f2705 	streq	r2, [pc, #-1797]!	@ 9b3 <xTaskCatchUpTicks+0x1f>
    10b4:	24054d36 	strcs	r4, [r5], #-3382	@ 0xfffff2ca
{
    10b8:	2f2b052e 	svccs	0x002b052e
    xYieldPendings[ portGET_CORE_ID() ] = pdTRUE;
    10bc:	052e1905 	streq	r1, [lr, #-2309]!	@ 0xfffff6fb
    10c0:	05f62f01 	ldrbeq	r2, [r6, #3841]!	@ 0xf01
}
    10c4:	05055015 	streq	r5, [r5, #-21]	@ 0xffffffeb
    10c8:	0077052e 	rsbseq	r0, r7, lr, lsr #10
    10cc:	20030402 	andcs	r0, r3, r2, lsl #8
{
    10d0:	02002005 	andeq	r2, r0, #5
    10d4:	053c0104 	ldreq	r0, [ip, #-260]!	@ 0xfffffefc
        prvCheckTasksWaitingTermination();
    10d8:	04020059 	streq	r0, [r2], #-89	@ 0xffffffa7
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) configNUMBER_OF_CORES )
    10dc:	09052e01 	stmdbeq	r5, {r0, r9, sl, fp, sp}
    10e0:	053c0c03 	ldreq	r0, [ip, #-3075]!	@ 0xfffff3fd
                taskYIELD();
    10e4:	0f05301b 	svceq	0x0005301b
    10e8:	2e07052e 	cfsh32cs	mvfx0, mvfx7, #30
    10ec:	053e1305 	ldreq	r1, [lr, #-773]!	@ 0xfffffcfb
    10f0:	20052e32 	andcs	r2, r5, r2, lsr lr
        prvCheckTasksWaitingTermination();
    10f4:	3d19052e 	cfldr32cc	mvfx0, [r9, #-184]	@ 0xffffff48
    10f8:	09030905 	stmdbeq	r3, {r0, r2, r8, fp}
    10fc:	3020052e 	eorcc	r0, r0, lr, lsr #10
{
    1100:	052e0f05 	streq	r0, [lr, #-3845]!	@ 0xfffff0fb
    1104:	07052e40 	streq	r2, [r5, -r0, asr #28]
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    1108:	300d052e 	andcc	r0, sp, lr, lsr #10
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    110c:	052e4605 	streq	r4, [lr, #-1541]!	@ 0xfffff9fb
    1110:	1c052e0b 	stcne	14, cr2, [r5], {11}
    1114:	2e2c0531 	mcrcs	5, 1, r0, cr12, cr1, {1}
    1118:	052e6405 	streq	r6, [lr, #-1029]!	@ 0xfffffbfb
    111c:	30052029 	andcc	r2, r5, r9, lsr #32
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    1120:	2e68053d 	mcrcs	5, 3, r0, cr8, cr13, {1}
    1124:	40202e05 	eormi	r2, r0, r5, lsl #28
    1128:	055d3605 	ldrbeq	r3, [sp, #-1541]	@ 0xfffff9fb
    vListInitialise( &xDelayedTaskList1 );
    112c:	07052e2a 	streq	r2, [r5, -sl, lsr #28]
    1130:	4c250535 	cfstr32mi	mvfx0, [r5], #-212	@ 0xffffff2c
    vListInitialise( &xDelayedTaskList2 );
    1134:	94420105 	strbls	r0, [r2], #-261	@ 0xfffffefb
    vListInitialise( &xPendingReadyList );
    1138:	054c0c05 	strbeq	r0, [ip, #-3077]	@ 0xfffff3fb
    113c:	27052e19 	smladcs	r5, r9, lr, r2
    pxDelayedTaskList = &xDelayedTaskList1;
    1140:	3e05052e 	cfsh32cc	mvfx0, mvfx5, #30
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1144:	05301105 	ldreq	r1, [r0, #-261]!	@ 0xfffffefb
    1148:	1205400b 	andne	r4, r5, #11
}
    114c:	2418053e 	ldrcs	r0, [r8], #-1342	@ 0xfffffac2
    1150:	053e1c05 	ldreq	r1, [lr, #-3077]!	@ 0xfffff3fb
    1154:	1e052e13 	mcrne	14, 0, r2, cr5, cr3, {0}
    1158:	3f1c053e 	svccc	0x001c053e
    115c:	052e1305 	streq	r1, [lr, #-773]!	@ 0xfffffcfb
    1160:	19053e1e 	stmdbne	r5, {r1, r2, r3, r4, r9, sl, fp, ip, sp}
    1164:	031c0541 	tsteq	ip, #272629760	@ 0x10400000
    1168:	0e053c6e 	cdpeq	12, 0, cr3, cr5, cr14, {3}
{
    116c:	05581603 	ldrbeq	r1, [r8, #-1539]	@ 0xfffff9fd
}
    1170:	32053031 	andcc	r3, r5, #49	@ 0x31
    1174:	3d26053d 	cfstr32cc	mvfx0, [r6, #-244]!	@ 0xffffff0c
{
    1178:	053e0505 	ldreq	r0, [lr, #-1285]!	@ 0xfffffafb
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    117c:	35053031 	strcc	r3, [r5, #-49]	@ 0xffffffcf
    1180:	4b2f054b 	blmi	bc26b4 <_etext+0xbc01e4>
    1184:	054b3505 	strbeq	r3, [fp, #-1285]	@ 0xfffffafb
        xNextTaskUnblockTime = portMAX_DELAY;
    1188:	01054c05 	tsteq	r5, r5, lsl #24
    118c:	f209032f 	vcgt.s8	d0, d9, d31
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    1190:	052f0b05 	streq	r0, [pc, #-2821]!	@ 693 <vTaskStartScheduler+0x13>
    1194:	24053e19 	strcs	r3, [r5], #-3609	@ 0xfffff1e7
    1198:	1e053d3d 	mcrne	13, 0, r3, cr5, cr13, {1}
}
    119c:	3d01053d 	cfstr32cc	mvfx0, [r1, #-244]	@ 0xffffff0c
    11a0:	01000f02 	tsteq	r0, r2, lsl #30
    11a4:	0001f901 	andeq	pc, r1, r1, lsl #18
    11a8:	bd000300 	stclt	3, cr0, [r0, #-0]
        {
    11ac:	02000000 	andeq	r0, r0, #0
    11b0:	0d0efb01 	vstreq	d15, [lr, #-4]
            xReturn = pxCurrentTCB;
    11b4:	01010100 	mrseq	r0, (UNDEF: 17)
            return xReturn;
    11b8:	00000001 	andeq	r0, r0, r1
        }
    11bc:	01000001 	tsteq	r0, r1
    11c0:	462f2e2e 	strtmi	r2, [pc], -lr, lsr #28
    11c4:	52656572 	rsbpl	r6, r5, #478150656	@ 0x1c800000
    {
    11c8:	2d534f54 	ldclcs	15, cr4, [r3, #-336]	@ 0xfffffeb0
    11cc:	6e72654b 	cdpvs	5, 7, cr6, cr2, cr11, {2}
        TaskHandle_t xReturn = NULL;
    11d0:	702f6c65 	eorvc	r6, pc, r5, ror #24
        if( taskVALID_CORE_ID( xCoreID ) != pdFALSE )
    11d4:	6174726f 	cmnvs	r4, pc, ror #4
    11d8:	2f656c62 	svccs	0x00656c62
    11dc:	2f434347 	svccs	0x00434347
                xReturn = pxCurrentTCB;
    11e0:	5f4d5241 	svcpl	0x004d5241
    11e4:	00334d43 	eorseq	r4, r3, r3, asr #26
    }
    11e8:	7273752f 	rsbsvc	r7, r3, #197132288	@ 0xbc00000
    11ec:	62696c2f 	rsbvs	r6, r9, #12032	@ 0x2f00
    11f0:	6363672f 	cmnvs	r3, #12320768	@ 0xbc0000
    11f4:	6d72612f 	ldfvse	f6, [r2, #-188]!	@ 0xffffff44
{
    11f8:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
    11fc:	61652d65 	cmnvs	r5, r5, ror #26
    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    1200:	312f6962 			@ <UNDEFINED> instruction: 0x312f6962
    1204:	2e322e33 	mrccs	14, 1, r2, cr2, cr3, {1}
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) );
    1208:	6e692f31 	mcrvs	15, 3, r2, cr9, cr1, {1}
    120c:	64756c63 	ldrbtvs	r6, [r5], #-3171	@ 0xfffff39d
    1210:	2e2e0065 	cdpcs	0, 2, cr0, cr14, cr5, {3}
    1214:	6572462f 	ldrbvs	r4, [r2, #-1583]!	@ 0xfffff9d1
}
    1218:	4f545265 	svcmi	0x00545265
    121c:	654b2d53 	strbvs	r2, [fp, #-3411]	@ 0xfffff2ad
    1220:	6c656e72 	stclvs	14, cr6, [r5], #-456	@ 0xfffffe38
    1224:	636e692f 	cmnvs	lr, #770048	@ 0xbc000
    {
    1228:	6564756c 	strbvs	r7, [r4, #-1388]!	@ 0xfffffa94
    122c:	6f700000 	svcvs	0x00700000
    1230:	632e7472 			@ <UNDEFINED> instruction: 0x632e7472
        BaseType_t xAlreadyYielded, xShouldBlock = pdFALSE;
    1234:	00000100 	andeq	r0, r0, r0, lsl #2
        if( ( pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] == 0U ) && ( xTicksToWait > ( TickType_t ) 0 ) )
    1238:	74726f70 	ldrbtvc	r6, [r2], #-3952	@ 0xfffff090
    123c:	7263616d 	rsbvc	r6, r3, #1073741851	@ 0x4000001b
    1240:	00682e6f 	rsbeq	r2, r8, pc, ror #28
    1244:	73000001 	movwvc	r0, #1
    1248:	6e696474 	mcrvs	4, 3, r6, cr9, cr4, {3}
    124c:	00682e74 	rsbeq	r2, r8, r4, ror lr
            vTaskSuspendAll();
    1250:	70000002 	andvc	r0, r0, r2
                taskENTER_CRITICAL();
    1254:	646a6f72 	strbtvs	r6, [sl], #-3954	@ 0xfffff08e
                    if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] == 0U )
    1258:	2e736665 	cdpcs	6, 7, cr6, cr3, cr5, {3}
    125c:	00030068 	andeq	r0, r3, r8, rrx
    1260:	73617400 	cmnvc	r1, #0, 8
    1264:	00682e6b 	rsbeq	r2, r8, fp, ror #28
    1268:	00000003 	andeq	r0, r0, r3
                        pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskWAITING_NOTIFICATION;
    126c:	05000105 	streq	r0, [r0, #-261]	@ 0xfffffefb
    1270:	00225802 	eoreq	r5, r2, r2, lsl #16
    1274:	01b80300 			@ <UNDEFINED> instruction: 0x01b80300
                        xShouldBlock = pdTRUE;
    1278:	69110501 	ldmdbvs	r1, {r0, r8, sl}
                taskEXIT_CRITICAL();
    127c:	053d1305 	ldreq	r1, [sp, #-773]!	@ 0xfffffcfb
                if( xShouldBlock == pdTRUE )
    1280:	17054b11 	smladne	r5, r1, fp, r4
    1284:	2030053d 	eorscs	r0, r0, sp, lsr r5
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1288:	052e1305 	streq	r1, [lr, #-773]!	@ 0xfffffcfb
    128c:	15052f11 	strne	r2, [r5, #-3857]	@ 0xfffff0ef
            xAlreadyYielded = xTaskResumeAll();
    1290:	2013053d 	andscs	r0, r3, sp, lsr r5
            if( ( xShouldBlock == pdTRUE ) && ( xAlreadyYielded == pdFALSE ) )
    1294:	052f1205 	streq	r1, [pc, #-517]!	@ 1097 <xTaskCheckForTimeOut+0x63>
    1298:	13053d15 	movwne	r3, #23829	@ 0x5d15
    129c:	2f120520 	svccs	0x00120520
                taskYIELD_WITHIN_API();
    12a0:	053e0c05 	ldreq	r0, [lr, #-3077]!	@ 0xfffff3fb
    12a4:	05782101 	ldrbeq	r2, [r8, #-257]!	@ 0xfffffeff
    12a8:	02043d17 	andeq	r3, r4, #1472	@ 0x5c0
    12ac:	0c030505 	cfstr32eq	mvfx0, [r3], {5}
        taskENTER_CRITICAL();
    12b0:	9801052e 	stmdals	r1, {r1, r2, r3, r5, r8, sl}
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ];
    12b4:	0a050104 	beq	1416cc <_etext+0x13f1fc>
    12b8:	05207703 	streq	r7, [r0, #-1795]!	@ 0xfffff8fd
    12bc:	04020014 	streq	r0, [r2], #-20	@ 0xffffffec
    12c0:	01052001 	tsteq	r5, r1
            if( ulReturn != 0U )
    12c4:	6a3c0a03 	bvs	f03ad8 <_etext+0xf01608>
    12c8:	05130505 	ldreq	r0, [r3, #-1285]	@ 0xfffffafb
                if( xClearCountOnExit != pdFALSE )
    12cc:	080e0301 	stmdaeq	lr, {r0, r8, r9}
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] = ( uint32_t ) 0U;
    12d0:	0505242e 	streq	r2, [r5, #-1070]	@ 0xfffffbd2
    12d4:	03010513 	movweq	r0, #5395	@ 0x1513
    12d8:	0527e40d 	streq	lr, [r7, #-1037]!	@ 0xfffffbf3
    12dc:	3c0f0331 	stccc	3, cr0, [pc], {49}	@ 0x31
    12e0:	05202105 	streq	r2, [r0, #-261]!	@ 0xfffffefb
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] = ulReturn - ( uint32_t ) 1;
    12e4:	00ea0305 	rsceq	r0, sl, r5, lsl #6
    12e8:	3c18052e 	cfldr32cc	mvfx0, [r8], {46}	@ 0x2e
    12ec:	053d0505 	ldreq	r0, [sp, #-1285]!	@ 0xfffffafb
    12f0:	05053c18 	streq	r3, [r5, #-3096]	@ 0xfffff3e8
            pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskNOT_WAITING_NOTIFICATION;
    12f4:	2018053d 	andscs	r0, r8, sp, lsr r5
    12f8:	05320505 	ldreq	r0, [r2, #-1285]!	@ 0xfffffafb
    12fc:	05053117 	streq	r3, [r5, #-279]	@ 0xfffffee9
    1300:	052f363f 	streq	r3, [pc, #-1599]!	@ cc9 <vTaskPlaceOnUnorderedEventList+0x39>
        taskEXIT_CRITICAL();
    1304:	0105310c 	tsteq	r5, ip, lsl #2
    }
    1308:	4e32be21 	cdpmi	14, 3, cr11, cr2, cr1, {1}
    130c:	05050204 	streq	r0, [r5, #-516]	@ 0xfffffdfc
    1310:	3c7ead03 	ldclcc	13, cr10, [lr], #-12
    1314:	04980105 	ldreq	r0, [r8], #261	@ 0x105
    {
    1318:	03160501 	tsteq	r6, #4194304	@ 0x400000
    131c:	052001cd 	streq	r0, [r0, #-461]!	@ 0xfffffe33
    1320:	580b0301 	stmdapl	fp, {r0, r8, r9}
    1324:	3e160586 	cdpcc	5, 1, cr0, cr6, cr6, {4}
        BaseType_t xReturn, xAlreadyYielded, xShouldBlock = pdFALSE;
    1328:	055a1b05 	ldrbeq	r1, [sl, #-2821]	@ 0xfffff4fb
        if( ( pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] != taskNOTIFICATION_RECEIVED ) && ( xTicksToWait > ( TickType_t ) 0 ) )
    132c:	02042e07 	andeq	r2, r4, #7, 28	@ 0x70
    1330:	ba030505 	blt	c274c <_etext+0xc027c>
    1334:	01054a7e 	tsteq	r5, lr, ror sl
    1338:	03010440 	movweq	r0, #5184	@ 0x1440
    133c:	862001c6 	strthi	r0, [r0], -r6, asr #3
    1340:	05150505 	ldreq	r0, [r5, #-1285]	@ 0xfffffafb
            vTaskSuspendAll();
    1344:	021d0301 	andseq	r0, sp, #67108864	@ 0x4000000
                taskENTER_CRITICAL();
    1348:	04240122 	strteq	r0, [r4], #-290	@ 0xfffffede
                    if( pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] != taskNOTIFICATION_RECEIVED )
    134c:	03050502 	movweq	r0, #21762	@ 0x5502
    1350:	053c7dec 	ldreq	r7, [ip, #-3564]!	@ 0xfffff214
    1354:	01049801 	tsteq	r4, r1, lsl #16
    1358:	95030d05 	strls	r0, [r3, #-3333]	@ 0xfffff2fb
                        pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] &= ~ulBitsToClearOnEntry;
    135c:	0b052002 	bleq	14936c <_etext+0x146e9c>
    1360:	01040200 	mrseq	r0, R12_usr
    1364:	340d053c 	strcc	r0, [sp], #-1340	@ 0xfffffac4
    1368:	04202305 	strteq	r2, [r0], #-773	@ 0xfffffcfb
    136c:	03050502 	movweq	r0, #21762	@ 0x5502
    1370:	05587dff 	ldrbeq	r7, [r8, #-3583]	@ 0xfffff201
    1374:	01044001 	tsteq	r4, r1
    1378:	20028503 	andcs	r8, r2, r3, lsl #10
                        pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskWAITING_NOTIFICATION;
    137c:	7401e503 	strvc	lr, [r1], #-1283	@ 0xfffffafd
    1380:	0b030505 	bleq	c279c <_etext+0xc02cc>
    1384:	201f052e 	andscs	r0, pc, lr, lsr #10
                        xShouldBlock = pdTRUE;
    1388:	052f0505 	streq	r0, [pc, #-1285]!	@ e8b <xTaskRemoveFromEventList+0x18b>
                taskEXIT_CRITICAL();
    138c:	05052028 	streq	r2, [r5, #-40]	@ 0xffffffd8
                if( xShouldBlock == pdTRUE )
    1390:	201f0531 	andscs	r0, pc, r1, lsr r5	@ <UNPREDICTABLE>
    1394:	052f0505 	streq	r0, [pc, #-1285]!	@ e97 <vTaskRemoveFromUnorderedEventList+0x3>
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1398:	0105201f 	tsteq	r5, pc, lsl r0
    139c:	000c022f 	andeq	r0, ip, pc, lsr #4
            xAlreadyYielded = xTaskResumeAll();
    13a0:	Address 0x13a0 is out of bounds.


Disassembly of section .debug_info:

00000000 <.debug_info>:
       0:	00000022 	andeq	r0, r0, r2, lsr #32
       4:	00000002 	andeq	r0, r0, r2
       8:	01040000 	mrseq	r0, (UNDEF: 4)
       c:	00000000 	andeq	r0, r0, r0
      10:	000001d0 	ldrdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
      14:	0000021c 	andeq	r0, r0, ip, lsl r2
      18:	00000000 	andeq	r0, r0, r0
      1c:	00000007 	andeq	r0, r0, r7
      20:	00000021 	andeq	r0, r0, r1, lsr #32
      24:	02148001 	andseq	r8, r4, #1
      28:	00050000 	andeq	r0, r5, r0
      2c:	00140401 	andseq	r0, r4, r1, lsl #8
      30:	43090000 	movwmi	r0, #36864	@ 0x9000
      34:	1d000000 	stcne	0, cr0, [r0, #-0]
      38:	0000018a 	andeq	r0, r0, sl, lsl #3
      3c:	00000007 	andeq	r0, r0, r7
      40:	0000021c 	andeq	r0, r0, ip, lsl r2
      44:	000000c8 	andeq	r0, r0, r8, asr #1
      48:	00000053 	andeq	r0, r0, r3, asr r0
      4c:	6905040a 	stmdbvs	r5, {r1, r3, sl}
      50:	0b00746e 	bleq	1d210 <_etext+0x1ad40>
      54:	00000026 	andeq	r0, r0, r6, lsr #32
      58:	23070401 	movwcs	r0, #29697	@ 0x7401
      5c:	01000001 	tsteq	r0, r1
      60:	00cf0508 	sbceq	r0, pc, r8, lsl #10
      64:	08010000 	stmdaeq	r1, {}	@ <UNPREDICTABLE>
      68:	0000f704 	andeq	pc, r0, r4, lsl #14
      6c:	06010100 	streq	r0, [r1], -r0, lsl #2
      70:	0000010d 	andeq	r0, r0, sp, lsl #2
      74:	96050201 	strls	r0, [r5], -r1, lsl #4
      78:	01000000 	mrseq	r0, (UNDEF: 0)
      7c:	00d40504 	sbcseq	r0, r4, r4, lsl #10
      80:	01010000 	mrseq	r0, (UNDEF: 1)
      84:	00010b08 	andeq	r0, r1, r8, lsl #22
      88:	07020100 	streq	r0, [r2, -r0, lsl #2]
      8c:	00000153 	andeq	r0, r0, r3, asr r1
      90:	00013003 	andeq	r3, r1, r3
      94:	19340200 	ldmdbne	r4!, {r9}
      98:	00000076 	andeq	r0, r0, r6, ror r0
      9c:	1e070401 	cdpne	4, 0, cr0, cr7, cr1, {0}
      a0:	01000001 	tsteq	r0, r1
      a4:	01190708 	tsteq	r9, r8, lsl #14
      a8:	34030000 	strcc	r0, [r3], #-0
      ac:	03000000 	movweq	r0, #0
      b0:	00901124 	addseq	r1, r0, r4, lsr #2
      b4:	95040000 	strls	r0, [r4, #-0]
      b8:	0c000000 	stceq	0, cr0, [r0], {-0}
      bc:	000000a0 	andeq	r0, r0, r0, lsr #1
      c0:	0000a002 	andeq	sl, r0, r2
      c4:	040d0000 	streq	r0, [sp], #-0
      c8:	0000a005 	andeq	sl, r0, r5
      cc:	017e0300 	cmneq	lr, r0, lsl #6
      d0:	3a040000 	bcc	1000d8 <_etext+0xfdc08>
      d4:	00006a1a 	andeq	r6, r0, sl, lsl sl
      d8:	00a70500 	adceq	r0, r7, r0, lsl #10
      dc:	73030000 	movwvc	r0, #12288	@ 0x3000
      e0:	04000001 	streq	r0, [r0], #-1
      e4:	00551a3b 	subseq	r1, r5, fp, lsr sl
      e8:	72030000 	andvc	r0, r3, #0
      ec:	04000001 	streq	r0, [r0], #-1
      f0:	00761a3c 	rsbseq	r1, r6, ip, lsr sl
      f4:	b4030000 	strlt	r0, [r3], #-0
      f8:	05000000 	streq	r0, [r0, #-0]
      fc:	00dc2e5f 	sbcseq	r2, ip, pc, asr lr
     100:	e1040000 	mrs	r0, (UNDEF: 4)
     104:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
     108:	000000e3 	andeq	r0, r0, r3, ror #1
     10c:	0000f704 	andeq	pc, r0, r4, lsl #14
     110:	00e60500 	rsceq	r0, r6, r0, lsl #10
     114:	01010000 	mrseq	r0, (UNDEF: 1)
     118:	00011408 	andeq	r1, r1, r8, lsl #8
     11c:	00f00500 	rscseq	r0, r0, r0, lsl #10
     120:	2d060000 	stccs	0, cr0, [r6, #-0]
     124:	17000000 	strne	r0, [r0, -r0]
     128:	0000006a 	andeq	r0, r0, sl, rrx
     12c:	0000c106 	andeq	ip, r0, r6, lsl #2
     130:	006a1800 	rsbeq	r1, sl, r0, lsl #16
     134:	03060000 	movweq	r0, #24576	@ 0x6000
     138:	19000001 	stmdbne	r0, {r0}
     13c:	0000006a 	andeq	r0, r0, sl, rrx
     140:	00019206 	andeq	r9, r1, r6, lsl #4
     144:	006a1a00 	rsbeq	r1, sl, r0, lsl #20
     148:	dd060000 	stcle	0, cr0, [r6, #-0]
     14c:	1b000000 	blne	154 <_stext+0x154>
     150:	0000006a 	andeq	r0, r0, sl, rrx
     154:	0000a00f 	andeq	sl, r0, pc
     158:	0ce50600 	stcleq	6, cr0, [r5]
     15c:	000000b8 	strheq	r0, [r0], -r8
     160:	00016610 	andeq	r6, r1, r0, lsl r6
     164:	01810500 	orreq	r0, r1, r0, lsl #10
     168:	0000b810 	andeq	fp, r0, r0, lsl r8
     16c:	00016a00 	andeq	r6, r1, r0, lsl #20
     170:	00840200 	addeq	r0, r4, r0, lsl #4
     174:	eb020000 	bl	8017c <_etext+0x7dcac>
     178:	02000000 	andeq	r0, r0, #0
     17c:	000000b3 	strheq	r0, [r0], -r3
     180:	0000a202 	andeq	sl, r0, r2, lsl #4
     184:	00c40200 	sbceq	r0, r4, r0, lsl #4
     188:	6f020000 	svcvs	0x00020000
     18c:	00000001 	andeq	r0, r0, r1
     190:	0000d004 	andeq	sp, r0, r4
     194:	016a0500 	cmneq	sl, r0, lsl #10
     198:	4d110000 	ldcmi	0, cr0, [r1, #-0]
     19c:	01000001 	tsteq	r0, r1
     1a0:	02440622 	subeq	r0, r4, #35651584	@ 0x2200000
     1a4:	00a00000 	adceq	r0, r0, r0
     1a8:	9c010000 	stcls	0, cr0, [r1], {-0}
     1ac:	000001b6 			@ <UNDEFINED> instruction: 0x000001b6
     1b0:	00075a12 	andeq	r5, r7, r2, lsl sl
     1b4:	10230100 	eorne	r0, r3, r0, lsl #2
     1b8:	000000b8 	strheq	r0, [r0], -r8
     1bc:	076c9102 	strbeq	r9, [ip, -r2, lsl #2]!
     1c0:	00637273 	rsbeq	r7, r3, r3, ror r2
     1c4:	01b60f25 			@ <UNDEFINED> instruction: 0x01b60f25
     1c8:	91020000 	mrsls	r0, (UNDEF: 2)
     1cc:	73640774 	cmnvc	r4, #116, 14	@ 0x1d00000
    ldr r0, =_sidata            /* Address of init values in flash */
     1d0:	0f260074 	svceq	0x00260074
    ldr r2, =_edata             /* End of .data in RAM */
     1d4:	000001b6 			@ <UNDEFINED> instruction: 0x000001b6
    bcs zero_bss
     1d8:	00709102 	rsbseq	r9, r0, r2, lsl #2
    ldr r3, [r0], #4
     1dc:	00006a04 	andeq	r6, r0, r4, lsl #20
    str r3, [r1], #4
     1e0:	00c81300 	sbceq	r1, r8, r0, lsl #6
    ldr r0, =_sbss              /* Start of .bss */
     1e4:	0d010000 	stceq	0, cr0, [r1, #-0]
    cmp r0, r1
     1e8:	0002300d 	andeq	r3, r2, sp
    movs r2, #0
     1ec:	00001400 	andeq	r1, r0, r0, lsl #8
    str r2, [r0], #4
     1f0:	eb9c0100 	bl	fe7005f8 <__StackTop+0xde6fe5f8>
    bl start                    /* Call main/start function */
     1f4:	08000001 	stmdaeq	r0, {r0}
    b hang                      /* If it returns, hang forever */
     1f8:	00000140 	andeq	r0, r0, r0, asr #2
    b .
     1fc:	0000a00d 	andeq	sl, r0, sp
    b .
     200:	6c910200 	lfmvs	f0, 4, [r1], {0}
    b .
     204:	0e006207 	cdpeq	2, 0, cr6, cr0, cr7, {0}
    ldr r0, =_sidata            /* Address of init values in flash */
     208:	00002d12 	andeq	r2, r0, r2, lsl sp
    ldr r1, =_sdata             /* Start of .data in RAM */
     20c:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
    ldr r2, =_edata             /* End of .data in RAM */
     210:	01391400 	teqeq	r9, r0, lsl #8
    ldr r0, =_sbss              /* Start of .bss */
     214:	05010000 	streq	r0, [r1, #-0]
    ldr r1, =_ebss              /* End of .bss */
     218:	00021c0d 	andeq	r1, r2, sp, lsl #24
static void vTask1(void *pvParameters){
     21c:	00001400 	andeq	r1, r0, r0, lsl #8
     220:	089c0100 	ldmeq	ip, {r8}
    volatile int a =0;
     224:	00000140 	andeq	r0, r0, r0, asr #2
        a++;
     228:	0000a005 	andeq	sl, r0, r5
     22c:	6c910200 	lfmvs	f0, 4, [r1], {0}
static void vTask2(void *pvParameters){
     230:	06006107 	streq	r6, [r0], -r7, lsl #2
     234:	00002d12 	andeq	r2, r0, r2, lsl sp
    volatile int b =0;
     238:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
        b++;
     23c:	00cf0000 	sbceq	r0, pc, r0
     240:	00050000 	andeq	r0, r5, r0
void start(){
     244:	01470401 	cmpeq	r7, r1, lsl #8
     248:	43040000 	movwmi	r0, #16384	@ 0x4000
    uint32_t *src = &_sidata;//Source flash
     24c:	1d000000 	stcne	0, cr0, [r0, #-0]
    uint32_t *dst = &_sdata;//Destination RAM
     250:	0000019f 	muleq	r0, pc, r1	@ <UNPREDICTABLE>
        *dst++ = *src++; //copy word and increment pointer
     254:	00000007 	andeq	r0, r0, r7
     258:	000002e4 	andeq	r0, r0, r4, ror #5
     25c:	0000003e 	andeq	r0, r0, lr, lsr r0
     260:	00000188 	andeq	r0, r0, r8, lsl #3
    while(dst < &_edata){
     264:	69050405 	stmdbvs	r5, {r0, r2, sl}
     268:	0600746e 	streq	r7, [r0], -lr, ror #8
    dst = &_sbss;
     26c:	00000198 	muleq	r0, r8, r1
    while(dst < &_ebss){
     270:	3917d602 	ldmdbcc	r7, {r1, r9, sl, ip, lr, pc}
        *dst++ = 0; //zero word and increment pointer
     274:	01000000 	mrseq	r0, (UNDEF: 0)
     278:	01230704 			@ <UNDEFINED> instruction: 0x01230704
    while(dst < &_ebss){
     27c:	08010000 	stmdaeq	r1, {}	@ <UNPREDICTABLE>
     280:	0000cf05 	andeq	ip, r0, r5, lsl #30
    xReturn = xTaskCreate(vTask1,"T1",configMINIMAL_STACK_SIZE,NULL,1,NULL);  // 256*4 = 1k stack size
     284:	04080100 	streq	r0, [r8], #-256	@ 0xffffff00
     288:	000000f7 	strdeq	r0, [r0], -r7
     28c:	0001c007 	andeq	ip, r1, r7
     290:	07020100 	streq	r0, [r2, -r0, lsl #2]
     294:	000000c3 	andeq	r0, r0, r3, asr #1
     298:	000002e4 	andeq	r0, r0, r4, ror #5
    xReturn = xTaskCreate(vTask2,"T2",configMINIMAL_STACK_SIZE,NULL,1,NULL);
     29c:	0000003e 	andeq	r0, r0, lr, lsr r0
     2a0:	00c39c01 	sbceq	r9, r3, r1, lsl #24
     2a4:	af020000 	svcge	0x00020000
     2a8:	14000001 	strne	r0, [r0], #-1
     2ac:	000000c3 	andeq	r0, r0, r3, asr #1
     2b0:	08649102 	stmdaeq	r4!, {r1, r8, ip, pc}^
    xPortStartScheduler();
     2b4:	02010063 	andeq	r0, r1, #99	@ 0x63
    return;
     2b8:	0000261e 	andeq	r2, r0, lr, lsl r6
     2bc:	60910200 	addsvs	r0, r1, r0, lsl #4
     2c0:	0001ba02 	andeq	fp, r1, r2, lsl #20
     2c4:	002d2800 	eoreq	r2, sp, r0, lsl #16
     2c8:	91020000 	mrsls	r0, (UNDEF: 2)
     2cc:	7470035c 	ldrbtvc	r0, [r0], #-860	@ 0xfffffca4
     2d0:	14050072 	strne	r0, [r5], #-114	@ 0xffffff8e
     2d4:	000000c5 	andeq	r0, r0, r5, asr #1
     2d8:	09709102 	ldmdbeq	r0!, {r1, r8, ip, pc}^
     2dc:	000001b4 			@ <UNDEFINED> instruction: 0x000001b4
     2e0:	cb130901 	blgt	4c26ec <_etext+0x4c021c>
void *memset(void *dest, int c, size_t count) {
     2e4:	02000000 	andeq	r0, r0, #0
     2e8:	f80a6f91 			@ <UNDEFINED> instruction: 0xf80a6f91
     2ec:	1e000002 	cdpne	0, 0, cr0, cr0, cr2, {0}
    unsigned char *ptr = (unsigned char *)dest;
     2f0:	03000000 	movweq	r0, #0
    unsigned char value = (unsigned char)c;
     2f4:	110c0069 	tstne	ip, r9, rrx
    for (size_t i = 0; i < count; i++) {
     2f8:	0000002d 	andeq	r0, r0, sp, lsr #32
     2fc:	00749102 	rsbseq	r9, r4, r2, lsl #2
        ptr[i] = value;
     300:	0c040b00 			@ <UNDEFINED> instruction: 0x0c040b00
     304:	0000cb04 	andeq	ip, r0, r4, lsl #22
    for (size_t i = 0; i < count; i++) {
     308:	08010100 	stmdaeq	r1, {r8}
     30c:	0000010b 	andeq	r0, r0, fp, lsl #2
     310:	0015f600 	andseq	pc, r5, r0, lsl #12
     314:	01000500 	tsteq	r0, r0, lsl #10
     318:	0001fd04 	andeq	pc, r1, r4, lsl #26
     31c:	00432400 	subeq	r2, r3, r0, lsl #8
     320:	0b1d0000 	bleq	740328 <_etext+0x73de58>
    {
     324:	07000008 	streq	r0, [r0, -r8]
     328:	24000000 	strcs	r0, [r0], #-0
     32c:	ec000003 	stc	0, cr0, [r0], {3}
     330:	23000018 	movwcs	r0, #24
            pxStack = pvPortMallocStack( ( ( ( size_t ) uxStackDepth ) * sizeof( StackType_t ) ) );
     334:	07000002 	streq	r0, [r0, -r2]
     338:	00000198 	muleq	r0, r8, r1
     33c:	3217d603 	andscc	sp, r7, #3145728	@ 0x300000
            if( pxStack != NULL )
     340:	0a000000 	beq	348 <prvCreateTask+0x24>
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
     344:	01230704 			@ <UNDEFINED> instruction: 0x01230704
     348:	04250000 	strteq	r0, [r5], #-0
                if( pxNewTCB != NULL )
     34c:	746e6905 	strbtvc	r6, [lr], #-2309	@ 0xfffff6fb
     350:	05080a00 	streq	r0, [r8, #-2560]	@ 0xfffff600
                    ( void ) memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
     354:	000000cf 	andeq	r0, r0, pc, asr #1
     358:	f704080a 			@ <UNDEFINED> instruction: 0xf704080a
                    pxNewTCB->pxStack = pxStack;
     35c:	0a000000 	beq	364 <prvCreateTask+0x40>
     360:	010d0601 	tsteq	sp, r1, lsl #12
                    vPortFreeStack( pxStack );
     364:	010a0000 	mrseq	r0, (UNDEF: 10)
     368:	00010b08 	andeq	r0, r1, r8, lsl #22
                pxNewTCB = NULL;
     36c:	05020a00 	streq	r0, [r2, #-2560]	@ 0xfffff600
        if( pxNewTCB != NULL )
     370:	00000096 	muleq	r0, r6, r0
     374:	5307020a 	movwpl	r0, #29194	@ 0x720a
            prvInitialiseNewTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
     378:	0a000001 	beq	384 <prvCreateTask+0x60>
     37c:	00d40504 	sbcseq	r0, r4, r4, lsl #10
     380:	040a0000 	streq	r0, [sl], #-0
     384:	00011e07 	andeq	r1, r1, r7, lsl #28
     388:	07080a00 	streq	r0, [r8, -r0, lsl #20]
     38c:	00000119 	andeq	r0, r0, r9, lsl r1
     390:	7f050426 	svcvc	0x00050426
    }
     394:	04000000 	streq	r0, [r0], #-0
     398:	0000008b 	andeq	r0, r0, fp, lsl #1
    {
     39c:	1408010a 	strne	r0, [r8], #-266	@ 0xfffffef6
     3a0:	05000001 	streq	r0, [r0, #-1]
     3a4:	0000008b 	andeq	r0, r0, fp, lsl #1
     3a8:	00009204 	andeq	r9, r0, r4, lsl #4
        pxNewTCB = prvCreateTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask );
     3ac:	00970500 	addseq	r0, r7, r0, lsl #10
     3b0:	ce070000 	cdpgt	0, 0, cr0, cr7, cr0, {0}
     3b4:	04000006 	streq	r0, [r0], #-6
     3b8:	0055182e 	subseq	r1, r5, lr, lsr #16
     3bc:	a10b0000 	mrsge	r0, (UNDEF: 11)
        if( pxNewTCB != NULL )
     3c0:	07000000 	streq	r0, [r0, -r0]
     3c4:	00000130 	andeq	r0, r0, r0, lsr r1
            prvAddNewTaskToReadyList( pxNewTCB );
     3c8:	71193404 	tstvc	r9, r4, lsl #8
            xReturn = pdPASS;
     3cc:	0b000000 	bleq	3d4 <xTaskCreate+0x38>
     3d0:	000000b2 	strheq	r0, [r0], -r2
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     3d4:	00003407 	andeq	r3, r0, r7, lsl #8
        return xReturn;
     3d8:	11240500 			@ <UNDEFINED> instruction: 0x11240500
    }
     3dc:	000000cf 	andeq	r0, r0, pc, asr #1
     3e0:	0000d404 	andeq	sp, r0, r4, lsl #8
{
     3e4:	00df2700 	sbcseq	r2, pc, r0, lsl #14
     3e8:	7f080000 	svcvc	0x00080000
     3ec:	00000000 	andeq	r0, r0, r0
        pxTopOfStack = &( pxNewTCB->pxStack[ uxStackDepth - ( configSTACK_DEPTH_TYPE ) 1 ] );
     3f0:	00017e07 	andeq	r7, r1, r7, lsl #28
     3f4:	1a3a0200 	bne	e80bfc <_etext+0xe7e72c>
     3f8:	000000b2 	strheq	r0, [r0], -r2
     3fc:	0000df0b 	andeq	sp, r0, fp, lsl #30
     400:	00df0500 	sbcseq	r0, pc, r0, lsl #10
        pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     404:	73070000 	movwvc	r0, #28672	@ 0x7000
     408:	02000001 	andeq	r0, r0, #1
    if( pcName != NULL )
     40c:	006a1a3b 	rsbeq	r1, sl, fp, lsr sl
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     410:	f50b0000 			@ <UNDEFINED> instruction: 0xf50b0000
     414:	05000000 	streq	r0, [r0, #-0]
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     418:	000000f5 	strdeq	r0, [r0], -r5
     41c:	00017207 	andeq	r7, r1, r7, lsl #4
     420:	1a3c0200 	bne	f00c28 <_etext+0xefe758>
     424:	00000071 	andeq	r0, r0, r1, ror r0
     428:	00010b0b 	andeq	r0, r1, fp, lsl #22
            if( pcName[ x ] == ( char ) 0x00 )
     42c:	01170500 	tsteq	r7, r0, lsl #10
     430:	b1070000 	mrslt	r0, (UNDEF: 7)
     434:	02000008 	andeq	r0, r0, #8
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     438:	00b21a42 	adcseq	r1, r2, r2, asr #20
     43c:	210b0000 	mrscs	r0, (UNDEF: 11)
     440:	05000001 	streq	r0, [r0, #-1]
                break;
     444:	00000121 	andeq	r0, r0, r1, lsr #2
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1U ] = '\0';
     448:	0002cf12 	andeq	ip, r2, r2, lsl pc
     44c:	90061400 	andls	r1, r6, r0, lsl #8
    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
     450:	00018608 	andeq	r8, r1, r8, lsl #12
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
     454:	09640600 	stmdbeq	r4!, {r9, sl}^
    pxNewTCB->uxPriority = uxPriority;
     458:	93060000 	movwls	r0, #24576	@ 0x6000
     45c:	00012124 	andeq	r2, r1, r4, lsr #2
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     460:	dd060000 	stcle	0, cr0, [r6, #-0]
     464:	06000007 	streq	r0, [r0], -r7
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     468:	01862d94 			@ <UNDEFINED> instruction: 0x01862d94
     46c:	06040000 	streq	r0, [r4], -r0
     470:	000004fb 	strdeq	r0, [r0], -fp
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     474:	862d9506 	strthi	r9, [sp], -r6, lsl #10
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority );
     478:	08000001 	stmdaeq	r0, {r0}
     47c:	000aeb06 	andeq	lr, sl, r6, lsl #22
     480:	0c960600 	ldceq	6, cr0, [r6], {0}
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     484:	0000007f 	andeq	r0, r0, pc, ror r0
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     488:	090b060c 	stmdbeq	fp, {r2, r3, r9, sl}
     48c:	97060000 	strls	r0, [r6, -r0]
     490:	0001c028 	andeq	ip, r1, r8, lsr #32
     494:	04001000 	streq	r1, [r0], #-0
    if( pxCreatedTask != NULL )
     498:	00000137 	andeq	r0, r0, r7, lsr r1
     49c:	00058012 	andeq	r8, r5, r2, lsl r0
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     4a0:	ac061400 	cfstrsge	mvf1, [r6], {-0}
}
     4a4:	0001c010 	andeq	ip, r1, r0, lsl r0
     4a8:	01da0600 	bicseq	r0, sl, r0, lsl #12
    {
     4ac:	af060000 	svcge	0x00060000
     4b0:	00010b25 	andeq	r0, r1, r5, lsr #22
        taskENTER_CRITICAL();
     4b4:	a1060000 	mrsge	r0, (UNDEF: 6)
            uxCurrentNumberOfTasks = ( UBaseType_t ) ( uxCurrentNumberOfTasks + 1U );
     4b8:	06000002 	streq	r0, [r0], -r2
     4bc:	021226b0 	andseq	r2, r2, #176, 12	@ 0xb000000
     4c0:	06040000 	streq	r0, [r4], -r0
            if( pxCurrentTCB == NULL )
     4c4:	00000685 	andeq	r0, r0, r5, lsl #13
     4c8:	0614b106 	ldreq	fp, [r4], -r6, lsl #2
                pxCurrentTCB = pxNewTCB;
     4cc:	08000002 	stmdaeq	r0, {r1}
                if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     4d0:	018b0400 	orreq	r0, fp, r0, lsl #8
     4d4:	aa070000 	bge	1c04dc <_etext+0x1be00c>
                    prvInitialiseTaskLists();
     4d8:	06000006 	streq	r0, [r0], -r6
     4dc:	01371b9a 	teqeq	r7, sl	@ <illegal shifter operand>
                if( xSchedulerRunning == pdFALSE )
     4e0:	65120000 	ldrvs	r0, [r2, #-0]
     4e4:	0c000005 	stceq	0, cr0, [r0], {5}
                    if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     4e8:	060c9d06 	streq	r9, [ip], -r6, lsl #26
     4ec:	06000002 	streq	r0, [r0], -r2
     4f0:	00000964 	andeq	r0, r0, r4, ror #18
                        pxCurrentTCB = pxNewTCB;
     4f4:	2128a006 			@ <UNDEFINED> instruction: 0x2128a006
     4f8:	00000001 	andeq	r0, r0, r1
            uxTaskNumber++;
     4fc:	0007dd06 	andeq	sp, r7, r6, lsl #26
     500:	31a10600 			@ <UNDEFINED> instruction: 0x31a10600
            prvAddTaskToReadyList( pxNewTCB );
     504:	00000186 	andeq	r0, r0, r6, lsl #3
     508:	04fb0604 	ldrbteq	r0, [fp], #1540	@ 0x604
     50c:	a2060000 	andge	r0, r6, #0
     510:	00018631 	andeq	r8, r1, r1, lsr r6
     514:	07000800 	streq	r0, [r0, -r0, lsl #16]
     518:	000006a6 	andeq	r0, r0, r6, lsr #13
     51c:	d124a406 			@ <UNDEFINED> instruction: 0xd124a406
     520:	04000001 	streq	r0, [r0], #-1
     524:	000001c5 	andeq	r0, r0, r5, asr #3
     528:	00021205 	andeq	r1, r2, r5, lsl #4
     52c:	089d0700 	ldmeq	sp, {r8, r9, sl}
     530:	b3060000 	movwlt	r0, #24576	@ 0x6000
     534:	00018b03 	andeq	r8, r1, r3, lsl #22
     538:	021c0500 	andseq	r0, ip, #0, 10
     53c:	b4070000 	strlt	r0, [r7], #-0
     540:	07000000 	streq	r0, [r0, -r0]
     544:	02392e5f 	eorseq	r2, r9, #1520	@ 0x5f0
     548:	3e040000 	cdpcc	0, 0, cr0, cr4, cr0, {0}
     54c:	28000002 	stmdacs	r0, {r1}
     550:	000000e3 	andeq	r0, r0, r3, ror #1
     554:	0176014c 	cmneq	r6, ip, asr #2
     558:	0002b510 	andeq	fp, r2, r0, lsl r5
     55c:	0bfd0d00 	bleq	fff43964 <__StackTop+0xdff41964>
     560:	01780000 	cmneq	r8, r0
     564:	00036d1c 	andeq	r6, r3, ip, lsl sp
     568:	b60d0000 	strlt	r0, [sp], -r0
     56c:	8200000b 	andhi	r0, r0, #11
     570:	01c51001 	biceq	r1, r5, r1
     574:	0d040000 	stceq	0, cr0, [r4, #-0]
     578:	00000b1e 	andeq	r0, r0, lr, lsl fp
     57c:	c5100183 	ldrgt	r0, [r0, #-387]	@ 0xfffffe7d
     580:	18000001 	stmdane	r0, {r0}
     584:	0001fc0d 	andeq	pc, r1, sp, lsl #24
        taskEXIT_CRITICAL();
     588:	11018400 	tstne	r1, r0, lsl #8
        if( xSchedulerRunning != pdFALSE )
     58c:	0000010b 	andeq	r0, r0, fp, lsl #2
     590:	09a00d2c 	stmibeq	r0!, {r2, r3, r5, r8, sl, fp}
            taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxNewTCB );
     594:	01850000 	orreq	r0, r5, r0
     598:	00036813 	andeq	r6, r3, r3, lsl r8
     59c:	cf0d3000 	svcgt	0x000d3000
     5a0:	8a000001 	bhi	5ac <prvAddNewTaskToReadyList+0x100>
     5a4:	03720a01 	cmneq	r2, #4096	@ 0x1000
     5a8:	0d340000 	ldceq	0, cr0, [r4, #-0]
     5ac:	000005f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
    }
     5b0:	921b01b3 	andsls	r0, fp, #-1073741780	@ 0xc000002c
     5b4:	44000003 	strmi	r0, [r0], #-3
     5b8:	0003fe0d 	andeq	pc, r3, sp, lsl #28
     5bc:	1a01b400 	bne	6d5c4 <_etext+0x6b0f4>
     5c0:	000003a7 	andeq	r0, r0, r7, lsr #7
     5c4:	07290048 	streq	r0, [r9, -r8, asr #32]!
     5c8:	00005501 	andeq	r5, r0, r1, lsl #10
     5cc:	01750700 	cmneq	r5, r0, lsl #14
     5d0:	000002e2 	andeq	r0, r0, r2, ror #5
{
     5d4:	00025813 	andeq	r5, r2, r3, lsl r8
     5d8:	d0130000 	andsle	r0, r3, r0
    BaseType_t xReturn = pdPASS;
     5dc:	01000008 	tsteq	r0, r8
    char cIdleName[ configMAX_TASK_NAME_LEN ] = { 0 };
     5e0:	00055a13 	andeq	r5, r5, r3, lsl sl
     5e4:	7a130200 	bvc	4c0dec <_etext+0x4be91c>
     5e8:	03000004 	movweq	r0, #4
    TaskFunction_t pxIdleTaskFunction = NULL;
     5ec:	00063b13 	andeq	r3, r6, r3, lsl fp
    for( xIdleTaskNameIndex = 0U; xIdleTaskNameIndex < ( configMAX_TASK_NAME_LEN - taskRESERVED_TASK_NAME_LENGTH ); xIdleTaskNameIndex++ )
     5f0:	07000400 	streq	r0, [r0, -r0, lsl #8]
        cIdleName[ xIdleTaskNameIndex ] = configIDLE_TASK_NAME[ xIdleTaskNameIndex ];
     5f4:	0000054c 	andeq	r0, r0, ip, asr #10
     5f8:	b5037b07 	strlt	r7, [r3, #-2823]	@ 0xfffff4f9
     5fc:	12000002 	andne	r0, r0, #2
     600:	000002a9 	andeq	r0, r0, r9, lsr #5
     604:	10800708 	addne	r0, r0, r8, lsl #14
        if( cIdleName[ xIdleTaskNameIndex ] == ( char ) 0x00 )
     608:	00000316 	andeq	r0, r0, r6, lsl r3
     60c:	00038006 	andeq	r8, r3, r6
     610:	10820700 	addne	r0, r2, r0, lsl #14
    for( xIdleTaskNameIndex = 0U; xIdleTaskNameIndex < ( configMAX_TASK_NAME_LEN - taskRESERVED_TASK_NAME_LENGTH ); xIdleTaskNameIndex++ )
     614:	000000f5 	strdeq	r0, [r0], -r5
     618:	07cd0600 	strbeq	r0, [sp, r0, lsl #12]
     61c:	83070000 	movwhi	r0, #28672	@ 0x7000
            break;
     620:	00012110 	andeq	r2, r1, r0, lsl r1
    cIdleName[ xIdleTaskNameIndex ] = '\0';
     624:	07000400 	streq	r0, [r0, -r0, lsl #8]
     628:	00000838 	andeq	r0, r0, r8, lsr r8
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
     62c:	ee038407 	cdp	4, 0, cr8, cr3, cr7, {0}
     630:	12000002 	andne	r0, r0, #2
            pxIdleTaskFunction = &prvIdleTask;
     634:	000008d9 	ldrdeq	r0, [r0], -r9
            xReturn = xTaskCreate( pxIdleTaskFunction,
     638:	1089070c 	addne	r0, r9, ip, lsl #14
     63c:	00000357 	andeq	r0, r0, r7, asr r3
     640:	000a6206 	andeq	r6, sl, r6, lsl #4
     644:	0c8b0700 	stceq	7, cr0, [fp], {0}
     648:	0000007f 	andeq	r0, r0, pc, ror r0
     64c:	07a10600 	streq	r0, [r1, r0, lsl #12]!
     650:	8c070000 	stchi	0, cr0, [r7], {-0}
        if( xReturn != pdPASS )
     654:	0000b20e 	andeq	fp, r0, lr, lsl #4
     658:	c4060400 	strgt	r0, [r6], #-1024	@ 0xfffffc00
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
     65c:	07000003 	streq	r0, [r0, -r3]
     660:	00b20e8d 	adcseq	r0, r2, sp, lsl #29
     664:	00080000 	andeq	r0, r8, r0
            break;
     668:	00070c07 	andeq	r0, r7, r7, lsl #24
}
     66c:	038e0700 	orreq	r0, lr, #0, 14
     670:	00000322 	andeq	r0, r0, r2, lsr #6
     674:	00035705 	andeq	r5, r3, r5, lsl #14
     678:	00df0400 	sbcseq	r0, pc, r0, lsl #8
     67c:	eb040000 	bl	100684 <_etext+0xfe1b4>
{
     680:	10000000 	andne	r0, r0, r0
     684:	0000008b 	andeq	r0, r0, fp, lsl #1
    xReturn = prvCreateIdleTasks();
     688:	00000382 	andeq	r0, r0, r2, lsl #7
    if( xReturn == pdPASS )
     68c:	00003211 	andeq	r3, r0, r1, lsl r2
     690:	10000f00 	andne	r0, r0, r0, lsl #30
    __asm volatile
     694:	000000be 	strheq	r0, [r0], -lr
     698:	00000392 	muleq	r0, r2, r3
     69c:	00003211 	andeq	r3, r0, r1, lsl r2
     6a0:	0b000000 	bleq	6a8 <vTaskStartScheduler+0x28>
}
     6a4:	00000382 	andeq	r0, r0, r2, lsl #7
        xNextTaskUnblockTime = portMAX_DELAY;
     6a8:	0000ad10 	andeq	sl, r0, r0, lsl sp
     6ac:	0003a700 	andeq	sl, r3, r0, lsl #14
        xSchedulerRunning = pdTRUE;
     6b0:	00321100 	eorseq	r1, r2, r0, lsl #2
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
     6b4:	00000000 	andeq	r0, r0, r0
     6b8:	0003970b 	andeq	r9, r3, fp, lsl #14
        ( void ) xPortStartScheduler();
     6bc:	03e01d00 	mvneq	r1, #0, 26
    ( void ) uxTopUsedPriority;
     6c0:	01c40000 	biceq	r0, r4, r0
}
     6c4:	00023e03 	andeq	r3, r2, r3, lsl #28
     6c8:	0ae51d00 	beq	ff947ad0 <__StackTop+0xdf945ad0>
     6cc:	01c80000 	biceq	r0, r8, r0
     6d0:	0003ac10 	andeq	sl, r3, r0, lsl ip
     6d4:	09172a00 	ldmdbeq	r7, {r9, fp, sp}
     6d8:	ce010000 	cdpgt	0, 0, cr0, cr1, cr0, {0}
{
     6dc:	03dc3701 	bicseq	r3, ip, #262144	@ 0x40000
     6e0:	03050000 	movweq	r0, #20480	@ 0x5000
    __asm volatile
     6e4:	20000004 	andcs	r0, r0, r4
     6e8:	0003b804 	andeq	fp, r3, r4, lsl #16
     6ec:	03d70b00 	bicseq	r0, r7, #0, 22
     6f0:	1c100000 	ldcne	0, cr0, [r0], {-0}
}
     6f4:	f1000002 	cps	#2
    xSchedulerRunning = pdFALSE;
     6f8:	11000003 	tstne	r0, r3
    vPortEndScheduler();
     6fc:	00000032 	andeq	r0, r0, r2, lsr r0
}
     700:	da010004 	ble	40718 <_etext+0x3e248>
     704:	db000002 	blle	714 <vTaskSuspendAll+0x8>
     708:	03e11f01 	mvneq	r1, #1, 30
{
     70c:	03050000 	movweq	r0, #20480	@ 0x5000
        uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended + 1U );
     710:	20000008 	andcs	r0, r0, r8
     714:	00035c01 	andeq	r5, r3, r1, lsl #24
     718:	1f01dc00 	svcne	0x0001dc00
}
     71c:	0000021c 	andeq	r0, r0, ip, lsl r2
     720:	006c0305 	rsbeq	r0, ip, r5, lsl #6
     724:	6e012000 	cdpvs	0, 0, cr2, cr1, cr0, {0}
{
     728:	dd000003 	stcle	0, cr0, [r0, #-12]
     72c:	021c1f01 	andseq	r1, ip, #1, 30
    TCB_t * pxTCB = NULL;
     730:	03050000 	movweq	r0, #20480	@ 0x5000
    BaseType_t xAlreadyYielded = pdFALSE;
     734:	20000080 	andcs	r0, r0, r0, lsl #1
        taskENTER_CRITICAL();
     738:	00097e01 	andeq	r7, r9, r1, lsl #28
            const BaseType_t xCoreID = ( BaseType_t ) portGET_CORE_ID();
     73c:	2a01de00 	bcs	77f44 <_etext+0x75a74>
            uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended - 1U );
     740:	0000043e 	andeq	r0, r0, lr, lsr r4
     744:	00940305 	addseq	r0, r4, r5, lsl #6
            if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
     748:	1c042000 	stcne	0, cr2, [r4], {-0}
     74c:	0b000002 	bleq	75c <xTaskResumeAll+0x34>
     750:	00000439 	andeq	r0, r0, r9, lsr r4
                if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     754:	00043905 	andeq	r3, r4, r5, lsl #18
     758:	05af0100 	streq	r0, [pc, #256]!	@ 860 <xTaskResumeAll+0x138>
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     75c:	01df0000 	bicseq	r0, pc, r0
                        pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     760:	00043e2a 	andeq	r3, r4, sl, lsr #28
     764:	98030500 	stmdals	r3, {r8, sl}
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
     768:	01200000 			@ <UNDEFINED> instruction: 0x01200000
     76c:	000004d2 	ldrdeq	r0, [r0], -r2
     770:	1c1f01e0 	ldfnes	f0, [pc], {224}	@ 0xe0
     774:	05000002 	streq	r0, [r0, #-2]
     778:	00009c03 	andeq	r9, r0, r3, lsl #24
     77c:	0b930120 	bleq	fe4c0c04 <__StackTop+0xde4bec04>
     780:	01f60000 	mvnseq	r0, r0
     784:	0001172d 	andeq	r1, r1, sp, lsr #14
     788:	b0030500 	andlt	r0, r3, r0, lsl #10
     78c:	01200000 			@ <UNDEFINED> instruction: 0x01200000
     790:	00000575 	andeq	r0, r0, r5, ror r5
     794:	2d2c01f7 	stfcss	f0, [ip, #-988]!	@ 0xfffffc24
     798:	05000001 	streq	r0, [r0, #-1]
     79c:	0000b403 	andeq	fp, r0, r3, lsl #8
     7a0:	02620120 	rsbeq	r0, r2, #32, 2
                        listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
     7a4:	01f80000 	mvnseq	r0, r0
     7a8:	0001172d 	andeq	r1, r1, sp, lsr #14
     7ac:	b8030500 	stmdalt	r3, {r8, sl}
     7b0:	01200000 			@ <UNDEFINED> instruction: 0x01200000
     7b4:	0000028f 	andeq	r0, r0, pc, lsl #5
     7b8:	012c01f9 	strdeq	r0, [ip, -r9]!
     7bc:	05000001 	streq	r0, [r0, #-1]
     7c0:	0000bc03 	andeq	fp, r0, r3, lsl #24
     7c4:	0b2d0120 	bleq	b40c4c <_etext+0xb3e77c>
     7c8:	01fa0000 	mvnseq	r0, r0
     7cc:	00012d2c 	andeq	r2, r1, ip, lsr #26
     7d0:	c0030500 	andgt	r0, r3, r0, lsl #10
     7d4:	10200000 	eorne	r0, r0, r0
     7d8:	00000101 	andeq	r0, r0, r1, lsl #2
     7dc:	000004d6 	ldrdeq	r0, [r0], -r6
     7e0:	00003211 	andeq	r3, r0, r1, lsl r2
                        prvAddTaskToReadyList( pxTCB );
     7e4:	0b000000 	bleq	7ec <xTaskResumeAll+0xc4>
     7e8:	000004c6 	andeq	r0, r0, r6, asr #9
     7ec:	00033101 	andeq	r3, r3, r1, lsl #2
     7f0:	2c01fb00 			@ <UNDEFINED> instruction: 0x2c01fb00
     7f4:	000004d6 	ldrdeq	r0, [r0], -r6
     7f8:	00c40305 	sbceq	r0, r4, r5, lsl #6
     7fc:	fb012000 	blx	48806 <_etext+0x46336>
     800:	fc000008 	stc2	0, cr0, [r0], {8}
     804:	01012c01 	tsteq	r1, r1, lsl #24
     808:	03050000 	movweq	r0, #20480	@ 0x5000
     80c:	200000c8 	andcs	r0, r0, r8, asr #1
     810:	00085f01 	andeq	r5, r8, r1, lsl #30
     814:	2401fd00 	strcs	pc, [r1], #-3328	@ 0xfffff300
     818:	0000010b 	andeq	r0, r0, fp, lsl #2
     81c:	00cc0305 	sbceq	r0, ip, r5, lsl #6
     820:	1b012000 	blne	48828 <_etext+0x46358>
     824:	fe000007 	cdp2	0, 0, cr0, cr0, cr7, {0}
     828:	012d2c01 			@ <UNDEFINED> instruction: 0x012d2c01
     82c:	03050000 	movweq	r0, #20480	@ 0x5000
     830:	200000d0 	ldrdcs	r0, [r0], -r0	@ <UNPREDICTABLE>
     834:	00022d10 	andeq	r2, r2, r0, lsl sp
     838:	00053300 	andeq	r3, r5, r0, lsl #6
     83c:	00321100 	eorseq	r1, r2, r0, lsl #2
     840:	00000000 	andeq	r0, r0, r0
     844:	0005df01 	andeq	sp, r5, r1, lsl #30
     848:	2501ff00 	strcs	pc, [r1, #-3840]	@ 0xfffff100
     84c:	00000523 	andeq	r0, r0, r3, lsr #10
     850:	00d40305 	sbcseq	r0, r4, r5, lsl #6
     854:	1d012000 	stcne	0, cr2, [r1, #-0]
     858:	04000005 	streq	r0, [r0], #-5
     85c:	011c2302 	tsteq	ip, r2, lsl #6
     860:	03050000 	movweq	r0, #20480	@ 0x5000
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     864:	000024c0 	andeq	r2, r0, r0, asr #9
     868:	000be801 	andeq	lr, fp, r1, lsl #16
     86c:	2d021200 	sfmcs	f1, 4, [r2, #-0]
     870:	00000117 	andeq	r0, r0, r7, lsl r1
                                xYieldPendings[ xCoreID ] = pdTRUE;
     874:	00d80305 	sbcseq	r0, r8, r5, lsl #6
     878:	0c2b2000 	stceq	0, cr2, [fp], #-0
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     87c:	06000004 	streq	r0, [r0], -r4
     880:	0b0d01f7 	bleq	341064 <_etext+0x33eb94>
     884:	80000001 	andhi	r0, r0, r1
                    if( pxTCB != NULL )
     888:	08000005 	stmdaeq	r0, {r0, r2}
                        prvResetNextTaskUnblockTime();
     88c:	00000217 	andeq	r0, r0, r7, lsl r2
                        TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
     890:	0aad1900 	beq	feb46c98 <__StackTop+0xdeb44c98>
     894:	01b90000 			@ <UNDEFINED> instruction: 0x01b90000
                        if( xPendedCounts > ( TickType_t ) 0U )
     898:	00000591 	muleq	r0, r1, r5
                                if( xTaskIncrementTick() != pdFALSE )
     89c:	00044308 	andeq	r4, r4, r8, lsl #6
     8a0:	cb190000 	blgt	6408a8 <_etext+0x63e3d8>
     8a4:	d100000a 	tstle	r0, sl
                                    xYieldPendings[ xCoreID ] = pdTRUE;
     8a8:	0005a701 	andeq	sl, r5, r1, lsl #14
     8ac:	04430800 	strbeq	r0, [r3], #-2048	@ 0xfffff800
                                --xPendedCounts;
     8b0:	17080000 	strne	r0, [r8, -r0]
     8b4:	00000002 	andeq	r0, r0, r2
                            } while( xPendedCounts > ( TickType_t ) 0U );
     8b8:	000c171a 	andeq	r1, ip, sl, lsl r7
                            xPendedTicks = 0;
     8bc:	06ec0800 	strbteq	r0, [ip], r0, lsl #16
     8c0:	0000a02c 	andeq	sl, r0, ip, lsr #32
                    if( xYieldPendings[ xCoreID ] != pdFALSE )
     8c4:	0ce50800 	stcleq	8, cr0, [r5]
     8c8:	000000f5 	strdeq	r0, [r0], -r5
     8cc:	0001ea1a 	andeq	lr, r1, sl, lsl sl
                            xAlreadyYielded = pdTRUE;
     8d0:	0d740200 	lfmeq	f0, 2, [r4, #-0]
                            taskYIELD_TASK_CORE_IF_USING_PREEMPTION( pxCurrentTCB );
     8d4:	00039f1a 	andeq	r9, r3, sl, lsl pc
     8d8:	0d730200 	lfmeq	f0, 2, [r3, #-0]
     8dc:	0007431b 	andeq	r4, r7, fp, lsl r3
     8e0:	178d0800 	strne	r0, [sp, r0, lsl #16]
     8e4:	00000368 	andeq	r0, r0, r8, ror #6
        taskEXIT_CRITICAL();
     8e8:	000005eb 	andeq	r0, r0, fp, ror #11
}
     8ec:	00036808 	andeq	r6, r3, r8, lsl #16
     8f0:	00c30800 	sbceq	r0, r3, r0, lsl #16
     8f4:	7f080000 	svcvc	0x00080000
     8f8:	00000000 	andeq	r0, r0, r0
     8fc:	00093b19 	andeq	r3, r9, r9, lsl fp
     900:	fc01c400 	stc2	4, cr12, [r1], {-0}
     904:	08000005 	stmdaeq	r0, {r0, r2}
     908:	00000217 	andeq	r0, r0, r7, lsl r2
     90c:	09c52d00 	stmibeq	r5, {r8, sl, fp, sp}^
     910:	c0080000 	andgt	r0, r8, r0
     914:	00060e06 	andeq	r0, r6, r6, lsl #28
{
     918:	007f0800 	rsbseq	r0, pc, r0, lsl #16
     91c:	1b000000 	blne	924 <xTaskGetTickCount+0xc>
        xTicks = xTickCount;
     920:	000001c0 	andeq	r0, r0, r0, asr #3
    return xTicks;
     924:	7f092109 	svcvc	0x00092109
}
     928:	2e000000 	cdpcs	0, 0, cr0, cr0, cr0, {0}
     92c:	08000006 	stmdaeq	r0, {r1, r2}
     930:	0000007f 	andeq	r0, r0, pc, ror r0
{
     934:	00003908 	andeq	r3, r0, r8, lsl #18
     938:	00260800 	eoreq	r0, r6, r0, lsl #16
    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
     93c:	1b000000 	blne	944 <xTaskGetTickCountFromISR+0x10>
        xReturn = xTickCount;
     940:	00000c0a 	andeq	r0, r0, sl, lsl #24
    return xReturn;
     944:	7f08bd08 	svcvc	0x0008bd08
}
     948:	44000000 	strmi	r0, [r0], #-0
     94c:	08000006 	stmdaeq	r0, {r1, r2}
     950:	00000026 	andeq	r0, r0, r6, lsr #32
{
     954:	05061400 	streq	r1, [r6, #-1024]	@ 0xfffffc00
    return uxCurrentNumberOfTasks;
     958:	226a0000 	rsbcs	r0, sl, #0
}
     95c:	001b7c06 	andseq	r7, fp, r6, lsl #24
     960:	00009400 	andeq	r9, r0, r0, lsl #8
     964:	6a9c0100 	bvs	fe700d6c <__StackTop+0xde6fed6c>
{
     968:	01000006 	tsteq	r0, r6
     96c:	000001c7 	andeq	r0, r0, r7, asr #3
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     970:	f510226c 			@ <UNDEFINED> instruction: 0xf510226c
     974:	02000000 	andeq	r0, r0, #0
     978:	15007491 	strne	r7, [r0, #-1169]	@ 0xfffffb6f
     97c:	00000b53 	andeq	r0, r0, r3, asr fp
    return &( pxTCB->pcTaskName[ 0 ] );
     980:	d00d2183 	andle	r2, sp, r3, lsl #3
}
     984:	ac00001a 	stcge	0, cr0, [r0], {26}
     988:	01000000 	mrseq	r0, (UNDEF: 0)
     98c:	0006db9c 	muleq	r6, ip, fp
     990:	0abe0200 	beq	fef81198 <__StackTop+0xdef7f198>
{
     994:	21830000 	orrcs	r0, r3, r0
     998:	00012138 	andeq	r2, r1, r8, lsr r1
    vTaskSuspendAll();
     99c:	64910200 	ldrvs	r0, [r1], #512	@ 0x200
    taskENTER_CRITICAL();
     9a0:	000a4c02 	andeq	r4, sl, r2, lsl #24
        xPendedTicks += xTicksToCatchUp;
     9a4:	3e218400 	cdpcc	4, 2, cr8, cr1, cr0, {0}
     9a8:	00000106 	andeq	r0, r0, r6, lsl #2
     9ac:	01609102 	cmneq	r0, r2, lsl #2
    taskEXIT_CRITICAL();
     9b0:	00000baa 	andeq	r0, r0, sl, lsr #23
    xYieldOccurred = xTaskResumeAll();
     9b4:	21102186 	tstcs	r0, r6, lsl #3
     9b8:	02000001 	andeq	r0, r0, #1
}
     9bc:	98016891 	stmdals	r1, {r0, r4, r7, fp, sp, lr}
     9c0:	87000005 	strhi	r0, [r0, -r5]
     9c4:	01321621 	teqeq	r2, r1, lsr #12
{
     9c8:	91020000 	mrsls	r0, (UNDEF: 2)
     9cc:	02750174 	rsbseq	r0, r5, #116, 2
    BaseType_t xSwitchRequired = pdFALSE;
     9d0:	21880000 	orrcs	r0, r8, r0
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
     9d4:	00044314 	andeq	r4, r4, r4, lsl r3
     9d8:	70910200 	addsvc	r0, r1, r0, lsl #4
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     9dc:	000c6e01 	andeq	r6, ip, r1, lsl #28
     9e0:	14218900 	strtne	r8, [r1], #-2304	@ 0xfffff700
        xTickCount = xConstTickCount;
     9e4:	00000443 	andeq	r0, r0, r3, asr #8
     9e8:	006c9102 	rsbeq	r9, ip, r2, lsl #2
        if( xConstTickCount == ( TickType_t ) 0U )
     9ec:	00076b0c 	andeq	r6, r7, ip, lsl #22
            taskSWITCH_DELAYED_LISTS();
     9f0:	0e20bc00 	cdpeq	12, 2, cr11, cr0, cr0, {0}
     9f4:	000000b2 	strheq	r0, [r0], -r2
     9f8:	00001a70 	andeq	r1, r0, r0, ror sl
     9fc:	00000060 	andeq	r0, r0, r0, rrx
     a00:	07419c01 	strbeq	r9, [r1, -r1, lsl #24]
     a04:	ca020000 	bgt	80a0c <_etext+0x7e53c>
     a08:	bc000008 	stclt	0, cr0, [r0], {8}
     a0c:	022d3a20 	eoreq	r3, sp, #32, 20	@ 0x20000
     a10:	91020000 	mrsls	r0, (UNDEF: 2)
        if( xConstTickCount >= xNextTaskUnblockTime )
     a14:	03d1026c 	bicseq	r0, r1, #108, 4	@ 0xc0000006
     a18:	20bd0000 	adcscs	r0, sp, r0
     a1c:	00010b39 	andeq	r0, r1, r9, lsr fp
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     a20:	68910200 	ldmvs	r1, {r9}
     a24:	0002b302 	andeq	fp, r2, r2, lsl #6
                    xNextTaskUnblockTime = portMAX_DELAY;
     a28:	3620be00 	strtcc	fp, [r0], -r0, lsl #28
     a2c:	000000b2 	strheq	r0, [r0], -r2
                    break;
     a30:	01649102 	cmneq	r4, r2, lsl #2
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     a34:	00000bc5 	andeq	r0, r0, r5, asr #23
     a38:	d71120c0 	ldrle	r2, [r1, -r0, asr #1]
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     a3c:	02000003 	andeq	r0, r0, #3
     a40:	62017491 	andvs	r7, r1, #-1862270976	@ 0x91000000
                    if( xConstTickCount < xItemValue )
     a44:	c1000007 	tstgt	r0, r7
     a48:	00b21220 	adcseq	r1, r2, r0, lsr #4
                        xNextTaskUnblockTime = xItemValue;
     a4c:	91020000 	mrsls	r0, (UNDEF: 2)
                        break;
     a50:	cb0c0070 	blgt	300c18 <_etext+0x2fe748>
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
     a54:	9500000b 	strls	r0, [r0, #-11]
     a58:	00f51020 	rscseq	r1, r5, r0, lsr #32
     a5c:	1a180000 	bne	600a64 <_etext+0x5fe594>
     a60:	00580000 	subseq	r0, r8, r0
     a64:	9c010000 	stcls	0, cr0, [r1], {-0}
     a68:	00000798 	muleq	r0, r8, r7
     a6c:	0008ca02 	andeq	ip, r8, r2, lsl #20
     a70:	3b209500 	blcc	825e78 <_etext+0x8239a8>
     a74:	0000022d 	andeq	r0, r0, sp, lsr #4
     a78:	026c9102 	rsbeq	r9, ip, #-2147483648	@ 0x80000000
     a7c:	000003d1 	ldrdeq	r0, [r0], -r1
     a80:	0b3a2096 	bleq	e88ce0 <_etext+0xe86810>
     a84:	02000001 	andeq	r0, r0, #1
     a88:	c5016891 	strgt	r6, [r1, #-2193]	@ 0xfffff76f
     a8c:	9800000b 	stmdals	r0, {r0, r1, r3}
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     a90:	03d71120 	bicseq	r1, r7, #32, 2
     a94:	91020000 	mrsls	r0, (UNDEF: 2)
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
     a98:	075a0170 			@ <UNDEFINED> instruction: 0x075a0170
     a9c:	20990000 	addscs	r0, r9, r0
     aa0:	0000f514 	andeq	pc, r0, r4, lsl r5	@ <UNPREDICTABLE>
     aa4:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
     aa8:	0a701400 	beq	1c05ab0 <_etext+0x1c035e0>
     aac:	20110000 	andscs	r0, r1, r0
     ab0:	00185c0a 	andseq	r5, r8, sl, lsl #24
     ab4:	0001bc00 	andeq	fp, r1, r0, lsl #24
     ab8:	9d9c0100 	ldflss	f0, [ip]
     abc:	02000008 	andeq	r0, r0, #8
     ac0:	000008bc 			@ <UNDEFINED> instruction: 0x000008bc
     ac4:	2d362011 	ldccs	0, cr2, [r6, #-68]!	@ 0xffffffbc
     ac8:	02000002 	andeq	r0, r0, #2
     acc:	30024c91 	mulcc	r2, r1, ip
     ad0:	1200000c 	andne	r0, r0, #12
     ad4:	010b3520 	tsteq	fp, r0, lsr #10
                    prvAddTaskToReadyList( pxTCB );
     ad8:	91020000 	mrsls	r0, (UNDEF: 2)
     adc:	023e0248 	eorseq	r0, lr, #72, 4	@ 0x80000004
     ae0:	20130000 	andscs	r0, r3, r0
     ae4:	00089d36 	andeq	r9, r8, r6, lsr sp
     ae8:	44910200 	ldrmi	r0, [r1], #512	@ 0x200
     aec:	000bc501 	andeq	ip, fp, r1, lsl #10
     af0:	11201500 			@ <UNDEFINED> instruction: 0x11201500
     af4:	000003d7 	ldrdeq	r0, [r0], -r7
     af8:	01749102 	cmneq	r4, r2, lsl #2
     afc:	000002ec 	andeq	r0, r0, ip, ror #5
     b00:	a1112016 	tstge	r1, r6, lsl r0
     b04:	02000000 	andeq	r0, r0, #0
     b08:	e7016f91 			@ <UNDEFINED> instruction: 0xe7016f91
     b0c:	17000003 	strne	r0, [r0, -r3]
     b10:	010b1520 	tsteq	fp, r0, lsr #10
     b14:	91020000 	mrsls	r0, (UNDEF: 2)
     b18:	18ce0370 	stmiane	lr, {r4, r5, r6, r8, r9}^
     b1c:	003e0000 	eorseq	r0, lr, r0
     b20:	08250000 	stmdaeq	r5!, {}	@ <UNPREDICTABLE>
     b24:	29010000 	stmdbcs	r1, {}	@ <UNPREDICTABLE>
     b28:	4900000c 	stmdbmi	r0, {r2, r3}
     b2c:	04431520 	strbeq	r1, [r3], #-1312	@ 0xfffffae0
     b30:	91020000 	mrsls	r0, (UNDEF: 2)
     b34:	1e030064 	cdpne	0, 0, cr0, cr3, cr4, {3}
     b38:	70000019 	andvc	r0, r0, r9, lsl r0
     b3c:	42000000 	andmi	r0, r0, #0
     b40:	01000008 	tsteq	r0, r8
     b44:	000002a1 	andeq	r0, r0, r1, lsr #5
     b48:	1715204a 	ldrne	r2, [r5, -sl, asr #32]
     b4c:	02000002 	andeq	r0, r0, #2
     b50:	03006091 	movweq	r6, #145	@ 0x91
     b54:	00001990 	muleq	r0, r0, r9
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     b58:	00000038 	andeq	r0, r0, r8, lsr r0
     b5c:	0000085f 	andeq	r0, r0, pc, asr r8
     b60:	0002a101 	andeq	sl, r2, r1, lsl #2
     b64:	15206000 	strne	r6, [r0, #-0]!
                                xSwitchRequired = pdTRUE;
     b68:	00000217 	andeq	r0, r0, r7, lsl r2
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     b6c:	00689102 	rsbeq	r9, r8, r2, lsl #2
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > 1U )
     b70:	0015971e 	andseq	r9, r5, lr, lsl r7
     b74:	00186c00 	andseq	r6, r8, r0, lsl #24
     b78:	00001a00 	andeq	r1, r0, r0, lsl #20
     b7c:	83203500 	nophi	{0}	@ <UNPREDICTABLE>
     b80:	0f000008 	svceq	0x00000008
     b84:	000015a8 	andeq	r1, r0, r8, lsr #11
                    xSwitchRequired = pdTRUE;
     b88:	0f5c9102 	svceq	0x005c9102
                if( xYieldPendings[ 0 ] != pdFALSE )
     b8c:	000015b3 			@ <UNDEFINED> instruction: 0x000015b3
     b90:	00589102 	subseq	r9, r8, r2, lsl #2
                    xSwitchRequired = pdTRUE;
     b94:	00158116 	andseq	r8, r5, r6, lsl r1
        xPendedTicks += 1U;
     b98:	0019ec00 	andseq	lr, r9, r0, lsl #24
     b9c:	00000800 	andeq	r0, r0, r0, lsl #16
     ba0:	09208b00 	stmdbeq	r0!, {r8, r9, fp, pc}
}
     ba4:	00158b1c 	andseq	r8, r5, ip, lsl fp
     ba8:	54910200 	ldrpl	r0, [r1], #512	@ 0x200
     bac:	f5040000 			@ <UNDEFINED> instruction: 0xf5040000
     bb0:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
     bb4:	00000317 	andeq	r0, r0, r7, lsl r3
     bb8:	f5101f5b 			@ <UNDEFINED> instruction: 0xf5101f5b
     bbc:	10000000 	andne	r0, r0, r0
     bc0:	4c000016 	stcmi	0, cr0, [r0], {22}
     bc4:	01000002 	tsteq	r0, r2
     bc8:	0009e79c 	muleq	r9, ip, r7
     bcc:	08bc0200 	ldmeq	ip!, {r9}
     bd0:	1f5b0000 	svcne	0x005b0000
     bd4:	00022d38 	andeq	r2, r2, r8, lsr sp
    {
     bd8:	4c910200 	lfmmi	f0, 4, [r1], {0}
     bdc:	000c3002 	andeq	r3, ip, r2
        if( uxSchedulerSuspended != ( UBaseType_t ) 0U )
     be0:	371f5c00 	ldrcc	r5, [pc, -r0, lsl #24]
     be4:	0000010b 	andeq	r0, r0, fp, lsl #2
            xYieldPendings[ 0 ] = pdTRUE;
     be8:	02489102 	subeq	r9, r8, #-2147483648	@ 0x80000000
    }
     bec:	000009a8 	andeq	r0, r0, r8, lsr #19
            xYieldPendings[ 0 ] = pdFALSE;
     bf0:	b2341f5d 	eorslt	r1, r4, #372	@ 0x174
            taskSELECT_HIGHEST_PRIORITY_TASK();
     bf4:	02000000 	andeq	r0, r0, #0
     bf8:	6c024491 	cfstrsvs	mvf4, [r2], {145}	@ 0x91
        __asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
     bfc:	5e000008 	cdppl	0, 0, cr0, cr0, cr8, {0}
     c00:	02e2391f 	rsceq	r3, r2, #507904	@ 0x7c000
     c04:	91020000 	mrsls	r0, (UNDEF: 2)
     c08:	07e40243 	strbeq	r0, [r4, r3, asr #4]!
     c0c:	1f5f0000 	svcne	0x005f0000
     c10:	0009e736 	andeq	lr, r9, r6, lsr r7
     c14:	00910200 	addseq	r0, r1, r0, lsl #4
     c18:	00023e02 	andeq	r3, r2, r2, lsl #28
     c1c:	381f6000 	ldmdacc	pc, {sp, lr}	@ <UNPREDICTABLE>
     c20:	0000089d 	muleq	r0, sp, r8
     c24:	01049102 	tsteq	r4, r2, lsl #2
     c28:	00000bc5 	andeq	r0, r0, r5, asr #23
     c2c:	d7111f62 	ldrle	r1, [r1, -r2, ror #30]
     c30:	02000003 	andeq	r0, r0, #3
     c34:	ec017091 	stc	0, cr7, [r1], {145}	@ 0x91
     c38:	63000002 	movwvs	r0, #2
     c3c:	00a1111f 	adceq	r1, r1, pc, lsl r1
     c40:	91020000 	mrsls	r0, (UNDEF: 2)
            portTASK_SWITCH_HOOK( pxCurrentTCB );
     c44:	075a016b 	ldrbeq	r0, [sl, -fp, ror #2]
    }
     c48:	1f640000 	svcne	0x00640000
     c4c:	0000f514 	andeq	pc, r0, r4, lsl r5	@ <UNPREDICTABLE>
     c50:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
     c54:	0003e701 	andeq	lr, r3, r1, lsl #14
     c58:	151f6500 	ldrne	r6, [pc, #-1280]	@ 760 <xTaskResumeAll+0x38>
     c5c:	0000010b 	andeq	r0, r0, fp, lsl #2
     c60:	036c9102 	cmneq	ip, #-2147483648	@ 0x80000000
{
     c64:	00001710 	andeq	r1, r0, r0, lsl r7
     c68:	0000003e 	andeq	r0, r0, lr, lsr r0
     c6c:	0000096f 	andeq	r0, r0, pc, ror #18
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     c70:	000c2901 	andeq	r2, ip, r1, lsl #18
     c74:	151fc300 	ldrne	ip, [pc, #-768]	@ 97c <pcTaskGetName+0x14>
     c78:	00000443 	andeq	r0, r0, r3, asr #8
    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     c7c:	00609102 	rsbeq	r9, r0, r2, lsl #2
     c80:	00176003 	andseq	r6, r7, r3
}
     c84:	00007000 	andeq	r7, r0, r0
     c88:	00098c00 	andeq	r8, r9, r0, lsl #24
     c8c:	02a10100 	adceq	r0, r1, #0, 2
{
     c90:	1fc40000 	svcne	0x00c40000
     c94:	00021715 	andeq	r1, r2, r5, lsl r7
     c98:	5c910200 	lfmpl	f0, 4, [r1], {0}
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     c9c:	17d20300 	ldrbne	r0, [r2, r0, lsl #6]
     ca0:	00380000 	eorseq	r0, r8, r0
     ca4:	09a90000 	stmibeq	r9!, {}	@ <UNPREDICTABLE>
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     ca8:	a1010000 	mrsge	r0, (UNDEF: 1)
     cac:	da000002 	ble	cbc <vTaskPlaceOnUnorderedEventList+0x2c>
     cb0:	0217151f 	andseq	r1, r7, #130023424	@ 0x7c00000
     cb4:	91020000 	mrsls	r0, (UNDEF: 2)
     cb8:	971e0064 	ldrls	r0, [lr, -r4, rrx]
     cbc:	26000015 			@ <UNDEFINED> instruction: 0x26000015
     cc0:	1a000016 	bne	d20 <xTaskRemoveFromEventList+0x20>
     cc4:	83000000 	movwhi	r0, #0
     cc8:	0009cd1f 	andeq	ip, r9, pc, lsl sp
     ccc:	15a80f00 	strne	r0, [r8, #3840]!	@ 0xf00
     cd0:	91020000 	mrsls	r0, (UNDEF: 2)
     cd4:	15b30f58 	ldrne	r0, [r3, #3928]!	@ 0xf58
     cd8:	91020000 	mrsls	r0, (UNDEF: 2)
     cdc:	81160054 	tsthi	r6, r4, asr r0
     ce0:	2e000015 	mcrcs	0, 0, r0, cr0, cr5, {0}
     ce4:	08000018 	stmdaeq	r0, {r3, r4}
     ce8:	05000000 	streq	r0, [r0, #-0]
    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     cec:	8b1c0920 	blhi	703174 <_etext+0x700ca4>
     cf0:	02000015 	andeq	r0, r0, #21
}
     cf4:	00005091 	muleq	r0, r1, r0
     cf8:	0000b204 	andeq	fp, r0, r4, lsl #4
     cfc:	042b0c00 	strteq	r0, [fp], #-3072	@ 0xfffff400
{
     d00:	1ee30000 	cdpne	0, 14, cr0, cr3, cr0, {0}
     d04:	0000f510 	andeq	pc, r0, r0, lsl r5	@ <UNPREDICTABLE>
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     d08:	00143c00 	andseq	r3, r4, r0, lsl #24
     d0c:	0001d400 	andeq	sp, r1, r0, lsl #8
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
     d10:	b59c0100 	ldrlt	r0, [ip, #256]	@ 0x100
     d14:	0200000a 	andeq	r0, r0, #10
     d18:	000008bc 			@ <UNDEFINED> instruction: 0x000008bc
     d1c:	2d311ee3 	ldccs	14, cr1, [r1, #-908]!	@ 0xfffffc74
     d20:	02000002 	andeq	r0, r0, #2
     d24:	30025c91 	mulcc	r2, r1, ip
     d28:	e400000c 	str	r0, [r0], #-12
     d2c:	010b301e 	tsteq	fp, lr, lsl r0
     d30:	91020000 	mrsls	r0, (UNDEF: 2)
     d34:	09a80258 	stmibeq	r8!, {r3, r4, r6, r9}
     d38:	1ee50000 	cdpne	0, 14, cr0, cr5, cr0, {0}
     d3c:	0000b22d 	andeq	fp, r0, sp, lsr #4
     d40:	54910200 	ldrpl	r0, [r1], #512	@ 0x200
     d44:	00086c02 	andeq	r6, r8, r2, lsl #24
     d48:	321ee600 	andscc	lr, lr, #0, 12
     d4c:	000002e2 	andeq	r0, r0, r2, ror #5
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
     d50:	02539102 	subseq	r9, r3, #-2147483648	@ 0x80000000
     d54:	000007e4 	andeq	r0, r0, r4, ror #15
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
     d58:	e72f1ee7 	str	r1, [pc, -r7, ror #29]!
     d5c:	02000009 	andeq	r0, r0, #9
     d60:	c5010091 	strgt	r0, [r1, #-145]	@ 0xffffff6f
     d64:	e900000b 	stmdb	r0, {r0, r1, r3}
     d68:	03d7111e 	bicseq	r1, r7, #-2147483641	@ 0x80000007
     d6c:	91020000 	mrsls	r0, (UNDEF: 2)
     d70:	075a0170 			@ <UNDEFINED> instruction: 0x075a0170
     d74:	1eea0000 	cdpne	0, 14, cr0, cr10, cr0, {0}
     d78:	0000f514 	andeq	pc, r0, r4, lsl r5	@ <UNPREDICTABLE>
     d7c:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
     d80:	0002ec01 	andeq	lr, r2, r1, lsl #24
     d84:	111eeb00 	tstne	lr, r0, lsl #22
     d88:	000000a1 	andeq	r0, r0, r1, lsr #1
     d8c:	036f9102 	cmneq	pc, #-2147483648	@ 0x80000000
     d90:	00001512 	andeq	r1, r0, r2, lsl r5
        prvAddTaskToReadyList( pxUnblockedTCB );
     d94:	0000003e 	andeq	r0, r0, lr, lsr r0
     d98:	00000a9b 	muleq	r0, fp, sl
     d9c:	000c2901 	andeq	r2, ip, r1, lsl #18
     da0:	111f3000 	tstne	pc, r0
     da4:	00000443 	andeq	r0, r0, r3, asr #8
     da8:	00689102 	rsbeq	r9, r8, r2, lsl #2
     dac:	00156209 	andseq	r6, r5, r9, lsl #4
     db0:	00007000 	andeq	r7, r0, r0
     db4:	02a10100 	adceq	r0, r1, #0, 2
     db8:	1f310000 	svcne	0x00310000
     dbc:	00021711 	andeq	r1, r2, r1, lsl r7
     dc0:	64910200 	ldrvs	r0, [r1], #512	@ 0x200
     dc4:	620c0000 	andvs	r0, ip, #0
     dc8:	71000006 	tstvc	r0, r6
     dcc:	00f5101e 	rscseq	r1, r5, lr, lsl r0
     dd0:	13180000 	tstne	r8, #0
     dd4:	01240000 			@ <UNDEFINED> instruction: 0x01240000
     dd8:	9c010000 	stcls	0, cr0, [r1], {-0}
     ddc:	00000b48 	andeq	r0, r0, r8, asr #22
     de0:	000c8402 	andeq	r8, ip, r2, lsl #8
     de4:	341e7100 	ldrcc	r7, [lr], #-256	@ 0xffffff00
     de8:	0000010b 	andeq	r0, r0, fp, lsl #2
     dec:	02649102 	rsbeq	r9, r4, #-2147483648	@ 0x80000000
     df0:	000004aa 	andeq	r0, r0, sl, lsr #9
     df4:	b2311e72 	eorslt	r1, r1, #1824	@ 0x720
     df8:	02000000 	andeq	r0, r0, #0
     dfc:	13026091 	movwne	r6, #8337	@ 0x2091
     e00:	73000002 	movwvc	r0, #2
     e04:	00b2311e 	adcseq	r3, r2, lr, lsl r1
     e08:	91020000 	mrsls	r0, (UNDEF: 2)
     e0c:	09eb025c 	stmibeq	fp!, {r2, r3, r4, r6, r9}^
     e10:	1e740000 	cdpne	0, 7, cr0, cr4, cr0, {0}
     e14:	0009e733 	andeq	lr, r9, r3, lsr r7
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     e18:	58910200 	ldmpl	r1, {r9}
     e1c:	000abe02 	andeq	fp, sl, r2, lsl #28
     e20:	331e7500 	tstcc	lr, #0, 10
     e24:	00000121 	andeq	r0, r0, r1, lsr #2
     e28:	01009102 	tsteq	r0, r2, lsl #2
     e2c:	0000075a 	andeq	r0, r0, sl, asr r7
     e30:	f5141e77 			@ <UNDEFINED> instruction: 0xf5141e77
     e34:	02000000 	andeq	r0, r0, #0
     e38:	f3017491 	vqshl.u8	d7, d1, d17
     e3c:	7700000a 	strvc	r0, [r0, -sl]
     e40:	00f51d1e 	rscseq	r1, r5, lr, lsl sp
     e44:	91020000 	mrsls	r0, (UNDEF: 2)
     e48:	0924016c 	stmdbeq	r4!, {r2, r3, r5, r6, r8}
     e4c:	1e770000 	cdpne	0, 7, cr0, cr7, cr0, {0}
        if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     e50:	0000f52e 	andeq	pc, r0, lr, lsr #10
     e54:	70910200 	addsvc	r0, r1, r0, lsl #4
     e58:	068e0c00 	streq	r0, [lr], r0, lsl #24
     e5c:	1e0b0000 	cdpne	0, 0, cr0, cr11, cr0, {0}
            xReturn = pdTRUE;
     e60:	0000b20e 	andeq	fp, r0, lr, lsl #4
            xYieldPendings[ 0 ] = pdTRUE;
     e64:	00122800 	andseq	r2, r2, r0, lsl #16
     e68:	0000f000 	andeq	pc, r0, r0
            xReturn = pdFALSE;
     e6c:	bd9c0100 	ldflts	f0, [ip]
}
     e70:	0200000b 	andeq	r0, r0, #11
     e74:	00000c84 	andeq	r0, r0, r4, lsl #25
     e78:	0b331e0b 	bleq	cc86ac <_etext+0xcc61dc>
     e7c:	02000001 	andeq	r0, r0, #1
     e80:	4d026491 	cfstrsmi	mvf6, [r2, #-580]	@ 0xfffffdbc
     e84:	0c000004 	stceq	0, cr0, [r0], {4}
     e88:	00f5321e 	rscseq	r3, r5, lr, lsl r2
     e8c:	91020000 	mrsls	r0, (UNDEF: 2)
     e90:	0abe0260 	beq	fef81818 <__StackTop+0xdef7f818>
{
     e94:	1e0d0000 	cdpne	0, 0, cr0, cr13, cr0, {0}
     e98:	00012132 	andeq	r2, r1, r2, lsr r1
     e9c:	5c910200 	lfmpl	f0, 4, [r1], {0}
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     ea0:	00076201 	andeq	r6, r7, r1, lsl #4
     ea4:	121e0f00 	andsne	r0, lr, #0, 30
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem );
     ea8:	000000b2 	strheq	r0, [r0], -r2
     eac:	016c9102 	cmneq	ip, r2, lsl #2
    listREMOVE_ITEM( pxEventListItem );
     eb0:	00000af3 	strdeq	r0, [r0], -r3
     eb4:	f5141e10 			@ <UNDEFINED> instruction: 0xf5141e10
     eb8:	02000000 	andeq	r0, r0, #0
     ebc:	24017091 	strcs	r7, [r1], #-145	@ 0xffffff6f
     ec0:	10000009 	andne	r0, r0, r9
     ec4:	00f5251e 	rscseq	r2, r5, lr, lsl r5
     ec8:	91020000 	mrsls	r0, (UNDEF: 2)
     ecc:	830e0074 	movwhi	r0, #57460	@ 0xe074
     ed0:	de000008 	cdple	0, 0, cr0, cr0, cr8, {0}
     ed4:	01210c1d 			@ <UNDEFINED> instruction: 0x01210c1d
     ed8:	11f80000 	mvnsne	r0, r0
     edc:	00300000 	eorseq	r0, r0, r0
     ee0:	9c010000 	stcls	0, cr0, [r1], {-0}
     ee4:	00000be7 	andeq	r0, r0, r7, ror #23
     ee8:	00075901 	andeq	r5, r7, r1, lsl #18
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
     eec:	101de000 	andsne	lr, sp, r0
     ef0:	00000121 	andeq	r0, r0, r1, lsr #2
     ef4:	00749102 	rsbseq	r9, r4, r2, lsl #2
     ef8:	000b720e 	andeq	r7, fp, lr, lsl #4
     efc:	1219ae00 	andsne	sl, r9, #0, 28
     f00:	0000022d 	andeq	r0, r0, sp, lsr #4
     f04:	000011c8 	andeq	r1, r0, r8, asr #3
     f08:	00000030 	andeq	r0, r0, r0, lsr r0
     f0c:	0c209c01 	stceq	12, cr9, [r0], #-4
     f10:	c7020000 	strgt	r0, [r2, -r0]
     f14:	ae000001 	cdpge	0, 0, cr0, cr0, cr1, {0}
     f18:	00f53f19 	rscseq	r3, r5, r9, lsl pc
     f1c:	91020000 	mrsls	r0, (UNDEF: 2)
     f20:	075a016c 	ldrbeq	r0, [sl, -ip, ror #2]
     f24:	19b00000 	ldmibne	r0!, {}	@ <UNPREDICTABLE>
    prvAddTaskToReadyList( pxUnblockedTCB );
     f28:	00022d16 	andeq	r2, r2, r6, lsl sp
     f2c:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
     f30:	0b030e00 	bleq	c4738 <_etext+0xc2268>
     f34:	198b0000 	stmibne	fp, {}	@ <UNPREDICTABLE>
     f38:	00022d16 	andeq	r2, r2, r6, lsl sp
     f3c:	0011ac00 	andseq	sl, r1, r0, lsl #24
     f40:	00001c00 	andeq	r1, r0, r0, lsl #24
     f44:	4a9c0100 	bmi	fe70134c <__StackTop+0xde6ff34c>
     f48:	0100000c 	tsteq	r0, ip
     f4c:	0000075a 	andeq	r0, r0, sl, asr r7
     f50:	2d1a198d 	vldrcs.16	s2, [sl, #-282]	@ 0xfffffee6	@ <UNPREDICTABLE>
     f54:	02000002 	andeq	r0, r0, #2
     f58:	1f007491 	svcne	0x00007491
     f5c:	000007b1 			@ <UNDEFINED> instruction: 0x000007b1
     f60:	11781973 	cmnne	r8, r3, ror r9
     f64:	00340000 	eorseq	r0, r4, r0
     f68:	9c010000 	stcls	0, cr0, [r1], {-0}
     f6c:	000c4e1f 	andeq	r4, ip, pc, lsl lr
     f70:	6c17d300 	ldcvs	3, cr13, [r7], {-0}
     f74:	0c000011 	stceq	0, cr0, [r0], {17}
     f78:	01000000 	mrseq	r0, (UNDEF: 0)
     f7c:	04e4159c 	strbteq	r1, [r4], #1436	@ 0x59c
     f80:	17b30000 	ldrne	r0, [r3, r0]!
     f84:	0011000d 	andseq	r0, r1, sp
     f88:	00006c00 	andeq	r6, r0, r0, lsl #24
     f8c:	929c0100 	addsls	r0, ip, #0, 2
     f90:	0100000c 	tsteq	r0, ip
     f94:	000001fc 	strdeq	r0, [r0], -ip
     f98:	0b1117b5 	bleq	446e74 <_etext+0x4449a4>
     f9c:	02000001 	andeq	r0, r0, #1
     fa0:	15007491 	strne	r7, [r0, #-1169]	@ 0xfffffb6f
     fa4:	00000679 	andeq	r0, r0, r9, ror r6
     fa8:	d00816a9 	andle	r1, r8, r9, lsr #13
        if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     fac:	30000010 	andcc	r0, r0, r0, lsl r0
     fb0:	01000000 	mrseq	r0, (UNDEF: 0)
     fb4:	000cb89c 	muleq	ip, ip, r8
            xYieldPendings[ 0 ] = pdTRUE;
     fb8:	01400200 	mrseq	r0, (UNDEF: 96)
     fbc:	16a90000 	strtne	r0, [r9], r0
}
     fc0:	00007f08 	andeq	r7, r0, r8, lsl #30
     fc4:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
     fc8:	0a002000 	beq	8fd0 <_etext+0x6b00>
     fcc:	16180000 	ldrne	r0, [r8], -r0
     fd0:	000010b8 	strheq	r1, [r0], -r8
     fd4:	00000018 	andeq	r0, r0, r8, lsl r0
{
     fd8:	b00c9c01 	andlt	r9, ip, r1, lsl #24
     fdc:	d3000009 	movwle	r0, #9
    taskENTER_CRITICAL();
     fe0:	00f50c15 	rscseq	r0, r5, r5, lsl ip
        pxTimeOut->xOverflowCount = xNumOfOverflows;
     fe4:	10340000 	eorsne	r0, r4, r0
     fe8:	00840000 	addeq	r0, r4, r0
        pxTimeOut->xTimeOnEntering = xTickCount;
     fec:	9c010000 	stcls	0, cr0, [r1], {-0}
     ff0:	00000d39 	andeq	r0, r0, r9, lsr sp
    taskEXIT_CRITICAL();
     ff4:	00080102 	andeq	r0, r8, r2, lsl #2
}
     ff8:	3415d300 	ldrcc	sp, [r5], #-768	@ 0xfffffd00
     ffc:	00000d3e 	andeq	r0, r0, lr, lsr sp
    1000:	02649102 	rsbeq	r9, r4, #-2147483648	@ 0x80000000
    1004:	00000abd 			@ <UNDEFINED> instruction: 0x00000abd
{
    1008:	483515d4 	ldmdami	r5!, {r2, r4, r6, r7, r8, sl, ip}
    100c:	0200000d 	andeq	r0, r0, #13
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    1010:	5a016091 	bpl	5925c <_etext+0x56d8c>
    1014:	d6000007 	strle	r0, [r0], -r7
    pxTimeOut->xTimeOnEntering = xTickCount;
    1018:	00f51015 	rscseq	r1, r5, r5, lsl r0
    101c:	91020000 	mrsls	r0, (UNDEF: 2)
}
    1020:	10420974 	subne	r0, r2, r4, ror r9
    1024:	005e0000 	subseq	r0, lr, r0
    1028:	98010000 	stmdals	r1, {}	@ <UNPREDICTABLE>
    102c:	e0000005 	and	r0, r0, r5
    1030:	01321a15 	teqeq	r2, r5, lsl sl
{
    1034:	91020000 	mrsls	r0, (UNDEF: 2)
    1038:	046d0170 	strbteq	r0, [sp], #-368	@ 0xfffffe90
    103c:	15e10000 	strbne	r0, [r1, #0]!
    taskENTER_CRITICAL();
    1040:	0001321a 	andeq	r3, r1, sl, lsl r2
        const TickType_t xConstTickCount = xTickCount;
    1044:	6c910200 	lfmvs	f0, 4, [r1], {0}
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    1048:	16040000 	strne	r0, [r4], -r0
    104c:	05000003 	streq	r0, [r0, #-3]
    1050:	00000d39 	andeq	r0, r0, r9, lsr sp
        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) )
    1054:	00012104 	andeq	r2, r1, r4, lsl #2
    1058:	0d430500 	cfstr64eq	mvdx0, [r3, #-0]
    105c:	42140000 	andsmi	r0, r4, #0
    1060:	c7000008 	strgt	r0, [r0, -r8]
    1064:	10080615 	andne	r0, r8, r5, lsl r6
            xReturn = pdTRUE;
    1068:	002c0000 	eoreq	r0, ip, r0
            *pxTicksToWait = ( TickType_t ) 0;
    106c:	9c010000 	stcls	0, cr0, [r1], {-0}
    1070:	00000d73 	andeq	r0, r0, r3, ror sp
        else if( xElapsedTime < *pxTicksToWait )
    1074:	00080102 	andeq	r0, r8, r2, lsl #2
    1078:	3615c700 	ldrcc	ip, [r5], -r0, lsl #14
    107c:	00000d3e 	andeq	r0, r0, lr, lsr sp
            *pxTicksToWait -= xElapsedTime;
    1080:	00749102 	rsbseq	r9, r4, r2, lsl #2
    1084:	00030217 	andeq	r0, r3, r7, lsl r2
    1088:	d815b700 	ldmdale	r5, {r8, r9, sl, ip, sp, pc}
            vTaskInternalSetTimeOutState( pxTimeOut );
    108c:	3000000f 	andcc	r0, r0, pc
            xReturn = pdFALSE;
    1090:	01000000 	mrseq	r0, (UNDEF: 0)
    1094:	000d989c 	muleq	sp, ip, r8
            *pxTicksToWait = ( TickType_t ) 0;
    1098:	08010200 	stmdaeq	r1, {r9}
            xReturn = pdTRUE;
    109c:	15b70000 	ldrne	r0, [r7, #0]!
    taskEXIT_CRITICAL();
    10a0:	000d3e2e 	andeq	r3, sp, lr, lsr #28
    return xReturn;
    10a4:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
}
    10a8:	06001400 	streq	r1, [r0], -r0, lsl #8
    10ac:	156f0000 	strbne	r0, [pc, #-0]!	@ 10b4 <xTaskCheckForTimeOut+0x80>
    10b0:	000e9406 	andeq	r9, lr, r6, lsl #8
    10b4:	00014400 	andeq	r4, r1, r0, lsl #8
{
    10b8:	2f9c0100 	svccs	0x009c0100
    xYieldPendings[ portGET_CORE_ID() ] = pdTRUE;
    10bc:	0200000e 	andeq	r0, r0, #14
    10c0:	00000b1d 	andeq	r0, r0, sp, lsl fp
}
    10c4:	1236156f 	eorsne	r1, r6, #465567744	@ 0x1bc00000
    10c8:	02000002 	andeq	r0, r0, #2
    10cc:	64026491 	strvs	r6, [r2], #-1169	@ 0xfffffb6f
{
    10d0:	70000009 	andvc	r0, r0, r9
    10d4:	01323a15 	teqeq	r2, r5, lsl sl
        prvCheckTasksWaitingTermination();
    10d8:	91020000 	mrsls	r0, (UNDEF: 2)
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) configNUMBER_OF_CORES )
    10dc:	043e0160 	ldrteq	r0, [lr], #-352	@ 0xfffffea0
    10e0:	15720000 	ldrbne	r0, [r2, #-0]!
                taskYIELD();
    10e4:	0003d70d 	andeq	sp, r3, sp, lsl #14
    10e8:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
    10ec:	000eae03 	andeq	sl, lr, r3, lsl #28
    10f0:	00003c00 	andeq	r3, r0, r0, lsl #24
        prvCheckTasksWaitingTermination();
    10f4:	000df800 	andeq	pc, sp, r0, lsl #16
    10f8:	0c290100 	stfeqs	f0, [r9], #-0
    10fc:	15840000 	strne	r0, [r4]
{
    1100:	00044305 	andeq	r4, r4, r5, lsl #6
    1104:	70910200 	addsvc	r0, r1, r0, lsl #4
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    1108:	0eea0300 	cdpeq	3, 14, cr0, cr10, cr0, {0}
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    110c:	003e0000 	eorseq	r0, lr, r0
    1110:	0e150000 	cdpeq	0, 1, cr0, cr5, cr0, {0}
    1114:	29010000 	stmdbcs	r1, {}	@ <UNPREDICTABLE>
    1118:	9700000c 	strls	r0, [r0, -ip]
    111c:	04430515 	strbeq	r0, [r3], #-1301	@ 0xfffffaeb
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    1120:	91020000 	mrsls	r0, (UNDEF: 2)
    1124:	3a09006c 	bcc	2412dc <_etext+0x23ee0c>
    1128:	7000000f 	andvc	r0, r0, pc
    vListInitialise( &xDelayedTaskList1 );
    112c:	01000000 	mrseq	r0, (UNDEF: 0)
    1130:	000002a1 	andeq	r0, r0, r1, lsr #5
    vListInitialise( &xDelayedTaskList2 );
    1134:	17051598 			@ <UNDEFINED> instruction: 0x17051598
    vListInitialise( &xPendingReadyList );
    1138:	02000002 	andeq	r0, r0, #2
    113c:	00006891 	muleq	r0, r1, r8
    pxDelayedTaskList = &xDelayedTaskList1;
    1140:	0006220e 	andeq	r2, r6, lr, lsl #4
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1144:	0c151200 	lfmeq	f1, 4, [r5], {-0}
    1148:	000000f5 	strdeq	r0, [r0], -r5
}
    114c:	00000d00 	andeq	r0, r0, r0, lsl #26
    1150:	00000194 	muleq	r0, r4, r1
    1154:	0ee79c01 	cdpeq	12, 14, cr9, cr7, cr1, {0}
    1158:	83020000 	movwhi	r0, #8192	@ 0x2000
    115c:	12000002 	andne	r0, r0, #2
    1160:	0eec3b15 	vdupeq.8	q6, r3
    1164:	91020000 	mrsls	r0, (UNDEF: 2)
    1168:	043e015c 	ldrteq	r0, [lr], #-348	@ 0xfffffea4
{
    116c:	15140000 	ldrne	r0, [r4, #-0]
}
    1170:	0003d70d 	andeq	sp, r3, sp, lsl #14
    1174:	70910200 	addsvc	r0, r1, r0, lsl #4
{
    1178:	00075a01 	andeq	r5, r7, r1, lsl #20
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    117c:	10151500 	andsne	r1, r5, r0, lsl #10
    1180:	000000f5 	strdeq	r0, [r0], -r5
    1184:	03749102 	cmneq	r4, #-2147483648	@ 0x80000000
        xNextTaskUnblockTime = portMAX_DELAY;
    1188:	00000d10 	andeq	r0, r0, r0, lsl sp
    118c:	0000003e 	andeq	r0, r0, lr, lsr r0
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    1190:	00000e93 	muleq	r0, r3, lr
    1194:	000c2901 	andeq	r2, ip, r1, lsl #18
    1198:	05152b00 	ldreq	r2, [r5, #-2816]	@ 0xfffff500
}
    119c:	00000443 	andeq	r0, r0, r3, asr #8
    11a0:	006c9102 	rsbeq	r9, ip, r2, lsl #2
    11a4:	000d5603 	andeq	r5, sp, r3, lsl #12
    11a8:	00003e00 	andeq	r3, r0, r0, lsl #28
        {
    11ac:	000eb000 	andeq	fp, lr, r0
    11b0:	0c290100 	stfeqs	f0, [r9], #-0
            xReturn = pxCurrentTCB;
    11b4:	152f0000 	strne	r0, [pc, #-0]!	@ 11bc <xTaskGetCurrentTaskHandle+0x10>
            return xReturn;
    11b8:	00044309 	andeq	r4, r4, r9, lsl #6
        }
    11bc:	64910200 	ldrvs	r0, [r1], #512	@ 0x200
    11c0:	0da60300 	stceq	3, cr0, [r6]
    11c4:	00700000 	rsbseq	r0, r0, r0
    {
    11c8:	0ecd0000 	cdpeq	0, 12, cr0, cr13, cr0, {0}
    11cc:	a1010000 	mrsge	r0, (UNDEF: 1)
        TaskHandle_t xReturn = NULL;
    11d0:	30000002 	andcc	r0, r0, r2
        if( taskVALID_CORE_ID( xCoreID ) != pdFALSE )
    11d4:	02170915 	andseq	r0, r7, #344064	@ 0x54000
    11d8:	91020000 	mrsls	r0, (UNDEF: 2)
    11dc:	18090060 	stmdane	r9, {r5, r6}
                xReturn = pxCurrentTCB;
    11e0:	3800000e 	stmdacc	r0, {r1, r2, r3}
    11e4:	01000000 	mrseq	r0, (UNDEF: 0)
    }
    11e8:	000002a1 	andeq	r0, r0, r1, lsr #5
    11ec:	17091544 	strne	r1, [r9, -r4, asr #10]
    11f0:	02000002 	andeq	r0, r0, #2
    11f4:	00006891 	muleq	r0, r1, r8
{
    11f8:	00022804 	andeq	r2, r2, r4, lsl #16
    11fc:	0ee70500 	cdpeq	5, 14, cr0, cr7, cr0, {0}
    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    1200:	8e170000 	cdphi	0, 1, cr0, cr7, cr0, {0}
    1204:	cd00000a 	stcgt	0, cr0, [r0, #-40]	@ 0xffffffd8
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) );
    1208:	000c9014 	andeq	r9, ip, r4, lsl r0
    120c:	00007000 	andeq	r7, r0, r0
    1210:	4d9c0100 	ldfmis	f0, [ip]
    1214:	0200000f 	andeq	r0, r0, #15
}
    1218:	00000283 	andeq	r0, r0, r3, lsl #5
    121c:	392f14cd 	stmdbcc	pc!, {r0, r2, r3, r6, r7, sl, ip}	@ <UNPREDICTABLE>
    1220:	02000004 	andeq	r0, r0, #4
    1224:	64026c91 	strvs	r6, [r2], #-3217	@ 0xfffff36f
    {
    1228:	ce000009 	cdpgt	0, 0, cr0, cr0, cr9, {0}
    122c:	01323714 	teqeq	r2, r4, lsl r7
    1230:	91020000 	mrsls	r0, (UNDEF: 2)
        BaseType_t xAlreadyYielded, xShouldBlock = pdFALSE;
    1234:	0abe0268 	beq	fef81bdc <__StackTop+0xdef7fbdc>
        if( ( pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] == 0U ) && ( xTicksToWait > ( TickType_t ) 0 ) )
    1238:	14cf0000 	strbne	r0, [pc], #0	@ 1240 <ulTaskGenericNotifyTake+0x18>
    123c:	00013237 	andeq	r3, r1, r7, lsr r2
    1240:	64910200 	ldrvs	r0, [r1], #512	@ 0x200
    1244:	000ca809 	andeq	sl, ip, r9, lsl #16
    1248:	00004200 	andeq	r4, r0, r0, lsl #4
    124c:	02a10100 	adceq	r0, r1, #0, 2
            vTaskSuspendAll();
    1250:	14e30000 	strbtne	r0, [r3], #0
                taskENTER_CRITICAL();
    1254:	00021705 	andeq	r1, r2, r5, lsl #14
                    if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] == 0U )
    1258:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
    125c:	c9170000 	ldmdbgt	r7, {}	@ <UNPREDICTABLE>
    1260:	b0000005 	andlt	r0, r0, r5
    1264:	000c6414 	andeq	r6, ip, r4, lsl r4
    1268:	00002c00 	andeq	r2, r0, r0, lsl #24
                        pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskWAITING_NOTIFICATION;
    126c:	819c0100 	orrshi	r0, ip, r0, lsl #2
    1270:	0200000f 	andeq	r0, r0, #15
    1274:	00000283 	andeq	r0, r0, r3, lsl #5
                        xShouldBlock = pdTRUE;
    1278:	432c14b0 			@ <UNDEFINED> instruction: 0x432c14b0
                taskEXIT_CRITICAL();
    127c:	02000004 	andeq	r0, r0, #4
                if( xShouldBlock == pdTRUE )
    1280:	be027491 	mcrlt	4, 0, r7, cr2, cr1, {4}
    1284:	b100000a 	tstlt	r0, sl
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1288:	01322e14 	teqeq	r2, r4, lsl lr
    128c:	91020000 	mrsls	r0, (UNDEF: 2)
            xAlreadyYielded = xTaskResumeAll();
    1290:	e8140070 	ldmda	r4, {r4, r5, r6}
            if( ( xShouldBlock == pdTRUE ) && ( xAlreadyYielded == pdFALSE ) )
    1294:	f5000008 			@ <UNDEFINED> instruction: 0xf5000008
    1298:	0bd80a13 	bleq	ff603aec <__StackTop+0xdf601aec>
    129c:	008c0000 	addeq	r0, ip, r0
                taskYIELD_WITHIN_API();
    12a0:	9c010000 	stcls	0, cr0, [r1], {-0}
    12a4:	00000fef 	andeq	r0, r0, pc, ror #31
    12a8:	000bf409 	andeq	pc, fp, r9, lsl #8
    12ac:	00004e00 	andeq	r4, r0, r0, lsl #28
        taskENTER_CRITICAL();
    12b0:	0ad70100 	beq	ff5c16b8 <__StackTop+0xdf5bf6b8>
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ];
    12b4:	142f0000 	strtne	r0, [pc], #-0	@ 12bc <ulTaskGenericNotifyTake+0x94>
    12b8:	00010b0d 	andeq	r0, r1, sp, lsl #22
    12bc:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
    12c0:	000c0a03 	andeq	r0, ip, r3, lsl #20
            if( ulReturn != 0U )
    12c4:	00003800 	andeq	r3, r0, r0, lsl #16
    12c8:	000fcc00 	andeq	ip, pc, r0, lsl #24
                if( xClearCountOnExit != pdFALSE )
    12cc:	02070100 	andeq	r0, r7, #0, 2
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] = ( uint32_t ) 0U;
    12d0:	142f0000 	strtne	r0, [pc], #-0	@ 12d8 <ulTaskGenericNotifyTake+0xb0>
    12d4:	0004430d 	andeq	r4, r4, sp, lsl #6
    12d8:	70910200 	addsvc	r0, r1, r0, lsl #4
    12dc:	15d51600 	ldrbne	r1, [r5, #1536]	@ 0x600
    12e0:	0bfa0000 	bleq	ffe812e8 <__StackTop+0xdfe7f2e8>
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] = ulReturn - ( uint32_t ) 1;
    12e4:	000a0000 	andeq	r0, sl, r0
    12e8:	142f0000 	strtne	r0, [pc], #-0	@ 12f0 <ulTaskGenericNotifyTake+0xc8>
    12ec:	15e21c0d 	strbne	r1, [r2, #3085]!	@ 0xc0d
    12f0:	91020000 	mrsls	r0, (UNDEF: 2)
            pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskNOT_WAITING_NOTIFICATION;
    12f4:	15ed0f6c 	strbne	r0, [sp, #3948]!	@ 0xf6c
    12f8:	91020000 	mrsls	r0, (UNDEF: 2)
    12fc:	0000006b 	andeq	r0, r0, fp, rrx
    1300:	0003400c 	andeq	r4, r3, ip
        taskEXIT_CRITICAL();
    1304:	0c127500 	cfldr32eq	mvfx7, [r2], {-0}
    }
    1308:	000000f5 	strdeq	r0, [r0], -r5
    130c:	000009c8 	andeq	r0, r0, r8, asr #19
    1310:	00000210 	andeq	r0, r0, r0, lsl r2
    1314:	10c09c01 	sbcne	r9, r0, r1, lsl #24
    {
    1318:	c5010000 	strgt	r0, [r1, #-0]
    131c:	7700000b 	strvc	r0, [r0, -fp]
    1320:	03d70d12 	bicseq	r0, r7, #1152	@ 0x480
    1324:	91020000 	mrsls	r0, (UNDEF: 2)
        BaseType_t xReturn, xAlreadyYielded, xShouldBlock = pdFALSE;
    1328:	09640168 	stmdbeq	r4!, {r3, r5, r6, r8}^
        if( ( pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] != taskNOTIFICATION_RECEIVED ) && ( xTicksToWait > ( TickType_t ) 0 ) )
    132c:	12780000 	rsbsne	r0, r8, #0
    1330:	00012110 	andeq	r2, r1, r0, lsl r1
    1334:	64910200 	ldrvs	r0, [r1], #512	@ 0x200
    1338:	00099001 	andeq	r9, r9, r1
    133c:	10127900 	andsne	r7, r2, r0, lsl #18
    1340:	000000f5 	strdeq	r0, [r0], -r5
            vTaskSuspendAll();
    1344:	09749102 	ldmdbeq	r4!, {r1, r8, ip, pc}^
                taskENTER_CRITICAL();
    1348:	000009dc 	ldrdeq	r0, [r0], -ip
                    if( pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] != taskNOTIFICATION_RECEIVED )
    134c:	000001bc 			@ <UNDEFINED> instruction: 0x000001bc
    1350:	00059801 	andeq	r9, r5, r1, lsl #16
    1354:	1a128a00 	bne	4a3b5c <_etext+0x4a168c>
    1358:	00000132 	andeq	r0, r0, r2, lsr r1
                        pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] &= ~ulBitsToClearOnEntry;
    135c:	03709102 	cmneq	r0, #-2147483648	@ 0x80000000
    1360:	000009f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
    1364:	00000022 	andeq	r0, r0, r2, lsr #32
    1368:	0000106b 	andeq	r1, r0, fp, rrx
    136c:	00051601 	andeq	r1, r5, r1, lsl #12
    1370:	0d129200 	lfmeq	f1, 1, [r2, #-0]
    1374:	00000439 	andeq	r0, r0, r9, lsr r4
    1378:	006c9102 	rsbeq	r9, ip, r2, lsl #2
                        pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskWAITING_NOTIFICATION;
    137c:	000a5203 	andeq	r5, sl, r3, lsl #4
    1380:	00003e00 	andeq	r3, r0, r0, lsl #28
    1384:	00108800 	andseq	r8, r0, r0, lsl #16
                        xShouldBlock = pdTRUE;
    1388:	0c290100 	stfeqs	f0, [r9], #-0
                taskEXIT_CRITICAL();
    138c:	12c70000 	sbcne	r0, r7, #0
                if( xShouldBlock == pdTRUE )
    1390:	00044315 	andeq	r4, r4, r5, lsl r3
    1394:	60910200 	addsvs	r0, r1, r0, lsl #4
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1398:	0a980300 	beq	fe601fa0 <__StackTop+0xde5fffa0>
    139c:	003e0000 	eorseq	r0, lr, r0
            xAlreadyYielded = xTaskResumeAll();
    13a0:	10a50000 	adcne	r0, r5, r0
            if( ( xShouldBlock == pdTRUE ) && ( xAlreadyYielded == pdFALSE ) )
    13a4:	29010000 	stmdbcs	r1, {}	@ <UNPREDICTABLE>
    13a8:	cd00000c 	stcgt	0, cr0, [r0, #-48]	@ 0xffffffd0
    13ac:	04431912 	strbeq	r1, [r3], #-2322	@ 0xfffff6ee
                taskYIELD_WITHIN_API();
    13b0:	91020000 	mrsls	r0, (UNDEF: 2)
    13b4:	e809005c 	stmda	r9, {r2, r3, r4, r6}
    13b8:	7000000a 	andvc	r0, r0, sl
    13bc:	01000000 	mrseq	r0, (UNDEF: 0)
        taskENTER_CRITICAL();
    13c0:	000002a1 	andeq	r0, r0, r1, lsr #5
            if( pulNotificationValue != NULL )
    13c4:	171512d6 			@ <UNDEFINED> instruction: 0x171512d6
    13c8:	02000002 	andeq	r0, r0, #2
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ];
    13cc:	00005891 	muleq	r0, r1, r8
    13d0:	03b20c00 			@ <UNDEFINED> instruction: 0x03b20c00
    13d4:	11f90000 	mvnsne	r0, r0
    13d8:	0000f50c 	andeq	pc, r0, ip, lsl #10
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] != taskNOTIFICATION_RECEIVED )
    13dc:	00099400 	andeq	r9, r9, r0, lsl #8
    13e0:	00003400 	andeq	r3, r0, r0, lsl #8
    13e4:	f99c0100 			@ <UNDEFINED> instruction: 0xf99c0100
    13e8:	02000010 	andeq	r0, r0, #16
    13ec:	00000b3a 	andeq	r0, r0, sl, lsr fp
                xReturn = pdFALSE;
    13f0:	212a11f9 	strdcs	r1, [sl, -r9]!
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] &= ~ulBitsToClearOnExit;
    13f4:	02000001 	andeq	r0, r0, #1
    13f8:	fd016c91 	stc2	12, cr6, [r1, #-580]	@ 0xfffffdbc
    13fc:	fb000006 	blx	141e <xTaskGenericNotifyWait+0x106>
    1400:	00f51011 	rscseq	r1, r5, r1, lsl r0
    1404:	91020000 	mrsls	r0, (UNDEF: 2)
    1408:	230e0074 	movwcs	r0, #57460	@ 0xe074
    140c:	8200000a 	andhi	r0, r0, #10
    1410:	00860810 	addeq	r0, r6, r0, lsl r8
                xReturn = pdTRUE;
    1414:	09680000 	stmdbeq	r8!, {}^	@ <UNPREDICTABLE>
            pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskNOT_WAITING_NOTIFICATION;
    1418:	002c0000 	eoreq	r0, ip, r0
    141c:	9c010000 	stcls	0, cr0, [r1], {-0}
    1420:	00001132 	andeq	r1, r0, r2, lsr r1
        taskEXIT_CRITICAL();
    1424:	0008a402 	andeq	sl, r8, r2, lsl #8
        return xReturn;
    1428:	24108200 	ldrcs	r8, [r0], #-512	@ 0xfffffe00
    }
    142c:	0000022d 	andeq	r0, r0, sp, lsr #4
    1430:	016c9102 	cmneq	ip, r2, lsl #2
    1434:	00000bc5 	andeq	r0, r0, r5, asr #23
    1438:	d70d1084 	strle	r1, [sp, -r4, lsl #1]
    {
    143c:	02000003 	andeq	r0, r0, #3
    1440:	2e007491 	mcrcs	4, 0, r7, cr0, cr1, {4}
    1444:	00000227 	andeq	r0, r0, r7, lsr #4
    1448:	0d107601 	ldceq	6, cr7, [r0, #-4]
        BaseType_t xReturn = pdPASS;
    144c:	0000010b 	andeq	r0, r0, fp, lsl #2
        pxTCB = xTaskToNotify;
    1450:	00000954 	andeq	r0, r0, r4, asr r9
        taskENTER_CRITICAL();
    1454:	00000014 	andeq	r0, r0, r4, lsl r0
            if( pulPreviousNotificationValue != NULL )
    1458:	910e9c01 	tstls	lr, r1, lsl #24
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    145c:	53000004 	movwpl	r0, #4
    1460:	01210c10 			@ <UNDEFINED> instruction: 0x01210c10
    1464:	09340000 	ldmdbeq	r4!, {}	@ <UNPREDICTABLE>
    1468:	00200000 	eoreq	r0, r0, r0
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    146c:	9c010000 	stcls	0, cr0, [r1], {-0}
    1470:	00001182 	andeq	r1, r0, r2, lsl #3
    1474:	00075a01 	andeq	r5, r7, r1, lsl #20
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    1478:	10105500 	andsne	r5, r0, r0, lsl #10
    147c:	00000121 	andeq	r0, r0, r1, lsr #2
    1480:	01709102 	cmneq	r0, r2, lsl #2
            switch( eAction )
    1484:	000003e7 	andeq	r0, r0, r7, ror #7
    1488:	0b111056 	bleq	4455e8 <_etext+0x443118>
    148c:	02000001 	andeq	r0, r0, #1
    1490:	0e007491 	mcreq	4, 0, r7, cr0, cr1, {4}
    1494:	00000826 	andeq	r0, r0, r6, lsr #16
    1498:	210c1040 	tstcs	ip, r0, asr #32
    149c:	18000001 	stmdane	r0, {r0}
    14a0:	1c000009 	stcne	0, cr0, [r0], {9}
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    14a4:	01000000 	mrseq	r0, (UNDEF: 0)
    14a8:	0011ac9c 	mulseq	r1, ip, ip
    14ac:	0a310100 	beq	c418b4 <_etext+0xc3f3e4>
    14b0:	10420000 	subne	r0, r2, r0
    14b4:	00012110 	andeq	r2, r1, r0, lsl r1
    14b8:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
    14bc:	096f0c00 	stmdbeq	pc!, {sl, fp}^	@ <UNPREDICTABLE>
                    break;
    14c0:	0fab0000 	svceq	0x00ab0000
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    14c4:	0000f50c 	andeq	pc, r0, ip, lsl #10
    14c8:	00072800 	andeq	r2, r7, r0, lsl #16
    14cc:	0001f000 	andeq	pc, r1, r0
    14d0:	6e9c0100 	fmlvse	f0, f4, f0
    14d4:	01000012 	tsteq	r0, r2, lsl r0
    14d8:	00000bc5 	andeq	r0, r0, r5, asr #23
                    break;
    14dc:	d70d0fad 	strle	r0, [sp, -sp, lsr #31]
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    14e0:	02000003 	andeq	r0, r0, #3
    14e4:	f3017491 	vqshl.u8	d7, d1, d17
    14e8:	ae00000a 	cdpge	0, 0, cr0, cr0, cr10, {0}
                    break;
    14ec:	00f5100f 	rscseq	r1, r5, pc
                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    14f0:	91020000 	mrsls	r0, (UNDEF: 2)
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    14f4:	073a0970 			@ <UNDEFINED> instruction: 0x073a0970
    14f8:	01ac0000 			@ <UNDEFINED> instruction: 0x01ac0000
    14fc:	c7010000 	strgt	r0, [r1, -r0]
    1500:	bd000001 	stclt	0, cr0, [r0, #-4]
                        xReturn = pdFAIL;
    1504:	01061e0f 	tsteq	r6, pc, lsl #28
                    break;
    1508:	91020000 	mrsls	r0, (UNDEF: 2)
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    150c:	07660368 	strbeq	r0, [r6, -r8, ror #6]!
    1510:	003e0000 	eorseq	r0, lr, r0
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    1514:	12190000 	andsne	r0, r9, #0
    1518:	29010000 	stmdbcs	r1, {}	@ <UNPREDICTABLE>
    151c:	d200000c 	andle	r0, r0, #12
    1520:	0443190f 	strbeq	r1, [r3], #-2319	@ 0xfffff6f1
    1524:	91020000 	mrsls	r0, (UNDEF: 2)
    1528:	a4030064 	strge	r0, [r3], #-100	@ 0xffffff9c
    152c:	3e000007 	cdpcc	0, 0, cr0, cr0, cr7, {0}
    1530:	36000000 	strcc	r0, [r0], -r0
    1534:	01000012 	tsteq	r0, r2, lsl r0
    1538:	00000c29 	andeq	r0, r0, r9, lsr #24
    153c:	43190fd4 	tstmi	r9, #212, 30	@ 0x350
    1540:	02000004 	andeq	r0, r0, #4
    1544:	03006091 	movweq	r6, #145	@ 0x91
    1548:	000007f4 	strdeq	r0, [r0], -r4
    154c:	00000070 	andeq	r0, r0, r0, ror r0
                prvAddTaskToReadyList( pxTCB );
    1550:	00001253 	andeq	r1, r0, r3, asr r2
    1554:	0002a101 	andeq	sl, r2, r1, lsl #2
    1558:	190fd500 	stmdbne	pc, {r8, sl, ip, lr, pc}	@ <UNPREDICTABLE>
    155c:	00000217 	andeq	r0, r0, r7, lsl r2
    1560:	005c9102 	subseq	r9, ip, r2, lsl #2
    1564:	00089009 	andeq	r9, r8, r9
    1568:	00003200 	andeq	r3, r0, r0, lsl #4
    156c:	02c10100 	sbceq	r0, r1, #0, 2
    1570:	10020000 	andne	r0, r2, r0
    1574:	00012124 	andeq	r2, r1, r4, lsr #2
    1578:	6c910200 	lfmvs	f0, 4, [r1], {0}
    157c:	20000000 	andcs	r0, r0, r0
    1580:	0000052f 	andeq	r0, r0, pc, lsr #10
    1584:	070c0efd 			@ <UNDEFINED> instruction: 0x070c0efd
    1588:	001c0000 	andseq	r0, ip, r0
    158c:	9c010000 	stcls	0, cr0, [r1], {-0}
    1590:	00058617 	andeq	r8, r5, r7, lsl r6
    1594:	dc0ed200 	sfmle	f5, 1, [lr], {-0}
    1598:	30000006 	andcc	r0, r0, r6
    159c:	01000000 	mrseq	r0, (UNDEF: 0)
    15a0:	0012ae9c 	mulseq	r2, ip, lr
    15a4:	15bf1600 	ldrne	r1, [pc, #1536]!	@ 1bac <vTaskResetState+0x30>
    15a8:	06e20000 	strbteq	r0, [r2], r0
    15ac:	00140000 	andseq	r0, r4, r0
    15b0:	0ef20000 	cdpeq	0, 15, cr0, cr2, cr0, {0}
    15b4:	15c90f05 	strbne	r0, [r9, #3845]	@ 0xf05
    15b8:	91020000 	mrsls	r0, (UNDEF: 2)
    15bc:	17000074 	smlsdxne	r0, r4, r0, r0
    15c0:	00000a38 	andeq	r0, r0, r8, lsr sl
    15c4:	06800e69 	streq	r0, [r0], r9, ror #28
    15c8:	005c0000 	subseq	r0, ip, r0
    15cc:	9c010000 	stcls	0, cr0, [r1], {-0}
    15d0:	000012ec 	andeq	r1, r0, ip, ror #5
                taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxTCB );
    15d4:	00075a01 	andeq	r5, r7, r1, lsl #20
    15d8:	100e6b00 	andne	r6, lr, r0, lsl #22
    15dc:	000000f5 	strdeq	r0, [r0], -r5
    15e0:	16749102 	ldrbtne	r9, [r4], -r2, lsl #2
    15e4:	000015bf 			@ <UNDEFINED> instruction: 0x000015bf
    15e8:	00000692 	muleq	r0, r2, r6
    15ec:	00000014 	andeq	r0, r0, r4, lsl r0
        taskEXIT_CRITICAL();
    15f0:	0f090e96 	svceq	0x00090e96
        return xReturn;
    15f4:	000015c9 	andeq	r1, r0, r9, asr #11
    }
    15f8:	00709102 	rsbseq	r9, r0, r2, lsl #2
    15fc:	06d62100 	ldrbeq	r2, [r6], r0, lsl #2
    1600:	0dd40000 	ldcleq	0, cr0, [r4]
    1604:	0000f513 	andeq	pc, r0, r3, lsl r5	@ <UNPREDICTABLE>
    1608:	0005d400 	andeq	sp, r5, r0, lsl #8
    160c:	0000ac00 	andeq	sl, r0, r0, lsl #24
    {
    1610:	529c0100 	addspl	r0, ip, #0, 2
    1614:	01000013 	tsteq	r0, r3, lsl r0
    1618:	0000075a 	andeq	r0, r0, sl, asr r7
    161c:	f5100dd6 			@ <UNDEFINED> instruction: 0xf5100dd6
        BaseType_t xReturn = pdPASS;
    1620:	02000000 	andeq	r0, r0, #0
        pxTCB = xTaskToNotify;
    1624:	c7017491 			@ <UNDEFINED> instruction: 0xc7017491
    __asm volatile
    1628:	d7000001 	strle	r0, [r0, -r1]
    162c:	00f5100d 	rscseq	r1, r5, sp
    1630:	91020000 	mrsls	r0, (UNDEF: 2)
    1634:	09310170 	ldmdbeq	r1!, {r4, r5, r6, r8}
    1638:	0dd80000 	ldcleq	0, cr0, [r8]
    163c:	0003720a 	andeq	r7, r3, sl, lsl #4
        uxSavedInterruptStatus = ( UBaseType_t ) taskENTER_CRITICAL_FROM_ISR();
    1640:	58910200 	ldmpl	r1, {r9}
            if( pulPreviousNotificationValue != NULL )
    1644:	0009cf01 	andeq	ip, r9, r1, lsl #30
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    1648:	140dd900 	strne	sp, [sp], #-2304	@ 0xfffff700
    164c:	000000c3 	andeq	r0, r0, r3, asr #1
    1650:	01689102 	cmneq	r8, r2, lsl #2
    1654:	000004bf 			@ <UNDEFINED> instruction: 0x000004bf
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    1658:	0b110dda 	bleq	444dc8 <_etext+0x4428f8>
    165c:	02000001 	andeq	r0, r0, #1
    1660:	15006c91 	strne	r6, [r0, #-3217]	@ 0xfffff36f
    1664:	000006b5 			@ <UNDEFINED> instruction: 0x000006b5
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    1668:	ac1107f9 	ldcge	7, cr0, [r1], {249}	@ 0xf9
    166c:	28000004 	stmdacs	r0, {r2}
    1670:	01000001 	tsteq	r0, r1
            switch( eAction )
    1674:	0013919c 	mulseq	r3, ip, r1
    1678:	06e90200 	strbteq	r0, [r9], r0, lsl #4
    167c:	07f90000 	ldrbeq	r0, [r9, r0]!
    1680:	0003d733 	andeq	sp, r3, r3, lsr r7
    1684:	6c910200 	lfmvs	f0, 4, [r1], {0}
    1688:	00051609 	andeq	r1, r5, r9, lsl #12
    168c:	00007000 	andeq	r7, r0, r0
    1690:	02a10100 	adceq	r0, r1, #0, 2
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    1694:	08330000 	ldmdaeq	r3!, {}	@ <UNPREDICTABLE>
    1698:	0002170d 	andeq	r1, r2, sp, lsl #14
    169c:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
    16a0:	4f150000 	svcmi	0x00150000
    16a4:	17000009 	strne	r0, [r0, -r9]
    16a8:	03e20d07 	mvneq	r0, #448	@ 0x1c0
    16ac:	00ca0000 	sbceq	r0, sl, r0
                    break;
    16b0:	9c010000 	stcls	0, cr0, [r1], {-0}
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    16b4:	0000143d 	andeq	r1, r0, sp, lsr r4
    16b8:	0006f202 	andeq	pc, r6, r2, lsl #4
    16bc:	32071700 	andcc	r1, r7, #0, 14
    16c0:	000000c3 	andeq	r0, r0, r3, asr #1
    16c4:	026c9102 	rsbeq	r9, ip, #-2147483648	@ 0x80000000
    16c8:	000005a8 	andeq	r0, r0, r8, lsr #11
                    break;
    16cc:	9c360718 	ldcls	7, cr0, [r6], #-96	@ 0xffffffa0
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    16d0:	02000000 	andeq	r0, r0, #0
    16d4:	3f026891 	svccc	0x00026891
    16d8:	19000005 	stmdbne	r0, {r0, r2}
                    break;
    16dc:	00f04007 	rscseq	r4, r0, r7
                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    16e0:	91020000 	mrsls	r0, (UNDEF: 2)
    16e4:	01400264 	cmpeq	r0, r4, ror #4
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    16e8:	071a0000 	ldreq	r0, [sl, -r0]
    16ec:	00008130 	andeq	r8, r0, r0, lsr r1
    16f0:	60910200 	addsvs	r0, r1, r0, lsl #4
                    break;
    16f4:	0001fc02 	andeq	pc, r1, r2, lsl #24
                        xReturn = pdFAIL;
    16f8:	2f071b00 	svccs	0x00071b00
                    break;
    16fc:	0000010b 	andeq	r0, r0, fp, lsl #2
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1700:	02009102 	andeq	r9, r0, #-2147483648	@ 0x80000000
    1704:	00000c40 	andeq	r0, r0, r0, asr #24
                if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
    1708:	4238071c 	eorsmi	r0, r8, #28, 14	@ 0x700000
    170c:	02000014 	andeq	r0, r0, #20
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    1710:	e9020491 	stmdb	r2, {r0, r4, r7, sl}
    1714:	1d000006 	stcne	0, cr0, [r0, #-24]	@ 0xffffffe8
    1718:	03d72b07 	bicseq	r2, r7, #7168	@ 0x1c00
    171c:	91020000 	mrsls	r0, (UNDEF: 2)
    1720:	0b4a0208 	bleq	1281f48 <_etext+0x127fa78>
    1724:	071e0000 	ldreq	r0, [lr, -r0]
    1728:	00144c40 	andseq	r4, r4, r0, asr #24
    172c:	0c910200 	lfmeq	f0, 4, [r1], {0}
    1730:	000bfd01 	andeq	pc, fp, r1, lsl #26
    1734:	13072000 	movwne	r2, #28672	@ 0x7000
    1738:	00000368 	andeq	r0, r0, r8, ror #6
    173c:	2f709102 	svccs	0x00709102
    1740:	21010078 	tstcs	r1, r8, ror r0
    1744:	010b1107 	tsteq	fp, r7, lsl #2
    1748:	91020000 	mrsls	r0, (UNDEF: 2)
    174c:	2d040074 	stccs	0, cr0, [r4, #-464]	@ 0xfffffe30
                    prvAddTaskToReadyList( pxTCB );
    1750:	05000002 	streq	r0, [r0, #-2]
    1754:	0000143d 	andeq	r1, r0, sp, lsr r4
    1758:	00036304 	andeq	r6, r3, r4, lsl #6
    175c:	14470500 	strbne	r0, [r7], #-1280	@ 0xfffffb00
    1760:	660c0000 	strvs	r0, [ip], -r0
    1764:	cc000001 	stcgt	0, cr0, [r0], {1}
    1768:	00f51006 	rscseq	r1, r5, r6
    176c:	039c0000 	orrseq	r0, ip, #0
    1770:	00460000 	subeq	r0, r6, r0
    1774:	9c010000 	stcls	0, cr0, [r1], {-0}
    1778:	000014e4 	andeq	r1, r0, r4, ror #9
    177c:	0006f202 	andeq	pc, r6, r2, lsl #4
    1780:	2c06cc00 	stccs	12, cr12, [r6], {-0}
    1784:	000000c3 	andeq	r0, r0, r3, asr #1
    1788:	026c9102 	rsbeq	r9, ip, #-2147483648	@ 0x80000000
    178c:	000005a8 	andeq	r0, r0, r8, lsr #11
    1790:	9c3006cd 	ldcls	6, cr0, [r0], #-820	@ 0xfffffccc
    1794:	02000000 	andeq	r0, r0, #0
    1798:	3f026891 	svccc	0x00026891
    179c:	ce000005 	cdpgt	0, 0, cr0, cr0, cr5, {0}
    17a0:	00f03a06 	rscseq	r3, r0, r6, lsl #20
    17a4:	91020000 	mrsls	r0, (UNDEF: 2)
    17a8:	01400264 	cmpeq	r0, r4, ror #4
    17ac:	06cf0000 	strbeq	r0, [pc], r0
    17b0:	0000812a 	andeq	r8, r0, sl, lsr #2
    17b4:	60910200 	addsvs	r0, r1, r0, lsl #4
    17b8:	0001fc02 	andeq	pc, r1, r2, lsl #24
    17bc:	2906d000 	stmdbcs	r6, {ip, lr, pc}
    17c0:	0000010b 	andeq	r0, r0, fp, lsl #2
    17c4:	02009102 	andeq	r9, r0, #-2147483648	@ 0x80000000
    17c8:	00000c40 	andeq	r0, r0, r0, asr #24
    17cc:	423206d1 	eorsmi	r0, r2, #219152384	@ 0xd100000
    17d0:	02000014 	andeq	r0, r0, #20
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    17d4:	e9010491 	stmdb	r1, {r0, r4, r7, sl}
    17d8:	d3000006 	movwle	r0, #6
    17dc:	03d71106 	bicseq	r1, r7, #-2147483647	@ 0x80000001
    17e0:	91020000 	mrsls	r0, (UNDEF: 2)
    17e4:	075a0170 			@ <UNDEFINED> instruction: 0x075a0170
    17e8:	06d40000 	ldrbeq	r0, [r4], r0
    17ec:	0000f514 	andeq	pc, r0, r4, lsl r5	@ <UNPREDICTABLE>
    17f0:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
    17f4:	045f2100 	ldrbeq	r2, [pc], #-256	@ 17fc <xTaskGenericNotifyFromISR+0x1ec>
    17f8:	066a0000 	strbteq	r0, [sl], -r0
    17fc:	0003d714 	andeq	sp, r3, r4, lsl r7
    1800:	00032400 	andeq	r2, r3, r0, lsl #8
    1804:	00007800 	andeq	r7, r0, r0, lsl #16
    1808:	819c0100 	orrshi	r0, ip, r0, lsl #2
                    if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    180c:	02000015 	andeq	r0, r0, #21
    1810:	000006f2 	strdeq	r0, [r0], -r2
    1814:	c332066a 	teqgt	r2, #111149056	@ 0x6a00000
                        if( pxHigherPriorityTaskWoken != NULL )
    1818:	02000000 	andeq	r0, r0, #0
    181c:	a8026c91 	stmdage	r2, {r0, r4, r7, sl, fp, sp, lr}
                            *pxHigherPriorityTaskWoken = pdTRUE;
    1820:	6b000005 	blvs	183c <xTaskGenericNotifyFromISR+0x22c>
                        xYieldPendings[ 0 ] = pdTRUE;
    1824:	009c3606 	addseq	r3, ip, r6, lsl #12
    1828:	91020000 	mrsls	r0, (UNDEF: 2)
    182c:	053f0268 	ldreq	r0, [pc, #-616]!	@ 15cc <xTaskGenericNotify+0x190>
    __asm volatile
    1830:	066c0000 	strbteq	r0, [ip], -r0
}
    1834:	0000f040 	andeq	pc, r0, r0, asr #32
    }
    1838:	64910200 	ldrvs	r0, [r1], #512	@ 0x200
    183c:	00014002 	andeq	r4, r1, r2
    1840:	30066d00 	andcc	r6, r6, r0, lsl #26
    1844:	00000081 	andeq	r0, r0, r1, lsl #1
    1848:	02609102 	rsbeq	r9, r0, #-2147483648	@ 0x80000000
    184c:	000001fc 	strdeq	r0, [r0], -ip
    1850:	0b2f066e 	bleq	bc3210 <_etext+0xbc0d40>
    1854:	02000001 	andeq	r0, r0, #1
    1858:	40020091 	mulmi	r2, r1, r0
    {
    185c:	6f00000c 	svcvs	0x0000000c
    1860:	14423806 	strbne	r3, [r2], #-2054	@ 0xfffff7fa
    1864:	91020000 	mrsls	r0, (UNDEF: 2)
        pxTCB = xTaskToNotify;
    1868:	06e90104 	strbteq	r0, [r9], r4, lsl #2
    __asm volatile
    186c:	06710000 	ldrbteq	r0, [r1], -r0
    1870:	0003d711 	andeq	sp, r3, r1, lsl r7
    1874:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
    1878:	00033209 	andeq	r3, r3, r9, lsl #4
    187c:	00003e00 	andeq	r3, r0, r0, lsl #28
    1880:	09a00100 	stmibeq	r0!, {r8}
    return ulOriginalBASEPRI;
    1884:	06960000 	ldreq	r0, [r6], r0
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    1888:	0003681b 	andeq	r6, r3, fp, lsl r8
    188c:	70910200 	addsvc	r0, r1, r0, lsl #4
    1890:	8f220000 	svchi	0x00220000
    1894:	f8000003 			@ <UNDEFINED> instruction: 0xf8000003
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    1898:	00001597 	muleq	r0, r7, r5
    189c:	00087423 	andeq	r7, r8, r3, lsr #8
    18a0:	b238f800 	eorslt	pc, r8, #0, 16
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    18a4:	00000000 	andeq	r0, r0, r0
    18a8:	00073030 	andeq	r3, r7, r0, lsr r0
    18ac:	22e40200 	rsccs	r0, r4, #0, 4
    18b0:	000000b2 	strheq	r0, [r0], -r2
    18b4:	0015bf03 	andseq	fp, r5, r3, lsl #30
    18b8:	04191800 	ldreq	r1, [r9], #-2048	@ 0xfffff800
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    18bc:	0ee60000 	cdpeq	0, 14, cr0, cr6, cr0, {0}
    18c0:	000000b2 	strheq	r0, [r0], -r2
    18c4:	00065518 	andeq	r5, r6, r8, lsl r5
                if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
    18c8:	b221e600 	eorlt	lr, r1, #0, 12
    18cc:	00000000 	andeq	r0, r0, r0
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    18d0:	000a1122 	andeq	r1, sl, r2, lsr #2
    18d4:	15d5d400 	ldrbne	sp, [r5, #1024]	@ 0x400
    18d8:	55180000 	ldrpl	r0, [r8, #-0]
    18dc:	d6000006 	strle	r0, [r0], -r6
    18e0:	0000b20e 	andeq	fp, r0, lr, lsl #4
    18e4:	89310000 	ldmdbhi	r1!, {}	@ <UNPREDICTABLE>
    18e8:	02000007 	andeq	r0, r0, #7
    18ec:	00a13e94 	umlaleq	r3, r1, r4, lr
    18f0:	23030000 	movwcs	r0, #12288	@ 0x3000
    18f4:	00000353 	andeq	r0, r0, r3, asr r3
    18f8:	00b26094 	umlalseq	r6, r2, r4, r0
    18fc:	e2180000 	ands	r0, r8, #0
    1900:	96000009 	strls	r0, [r0], -r9
    1904:	0000a111 	andeq	sl, r0, r1, lsl r1
    1908:	96000000 	strls	r0, [r0], -r0
                    prvAddTaskToReadyList( pxTCB );
    190c:	05000002 	streq	r0, [r0, #-2]
    1910:	57040100 	strpl	r0, [r4, -r0, lsl #2]
    1914:	0a000005 	beq	1930 <vTaskGenericNotifyGiveFromISR+0xd4>
    1918:	00000043 	andeq	r0, r0, r3, asr #32
    191c:	000c941d 	andeq	r9, ip, sp, lsl r4
    1920:	00000700 	andeq	r0, r0, r0, lsl #14
    1924:	001c1000 	andseq	r1, ip, r0
    1928:	00015e00 	andeq	r5, r1, r0, lsl #28
    192c:	000c4500 	andeq	r4, ip, r0, lsl #10
    1930:	07040100 	streq	r0, [r4, -r0, lsl #2]
    1934:	00000123 	andeq	r0, r0, r3, lsr #2
    1938:	6905040b 	stmdbvs	r5, {r0, r1, r3, sl}
    193c:	0100746e 	tsteq	r0, lr, ror #8
    1940:	00cf0508 	sbceq	r0, pc, r8, lsl #10
    1944:	08010000 	stmdaeq	r1, {}	@ <UNPREDICTABLE>
    1948:	0000f704 	andeq	pc, r0, r4, lsl #14
    194c:	06010100 	streq	r0, [r1], -r0, lsl #2
    1950:	0000010d 	andeq	r0, r0, sp, lsl #2
    1954:	0b080101 	bleq	201d60 <_etext+0x1ff890>
    1958:	01000001 	tsteq	r0, r1
    195c:	00960502 	addseq	r0, r6, r2, lsl #10
    1960:	02010000 	andeq	r0, r1, #0
    1964:	00015307 	andeq	r5, r1, r7, lsl #6
    1968:	05040100 	streq	r0, [r4, #-256]	@ 0xffffff00
    196c:	000000d4 	ldrdeq	r0, [r0], -r4
    1970:	1e070401 	cdpne	4, 0, cr0, cr7, cr1, {0}
    1974:	01000001 	tsteq	r0, r1
    1978:	01190708 	tsteq	r9, r8, lsl #14
    197c:	040c0000 	streq	r0, [ip], #-0
    1980:	14080101 	strne	r0, [r8], #-257	@ 0xfffffeff
    1984:	04000001 	streq	r0, [r0], #-1
    1988:	00000130 	andeq	r0, r0, r0, lsr r1
    198c:	65193402 	ldrvs	r3, [r9, #-1026]	@ 0xfffffbfe
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1990:	04000000 	streq	r0, [r0], #-0
    1994:	00000172 	andeq	r0, r0, r2, ror r1
    1998:	651a3c03 	ldrvs	r3, [sl, #-3075]	@ 0xfffff3fd
    199c:	04000000 	streq	r0, [r0], #-0
    19a0:	000008b1 			@ <UNDEFINED> instruction: 0x000008b1
    19a4:	7c1a4203 	lfmvc	f4, 4, [sl], {3}
    19a8:	07000000 	streq	r0, [r0, -r0]
    19ac:	00000094 	muleq	r0, r4, r0
    19b0:	0002cf08 	andeq	ip, r2, r8, lsl #30
    19b4:	08901400 	ldmeq	r0, {sl, ip}
    19b8:	000000ee 	andeq	r0, r0, lr, ror #1
    19bc:	00096402 	andeq	r6, r9, r2, lsl #8
    19c0:	94249300 	strtls	r9, [r4], #-768	@ 0xfffffd00
    19c4:	00000000 	andeq	r0, r0, r0
                    if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    19c8:	0007dd02 	andeq	sp, r7, r2, lsl #26
    19cc:	ee2d9400 	cdp	4, 2, cr9, cr13, cr0, {0}
    19d0:	04000000 	streq	r0, [r0], #-0
    19d4:	0004fb02 	andeq	pc, r4, r2, lsl #22
                        if( pxHigherPriorityTaskWoken != NULL )
    19d8:	ee2d9500 	cfsh64	mvdx9, mvdx13, #0
                            *pxHigherPriorityTaskWoken = pdTRUE;
    19dc:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
    19e0:	000aeb02 	andeq	lr, sl, r2, lsl #22
                        xYieldPendings[ 0 ] = pdTRUE;
    19e4:	730c9600 	movwvc	r9, #50688	@ 0xc600
    19e8:	0c000000 	stceq	0, cr0, [r0], {-0}
    __asm volatile
    19ec:	00090b02 	andeq	r0, r9, r2, lsl #22
    19f0:	24289700 	strtcs	r9, [r8], #-1792	@ 0xfffff900
    }
    19f4:	10000001 	andne	r0, r0, r1
    19f8:	00a50500 	adceq	r0, r5, r0, lsl #10
    19fc:	80080000 	andhi	r0, r8, r0
    1a00:	14000005 	strne	r0, [r0], #-5
    1a04:	012410ac 			@ <UNDEFINED> instruction: 0x012410ac
    1a08:	da020000 	ble	81a10 <_etext+0x7f540>
    1a0c:	af000001 	svcge	0x00000001
    1a10:	00008825 	andeq	r8, r0, r5, lsr #16
    1a14:	a1020000 	mrsge	r0, (UNDEF: 2)
    {
    1a18:	b0000002 	andlt	r0, r0, r2
    1a1c:	00017226 	andeq	r7, r1, r6, lsr #4
    1a20:	85020400 	strhi	r0, [r2, #-1024]	@ 0xfffffc00
        pxTCB = prvGetTCBFromHandle( xTask );
    1a24:	b1000006 	tstlt	r0, r6
    1a28:	00016614 	andeq	r6, r1, r4, lsl r6
    1a2c:	05000800 	streq	r0, [r0, #-2048]	@ 0xfffff800
    1a30:	000000f3 	strdeq	r0, [r0], -r3
        taskENTER_CRITICAL();
    1a34:	0006aa04 	andeq	sl, r6, r4, lsl #20
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    1a38:	1b9a0400 	blne	fe682a40 <__StackTop+0xde680a40>
    1a3c:	000000a5 	andeq	r0, r0, r5, lsr #1
    1a40:	00056508 	andeq	r6, r5, r8, lsl #10
    1a44:	0c9d0c00 	ldceq	12, cr0, [sp], {0}
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    1a48:	00000166 	andeq	r0, r0, r6, ror #2
    1a4c:	00096402 	andeq	r6, r9, r2, lsl #8
    1a50:	9428a000 	strtls	sl, [r8], #-0
                xReturn = pdPASS;
    1a54:	00000000 	andeq	r0, r0, r0
                xReturn = pdFAIL;
    1a58:	0007dd02 	andeq	sp, r7, r2, lsl #26
        taskEXIT_CRITICAL();
    1a5c:	ee31a100 	rnds	f2, f0
        return xReturn;
    1a60:	04000000 	streq	r0, [r0], #-0
    }
    1a64:	0004fb02 	andeq	pc, r4, r2, lsl #22
    1a68:	ee31a200 	cdp	2, 3, cr10, cr1, cr0, {0}
    1a6c:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
    {
    1a70:	06a60400 	strteq	r0, [r6], r0, lsl #8
    1a74:	a4040000 	strge	r0, [r4], #-0
    1a78:	00013524 	andeq	r3, r1, r4, lsr #10
        pxTCB = prvGetTCBFromHandle( xTask );
    1a7c:	01290500 			@ <UNDEFINED> instruction: 0x01290500
    1a80:	72070000 	andvc	r0, r7, #0
    1a84:	04000001 	streq	r0, [r0], #-1
    1a88:	0000089d 	muleq	r0, sp, r8
        taskENTER_CRITICAL();
    1a8c:	f303b304 	vcgt.u8	d11, d3, d4
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    1a90:	0d000000 	stceq	0, cr0, [r0, #-0]
    1a94:	0000040c 	andeq	r0, r0, ip, lsl #8
    1a98:	880dd901 	stmdahi	sp, {r0, r8, fp, ip, lr, pc}
    1a9c:	1c000000 	stcne	0, cr0, [r0], {-0}
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    1aa0:	5200001d 	andpl	r0, r0, #29
    1aa4:	01000000 	mrseq	r0, (UNDEF: 0)
    1aa8:	0001bf9c 	muleq	r1, ip, pc	@ <UNPREDICTABLE>
    1aac:	0cae0300 	stceq	3, cr0, [lr]
    1ab0:	2ed90000 	cdpcs	0, 13, cr0, cr9, cr0, {0}
    1ab4:	00000177 	andeq	r0, r0, r7, ror r1
    1ab8:	066c9102 	strbteq	r9, [ip], -r2, lsl #2
        taskEXIT_CRITICAL();
    1abc:	00000c29 	andeq	r0, r0, r9, lsr #24
        return ulReturn;
    1ac0:	01c414dd 	ldrdeq	r1, [r4, #77]	@ 0x4d
    }
    1ac4:	91020000 	mrsls	r0, (UNDEF: 2)
    1ac8:	7c050074 	stcvc	0, cr0, [r5], {116}	@ 0x74
    1acc:	07000001 	streq	r0, [r0, -r1]
{
    1ad0:	000001bf 			@ <UNDEFINED> instruction: 0x000001bf
    1ad4:	000acb09 	andeq	ip, sl, r9, lsl #22
    1ad8:	1cac8b00 	vstmiane	ip!, {d8-d7}
    const TickType_t xConstTickCount = xTickCount;
    1adc:	00700000 	rsbseq	r0, r0, r0
    List_t * const pxDelayedList = pxDelayedTaskList;
    1ae0:	9c010000 	stcls	0, cr0, [r1], {-0}
    1ae4:	00000216 	andeq	r0, r0, r6, lsl r2
    List_t * const pxOverflowDelayedList = pxOverflowDelayedTaskList;
    1ae8:	000c2903 	andeq	r2, ip, r3, lsl #18
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1aec:	c4228b00 	strtgt	r8, [r2], #-2816	@ 0xfffff500
    1af0:	02000001 	andeq	r0, r0, #1
    1af4:	f0036c91 			@ <UNDEFINED> instruction: 0xf0036c91
    1af8:	8c00000c 	stchi	0, cr0, [r0], {12}
    1afc:	00017726 	andeq	r7, r1, r6, lsr #14
        portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
    1b00:	68910200 	ldmvs	r1, {r9}
    1b04:	000ce506 	andeq	lr, ip, r6, lsl #10
    1b08:	72128e00 	andsvc	r8, r2, #0, 28
    1b0c:	02000001 	andeq	r0, r0, #1
    1b10:	cc067491 	cfstrsgt	mvf7, [r6], {145}	@ 0x91
    1b14:	8f00000c 	svchi	0x0000000c
        xTimeToWake = xConstTickCount + xTicksToWait;
    1b18:	0000a016 	andeq	sl, r0, r6, lsl r0
    1b1c:	70910200 	addsvc	r0, r1, r0, lsl #4
        listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    1b20:	0cbd0900 			@ <UNDEFINED> instruction: 0x0cbd0900
    1b24:	66690000 	strbtvs	r0, [r9], -r0
        if( xTimeToWake < xConstTickCount )
    1b28:	4600001c 			@ <UNDEFINED> instruction: 0x4600001c
    1b2c:	01000000 	mrseq	r0, (UNDEF: 0)
            vListInsert( pxOverflowDelayedList, &( pxCurrentTCB->xStateListItem ) );
    1b30:	0002559c 	muleq	r2, ip, r5
    1b34:	0c290300 	stceq	3, cr0, [r9], #-0
    1b38:	25690000 	strbcs	r0, [r9, #-0]!
}
    1b3c:	000001c4 	andeq	r0, r0, r4, asr #3
            vListInsert( pxDelayedList, &( pxCurrentTCB->xStateListItem ) );
    1b40:	036c9102 	cmneq	ip, #-2147483648	@ 0x80000000
    1b44:	00000cf0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
    1b48:	0177296a 	cmneq	r7, sl, ror #18
            if( xTimeToWake < xNextTaskUnblockTime )
    1b4c:	91020000 	mrsls	r0, (UNDEF: 2)
    1b50:	02a10668 	adceq	r0, r1, #104, 12	@ 0x6800000
    1b54:	186c0000 	stmdane	ip!, {}^	@ <UNPREDICTABLE>
                xNextTaskUnblockTime = xTimeToWake;
    1b58:	00000177 	andeq	r0, r0, r7, ror r1
}
    1b5c:	00749102 	rsbseq	r9, r4, r2, lsl #2
    1b60:	00093b09 	andeq	r3, r9, r9, lsl #22
    1b64:	1c4e5900 	mcrrne	9, 0, r5, lr, cr0	@ <UNPREDICTABLE>
    1b68:	00180000 	andseq	r0, r8, r0
    1b6c:	9c010000 	stcls	0, cr0, [r1], {-0}
    1b70:	00000278 	andeq	r0, r0, r8, ror r2
    1b74:	000cde03 	andeq	sp, ip, r3, lsl #28
    1b78:	772e5900 	strvc	r5, [lr, -r0, lsl #18]!
{
    1b7c:	02000001 	andeq	r0, r0, #1
    1b80:	0e007491 	mcreq	4, 0, r7, cr0, cr1, {4}
        pxCurrentTCB = NULL;
    1b84:	00000aad 	andeq	r0, r0, sp, lsr #21
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
    1b88:	10063101 	andne	r3, r6, r1, lsl #2
    1b8c:	3e00001c 	mcrcc	0, 0, r0, cr0, cr12, {0}
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    1b90:	01000000 	mrseq	r0, (UNDEF: 0)
    uxTopReadyPriority = tskIDLE_PRIORITY;
    1b94:	0c29039c 	stceq	3, cr0, [r9], #-624	@ 0xfffffd90
    1b98:	26310000 	ldrtcs	r0, [r1], -r0
    xSchedulerRunning = pdFALSE;
    1b9c:	000001c4 	andeq	r0, r0, r4, asr #3
    xPendedTicks = ( TickType_t ) 0U;
    1ba0:	00749102 	rsbseq	r9, r4, r2, lsl #2
    1ba4:	0004a800 	andeq	sl, r4, r0, lsl #16
    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    1ba8:	01000500 	tsteq	r0, r0, lsl #10
        xYieldPendings[ xCoreID ] = pdFALSE;
    1bac:	00064304 	andeq	r4, r6, r4, lsl #6
    1bb0:	00431000 	subeq	r1, r3, r0
    1bb4:	f31d0000 	vhadd.u16	d0, d13, d0
    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    1bb8:	0700000e 	streq	r0, [r0, -lr]
    1bbc:	70000000 	andvc	r0, r0, r0
    1bc0:	e800001d 	stmda	r0, {r0, r2, r3, r4}
    xNumOfOverflows = ( BaseType_t ) 0;
    1bc4:	f5000004 			@ <UNDEFINED> instruction: 0xf5000004
    uxTaskNumber = ( UBaseType_t ) 0U;
    1bc8:	0500000d 	streq	r0, [r0, #-13]
    1bcc:	00000198 	muleq	r0, r8, r1
    xNextTaskUnblockTime = ( TickType_t ) 0U;
    1bd0:	3717d602 	ldrcc	sp, [r7, -r2, lsl #12]
    uxSchedulerSuspended = ( UBaseType_t ) 0U;
    1bd4:	11000000 	mrsne	r0, (UNDEF: 0)
    1bd8:	00000026 	andeq	r0, r0, r6, lsr #32
}
    1bdc:	23070402 	movwcs	r0, #29698	@ 0x7402
    1be0:	12000001 	andne	r0, r0, #1
    1be4:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    1be8:	08020074 	stmdaeq	r2, {r2, r4, r5, r6}
    1bec:	0000cf05 	andeq	ip, r0, r5, lsl #30
    1bf0:	04080200 	streq	r0, [r8], #-512	@ 0xfffffe00
    1bf4:	000000f7 	strdeq	r0, [r0], -r7
    1bf8:	0d060102 	stfeqs	f0, [r6, #-8]
    1bfc:	02000001 	andeq	r0, r0, #1
    1c00:	010b0801 	tsteq	fp, r1, lsl #16
    1c04:	02020000 	andeq	r0, r2, #0
    1c08:	00009605 	andeq	r9, r0, r5, lsl #12
    1c0c:	07020200 	streq	r0, [r2, -r0, lsl #4]
{
    1c10:	00000153 	andeq	r0, r0, r3, asr r1
    1c14:	d4050402 	strle	r0, [r5], #-1026	@ 0xfffffbfe
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );
    1c18:	02000000 	andeq	r0, r0, #0
    1c1c:	011e0704 	tsteq	lr, r4, lsl #14
    1c20:	08020000 	stmdaeq	r2, {}	@ <UNPREDICTABLE>
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    1c24:	00011907 	andeq	r1, r1, r7, lsl #18
    1c28:	02041300 	andeq	r1, r4, #0, 6
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );
    1c2c:	01140801 	tsteq	r4, r1, lsl #16
    1c30:	ce050000 	cdpgt	0, 0, cr0, cr5, cr0, {0}
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );
    1c34:	03000006 	movweq	r0, #6
    1c38:	005a182e 	subseq	r1, sl, lr, lsr #16
    1c3c:	30050000 	andcc	r0, r5, r0
    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1c40:	03000001 	movweq	r0, #1
}
    1c44:	00761934 	rsbseq	r1, r6, r4, lsr r9
    1c48:	73050000 	movwvc	r0, #20480	@ 0x5000
    1c4c:	04000001 	streq	r0, [r0], #-1
{
    1c50:	006f1a3b 	rsbeq	r1, pc, fp, lsr sl	@ <UNPREDICTABLE>
    1c54:	b1050000 	mrslt	r0, (UNDEF: 5)
    pxItem->pxContainer = NULL;
    1c58:	04000008 	streq	r0, [r0], #-8
}
    1c5c:	00991a42 	addseq	r1, r9, r2, asr #20
    1c60:	8d060000 	stchi	0, cr0, [r6, #-0]
    1c64:	0b000000 	bleq	1c6c <vListInsertEnd+0x6>
{
    1c68:	00000d0f 	andeq	r0, r0, pc, lsl #26
    1c6c:	2a9c051c 	bcs	fe7030e4 <__StackTop+0xde7010e4>
    ListItem_t * const pxIndex = pxList->pxIndex;
    1c70:	04000001 	streq	r0, [r0], #-1
    1c74:	00000ebb 			@ <UNDEFINED> instruction: 0x00000ebb
    pxNewListItem->pxNext = pxIndex;
    1c78:	260c9e05 	strcs	r9, [ip], -r5, lsl #28
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1c7c:	00000000 	andeq	r0, r0, r0
    1c80:	000f3404 	andeq	r3, pc, r4, lsl #8
    pxIndex->pxPrevious->pxNext = pxNewListItem;
    1c84:	0c9f0500 	cfldr32eq	mvfx0, [pc], {0}
    1c88:	00000026 	andeq	r0, r0, r6, lsr #32
    pxIndex->pxPrevious = pxNewListItem;
    1c8c:	0dcd0404 	cfstrdeq	mvd0, [sp, #16]
    1c90:	a0050000 	andge	r0, r5, r0
    pxNewListItem->pxContainer = pxList;
    1c94:	0000260c 	andeq	r2, r0, ip, lsl #12
    ( pxList->uxNumberOfItems ) = ( UBaseType_t ) ( pxList->uxNumberOfItems + 1U );
    1c98:	56040800 	strpl	r0, [r4], -r0, lsl #16
    1c9c:	0500000d 	streq	r0, [r0, #-13]
    1ca0:	00260ca1 	eoreq	r0, r6, r1, lsr #25
}
    1ca4:	040c0000 	streq	r0, [ip], #-0
    1ca8:	00000d1a 	andeq	r0, r0, sl, lsl sp
{
    1cac:	260ca205 	strcs	sl, [ip], -r5, lsl #4
    1cb0:	10000000 	andne	r0, r0, r0
    1cb4:	000e9c04 	andeq	r9, lr, r4, lsl #24
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1cb8:	0ca30500 	cfstr32eq	mvfx0, [r3]
    if( xValueOfInsertion == portMAX_DELAY )
    1cbc:	00000026 	andeq	r0, r0, r6, lsr #32
    1cc0:	0f8e0414 	svceq	0x008e0414
        pxIterator = pxList->xListEnd.pxPrevious;
    1cc4:	a4050000 	strge	r0, [r5], #-0
    1cc8:	0000260c 	andeq	r2, r0, ip, lsl #12
        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1ccc:	05001800 	streq	r1, [r0, #-2048]	@ 0xfffff800
    1cd0:	00000d39 	andeq	r0, r0, r9, lsr sp
    1cd4:	c203a505 	andgt	sl, r3, #20971520	@ 0x1400000
    1cd8:	14000000 	strne	r0, [r0], #-0
    1cdc:	0000008d 	andeq	r0, r0, sp, lsl #1
    1ce0:	00000147 	andeq	r0, r0, r7, asr #2
    1ce4:	00003715 	andeq	r3, r0, r5, lsl r7
    pxNewListItem->pxNext = pxIterator->pxNext;
    1ce8:	000fff00 	andeq	pc, pc, r0, lsl #30
    1cec:	00101201 	andseq	r1, r0, r1, lsl #4
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1cf0:	36245f00 	strtcc	r5, [r4], -r0, lsl #30
    1cf4:	05000001 	streq	r0, [r0, #-1]
    pxNewListItem->pxPrevious = pxIterator;
    1cf8:	0000dc03 	andeq	sp, r0, r3, lsl #24
    pxIterator->pxNext = pxNewListItem;
    1cfc:	0db10b20 			@ <UNDEFINED> instruction: 0x0db10b20
    1d00:	01080000 	mrseq	r0, (UNDEF: 8)
    pxNewListItem->pxContainer = pxList;
    1d04:	00017f64 	andeq	r7, r1, r4, ror #30
    ( pxList->uxNumberOfItems ) = ( UBaseType_t ) ( pxList->uxNumberOfItems + 1U );
    1d08:	0f6f0400 	svceq	0x006f0400
    1d0c:	66010000 	strvs	r0, [r1], -r0
    1d10:	00017f1b 	andeq	r7, r1, fp, lsl pc
}
    1d14:	a7040000 	strge	r0, [r4, -r0]
    1d18:	0100000f 	tsteq	r0, pc
{
    1d1c:	00260c67 	eoreq	r0, r6, r7, ror #24
    1d20:	00040000 	andeq	r0, r4, r0
    List_t * const pxList = pxItemToRemove->pxContainer;
    1d24:	00015806 	andeq	r5, r1, r6, lsl #16
    1d28:	0e900500 	cdpeq	5, 9, cr0, cr0, cr0, {0}
    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1d2c:	68010000 	stmdavs	r1, {}	@ <UNPREDICTABLE>
    1d30:	00015803 	andeq	r5, r1, r3, lsl #16
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1d34:	0ed60100 	cdpeq	1, 13, cr0, cr6, cr0, {0}
    1d38:	159e0000 	ldrne	r0, [lr]
    1d3c:	00000032 	andeq	r0, r0, r2, lsr r0
    if( pxList->pxIndex == pxItemToRemove )
    1d40:	24cc0305 	strbcs	r0, [ip], #773	@ 0x305
    1d44:	b2010000 	andlt	r0, r1, #0
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    1d48:	a100000f 	tstge	r0, pc
    1d4c:	00018424 	andeq	r8, r1, r4, lsr #8
    pxItemToRemove->pxContainer = NULL;
    1d50:	dc030500 	cfstr32le	mvfx0, [r3], {-0}
    1d54:	01200010 			@ <UNDEFINED> instruction: 0x01200010
    ( pxList->uxNumberOfItems ) = ( UBaseType_t ) ( pxList->uxNumberOfItems - 1U );
    1d58:	00000d6a 	andeq	r0, r0, sl, ror #26
    1d5c:	01c326a2 	biceq	r2, r3, r2, lsr #13
    return pxList->uxNumberOfItems;
    1d60:	03050000 	movweq	r0, #20480	@ 0x5000
}
    1d64:	200010e4 	andcs	r1, r0, r4, ror #1
    1d68:	00018406 	andeq	r8, r1, r6, lsl #8
    1d6c:	0f200100 	svceq	0x00200100
{
    1d70:	1fa60000 	svcne	0x00a60000
    1d74:	00000026 	andeq	r0, r0, r6, lsr #32
    void * pvReturn = NULL;
    1d78:	10e80305 	rscne	r0, r8, r5, lsl #6
    size_t xAllocatedBlockSize = 0;
    1d7c:	1a012000 	bne	49d84 <_etext+0x478b4>
    if( xWantedSize > 0 )
    1d80:	a700000d 	strge	r0, [r0, -sp]
    1d84:	0000261f 	andeq	r2, r0, pc, lsl r6
        if( heapADD_WILL_OVERFLOW( xWantedSize, xHeapStructSize ) == 0 )
    1d88:	ec030500 	cfstr32	mvfx0, [r3], {-0}
    1d8c:	01200010 			@ <UNDEFINED> instruction: 0x01200010
            xWantedSize += xHeapStructSize;
    1d90:	00000e9c 	muleq	r0, ip, lr
    1d94:	00261fa8 	eoreq	r1, r6, r8, lsr #31
            if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
    1d98:	03050000 	movweq	r0, #20480	@ 0x5000
    1d9c:	200010f0 	strdcs	r1, [r0], -r0
    1da0:	000f8e01 	andeq	r8, pc, r1, lsl #28
                xAdditionalRequiredSize = portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK );
    1da4:	261fa900 	ldrcs	sl, [pc], -r0, lsl #18
    1da8:	05000000 	streq	r0, [r0, #-0]
    1dac:	0010f403 	andseq	pc, r0, r3, lsl #8
                if( heapADD_WILL_OVERFLOW( xWantedSize, xAdditionalRequiredSize ) == 0 )
    1db0:	01ea0c20 	mvneq	r0, r0, lsr #24
    1db4:	0c740000 	ldcleq	0, cr0, [r4], #-0
                    xWantedSize += xAdditionalRequiredSize;
    1db8:	0000039f 	muleq	r0, pc, r3	@ <UNPREDICTABLE>
    1dbc:	01c01673 	biceq	r1, r0, r3, ror r6
    1dc0:	21070000 	mrscs	r0, (UNDEF: 7)
                    xWantedSize = 0;
    1dc4:	00008409 	andeq	r8, r0, r9, lsl #8
            xWantedSize = 0;
    1dc8:	00023800 	andeq	r3, r2, r0, lsl #16
    vTaskSuspendAll();
    1dcc:	00840800 	addeq	r0, r4, r0, lsl #16
        if( pxEnd == NULL )
    1dd0:	3e080000 	cdpcc	0, 0, cr0, cr8, cr0, {0}
    1dd4:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
            prvHeapInit();
    1dd8:	00000026 	andeq	r0, r0, r6, lsr #32
        if( heapBLOCK_SIZE_IS_VALID( xWantedSize ) != 0 )
    1ddc:	096f1700 	stmdbeq	pc!, {r8, r9, sl, ip}^	@ <UNPREDICTABLE>
    1de0:	96060000 	strls	r0, [r6], -r0
            if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    1de4:	00a50c06 	adceq	r0, r5, r6, lsl #24
    1de8:	2f180000 	svccs	0x00180000
    1dec:	06000005 	streq	r0, [r0], -r5
    1df0:	0906065e 	stmdbeq	r6, {r1, r2, r3, r4, r6, r9, sl}
                pxPreviousBlock = &xStart;
    1df4:	00000e53 	andeq	r0, r0, r3, asr lr
                pxBlock = heapPROTECT_BLOCK_POINTER( xStart.pxNextFreeBlock );
    1df8:	22180275 	andscs	r0, r8, #1342177287	@ 0x50000007
                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != heapPROTECT_BLOCK_POINTER( NULL ) ) )
    1dfc:	00400000 	subeq	r0, r0, r0
                    pxPreviousBlock = pxBlock;
    1e00:	9c010000 	stcls	0, cr0, [r1], {-0}
                    pxBlock = heapPROTECT_BLOCK_POINTER( pxBlock->pxNextFreeBlock );
    1e04:	000ff90d 	andeq	pc, pc, sp, lsl #18
                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != heapPROTECT_BLOCK_POINTER( NULL ) ) )
    1e08:	5c023c00 	stcpl	12, cr3, [r2], {-0}
    1e0c:	bc000021 	stclt	0, cr0, [r0], {33}	@ 0x21
    1e10:	01000000 	mrseq	r0, (UNDEF: 0)
    1e14:	0002c09c 	muleq	r2, ip, r0
    1e18:	0d0e0700 	stceq	7, cr0, [lr, #-0]
                if( pxBlock != pxEnd )
    1e1c:	023c0000 	eorseq	r0, ip, #0
    1e20:	0002c027 	andeq	ip, r2, r7, lsr #32
                    pvReturn = ( void * ) ( ( ( uint8_t * ) heapPROTECT_BLOCK_POINTER( pxPreviousBlock->pxNextFreeBlock ) ) + xHeapStructSize );
    1e24:	64910200 	ldrvs	r0, [r1], #512	@ 0x200
    1e28:	000d4503 	andeq	r4, sp, r3, lsl #10
    1e2c:	13023e00 	movwne	r3, #11776	@ 0x2e00
                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1e30:	000001c3 	andeq	r0, r0, r3, asr #3
    1e34:	03749102 	cmneq	r4, #-2147483648	@ 0x80000000
                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1e38:	00000fb9 			@ <UNDEFINED> instruction: 0x00000fb9
    1e3c:	260c023f 			@ <UNDEFINED> instruction: 0x260c023f
    1e40:	02000000 	andeq	r0, r0, #0
    1e44:	67037091 			@ <UNDEFINED> instruction: 0x67037091
                        pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    1e48:	3f00000e 	svccc	0x0000000e
    1e4c:	00261902 	eoreq	r1, r6, r2, lsl #18
                        pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1e50:	91020000 	mrsls	r0, (UNDEF: 2)
    1e54:	0d4d036c 	stcleq	3, cr0, [sp, #-432]	@ 0xfffffe50
    1e58:	023f0000 	eorseq	r0, pc, #0
                        pxBlock->xBlockSize = xWantedSize;
    1e5c:	00002627 	andeq	r2, r0, r7, lsr #12
                        pxNewBlockLink->pxNextFreeBlock = pxPreviousBlock->pxNextFreeBlock;
    1e60:	68910200 	ldmvs	r1, {r9}
    1e64:	012a0600 			@ <UNDEFINED> instruction: 0x012a0600
                        pxPreviousBlock->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxNewBlockLink );
    1e68:	700e0000 	andvc	r0, lr, r0
    1e6c:	f800000d 			@ <UNDEFINED> instruction: 0xf800000d
                    xFreeBytesRemaining -= pxBlock->xBlockSize;
    1e70:	0020ac01 	eoreq	sl, r0, r1, lsl #24
    1e74:	0000b000 	andeq	fp, r0, r0
    1e78:	089c0100 	ldmeq	ip, {r8}
                    if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    1e7c:	07000003 	streq	r0, [r0, -r3]
    1e80:	00000f5f 	andeq	r0, r0, pc, asr pc
    1e84:	c33701f8 	teqgt	r7, #248, 2	@ 0x3e
                        xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    1e88:	02000001 	andeq	r0, r0, #1
    1e8c:	e5036c91 	str	r6, [r3, #-3217]	@ 0xfffff36f
                    xAllocatedBlockSize = pxBlock->xBlockSize;
    1e90:	fa00000c 	blx	1ec8 <pvPortMalloc+0x158>
    1e94:	01c31301 	biceq	r1, r3, r1, lsl #6
                    heapALLOCATE_BLOCK( pxBlock );
    1e98:	91020000 	mrsls	r0, (UNDEF: 2)
    1e9c:	75700a74 	ldrbvc	r0, [r0, #-2676]!	@ 0xfffff58c
    1ea0:	01fb0063 	mvnseq	r0, r3, rrx
                    pxBlock->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( NULL );
    1ea4:	0000bd0f 	andeq	fp, r0, pc, lsl #26
                    xNumberOfSuccessfulAllocations++;
    1ea8:	70910200 	addsvc	r0, r1, r0, lsl #4
    1eac:	0f530e00 	svceq	0x00530e00
    1eb0:	01c80000 	biceq	r0, r8, r0
    ( void ) xTaskResumeAll();
    1eb4:	00001ff8 	strdeq	r1, [r0], -r8
}
    1eb8:	000000b4 	strheq	r0, [r0], -r4
    1ebc:	035a9c01 	cmpeq	sl, #256	@ 0x100
    1ec0:	c6030000 	strgt	r0, [r3], -r0
    1ec4:	ca00000f 	bgt	1f08 <vPortFree+0x34>
    1ec8:	01c31301 	biceq	r1, r3, r1, lsl #6
    1ecc:	91020000 	mrsls	r0, (UNDEF: 2)
    1ed0:	0dbe0368 	ldceq	3, cr0, [lr, #416]!	@ 0x1a0
{
    1ed4:	01cb0000 	biceq	r0, fp, r0
    1ed8:	0000991b 	andeq	r9, r0, fp, lsl r9
    uint8_t * puc = ( uint8_t * ) pv;
    1edc:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
    if( pv != NULL )
    1ee0:	000e0103 	andeq	r0, lr, r3, lsl #2
    1ee4:	2b01cb00 	blcs	74aec <_etext+0x7261c>
        puc -= xHeapStructSize;
    1ee8:	00000099 	muleq	r0, r9, r0
    1eec:	036c9102 	cmneq	ip, #-2147483648	@ 0x80000000
        pxLink = ( void * ) puc;
    1ef0:	00000f7f 	andeq	r0, r0, pc, ror pc
        if( heapBLOCK_IS_ALLOCATED( pxLink ) != 0 )
    1ef4:	260c01cc 	strcs	r0, [ip], -ip, asr #3
    1ef8:	02000000 	andeq	r0, r0, #0
            if( pxLink->pxNextFreeBlock == heapPROTECT_BLOCK_POINTER( NULL ) )
    1efc:	19007091 	stmdbne	r0, {r0, r4, r7, ip, sp, lr}
    1f00:	00000ee6 	andeq	r0, r0, r6, ror #29
                heapFREE_BLOCK( pxLink );
    1f04:	0801b501 	stmdaeq	r1, {r0, r8, sl, ip, sp, pc}
    1f08:	00000084 	andeq	r0, r0, r4, lsl #1
    1f0c:	00001f98 	muleq	r0, r8, pc	@ <UNPREDICTABLE>
                vTaskSuspendAll();
    1f10:	00000060 	andeq	r0, r0, r0, rrx
                    xFreeBytesRemaining += pxLink->xBlockSize;
    1f14:	03a29c01 			@ <UNDEFINED> instruction: 0x03a29c01
    1f18:	c1070000 	mrsgt	r0, (UNDEF: 7)
    1f1c:	b500000f 	strlt	r0, [r0, #-15]
    1f20:	00261d01 	eoreq	r1, r6, r1, lsl #26
                    prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    1f24:	91020000 	mrsls	r0, (UNDEF: 2)
                    xNumberOfSuccessfulFrees++;
    1f28:	0e6a076c 	cdpeq	7, 6, cr0, cr10, cr12, {3}
    1f2c:	01b60000 			@ <UNDEFINED> instruction: 0x01b60000
    1f30:	0000261d 	andeq	r2, r0, sp, lsl r6
                ( void ) xTaskResumeAll();
    1f34:	68910200 	ldmvs	r1, {r9}
}
    1f38:	0076700a 	rsbseq	r7, r6, sl
    1f3c:	840c01b8 	strhi	r0, [ip], #-440	@ 0xfffffe48
    1f40:	02000000 	andeq	r0, r0, #0
    1f44:	09007491 	stmdbeq	r0, {r0, r4, r7, sl, ip, sp, lr}
{
    1f48:	00000fe3 	andeq	r0, r0, r3, ror #31
    return xFreeBytesRemaining;
    1f4c:	1f8c01af 	svcne	0x008c01af
}
    1f50:	000c0000 	andeq	r0, ip, r0
    1f54:	9c010000 	stcls	0, cr0, [r1], {-0}
    1f58:	000d8b09 	andeq	r8, sp, r9, lsl #22
{
    1f5c:	7001a900 	andvc	sl, r1, r0, lsl #18
    return xMinimumEverFreeBytesRemaining;
    1f60:	1c00001f 	stcne	0, cr0, [r0], {31}
}
    1f64:	01000000 	mrseq	r0, (UNDEF: 0)
    1f68:	0e700f9c 	mrceq	15, 3, r0, cr0, cr12, {4}
    1f6c:	01a30000 			@ <UNDEFINED> instruction: 0x01a30000
{
    1f70:	00000026 	andeq	r0, r0, r6, lsr #32
    xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    1f74:	00001f5c 	andeq	r1, r0, ip, asr pc
    1f78:	00000014 	andeq	r0, r0, r4, lsl r0
}
    1f7c:	1d0f9c01 	stcne	12, cr9, [pc, #-4]	@ 1f80 <xPortResetHeapMinimumEverFreeHeapSize+0x10>
    1f80:	9d00000e 	stcls	0, cr0, [r0, #-56]	@ 0xffffffc8
    1f84:	00002601 	andeq	r2, r0, r1, lsl #12
    1f88:	001f4800 	andseq	r4, pc, r0, lsl #16
{
    1f8c:	00001400 	andeq	r1, r0, r0, lsl #8
}
    1f90:	0d9c0100 	ldfeqs	f0, [ip]
    1f94:	000009c5 	andeq	r0, r0, r5, asr #19
{
    1f98:	1ed40162 	cdpne	1, 13, cr0, cr4, cr2, {3}
    1f9c:	00740000 	rsbseq	r0, r4, r0
    1fa0:	9c010000 	stcls	0, cr0, [r1], {-0}
    void * pv = NULL;
    1fa4:	00000431 	andeq	r0, r0, r1, lsr r4
    if( heapMULTIPLY_WILL_OVERFLOW( xNum, xSize ) == 0 )
    1fa8:	0076701a 	rsbseq	r7, r6, sl, lsl r0
    1fac:	18016201 	stmdane	r1, {r0, r9, sp, lr}
    1fb0:	00000084 	andeq	r0, r0, r4, lsl #1
    1fb4:	0a6c9102 	beq	1b263c4 <_etext+0x1b23ef4>
    1fb8:	00637570 	rsbeq	r7, r3, r0, ror r5
    1fbc:	bd0f0164 	stflts	f0, [pc, #-400]	@ 1e34 <pvPortMalloc+0xc4>
    1fc0:	02000000 	andeq	r0, r0, #0
    1fc4:	0b037491 	bleq	df210 <_etext+0xdcd40>
        pv = pvPortMalloc( xNum * xSize );
    1fc8:	65000010 	strvs	r0, [r0, #-16]
    1fcc:	01c31301 	biceq	r1, r3, r1, lsl #6
    1fd0:	91020000 	mrsls	r0, (UNDEF: 2)
    1fd4:	0a1b0070 	beq	6c219c <_etext+0x6bfccc>
        if( pv != NULL )
    1fd8:	0100000c 	tsteq	r0, ip
            ( void ) memset( pv, 0, xNum * xSize );
    1fdc:	008408ad 	addeq	r0, r4, sp, lsr #17
    1fe0:	1d700000 	ldclne	0, cr0, [r0, #-0]
    1fe4:	01640000 	cmneq	r4, r0
    1fe8:	9c010000 	stcls	0, cr0, [r1], {-0}
    1fec:	000fd71c 	andeq	sp, pc, ip, lsl r7	@ <UNPREDICTABLE>
}
    1ff0:	1dad0100 	stfnes	f0, [sp]
    1ff4:	00000026 	andeq	r0, r0, r6, lsr #32
{
    1ff8:	015c9102 	cmpeq	ip, r2, lsl #2
    1ffc:	00000d45 	andeq	r0, r0, r5, asr #26
    size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
    2000:	01c313af 	biceq	r1, r3, pc, lsr #7
    uxStartAddress = ( portPOINTER_SIZE_TYPE ) ucHeap;
    2004:	91020000 	mrsls	r0, (UNDEF: 2)
    if( ( uxStartAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
    2008:	0cfe0174 	ldfeqe	f0, [lr], #464	@ 0x1d0
    200c:	13b00000 	movsne	r0, #0
    2010:	000001c3 	andeq	r0, r0, r3, asr #3
        uxStartAddress += ( portBYTE_ALIGNMENT - 1 );
    2014:	01709102 	cmneq	r0, r2, lsl #2
        uxStartAddress &= ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK );
    2018:	00000e0e 	andeq	r0, r0, lr, lsl #28
    201c:	01c313b1 	strheq	r1, [r3, #49]	@ 0x31
        xTotalHeapSize -= ( size_t ) ( uxStartAddress - ( portPOINTER_SIZE_TYPE ) ucHeap );
    2020:	91020000 	mrsls	r0, (UNDEF: 2)
    2024:	0e4a0160 	dvfeqez	f0, f2, f0
    2028:	0cb20000 	ldceq	0, cr0, [r2]
    xStart.pxNextFreeBlock = ( void * ) heapPROTECT_BLOCK_POINTER( uxStartAddress );
    202c:	00000084 	andeq	r0, r0, r4, lsl #1
    2030:	016c9102 	cmneq	ip, r2, lsl #2
    xStart.xBlockSize = ( size_t ) 0;
    2034:	00000e32 	andeq	r0, r0, r2, lsr lr
    uxEndAddress = uxStartAddress + ( portPOINTER_SIZE_TYPE ) xTotalHeapSize;
    2038:	00260cb3 	strhteq	r0, [r6], -r3
    203c:	91020000 	mrsls	r0, (UNDEF: 2)
    uxEndAddress -= ( portPOINTER_SIZE_TYPE ) xHeapStructSize;
    2040:	0ded0164 	stfeqe	f0, [sp, #400]!	@ 0x190
    2044:	0cb40000 	ldceq	0, cr0, [r4]
    uxEndAddress &= ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK );
    2048:	00000026 	andeq	r0, r0, r6, lsr #32
    204c:	00689102 	rsbeq	r9, r8, r2, lsl #2
    pxEnd = ( BlockLink_t * ) uxEndAddress;
    2050:	00030700 	andeq	r0, r3, r0, lsl #14
    2054:	01000500 	tsteq	r0, r0, lsl #10
    pxEnd->xBlockSize = 0;
    2058:	00083604 	andeq	r3, r8, r4, lsl #12
    205c:	00430c00 	subeq	r0, r3, r0, lsl #24
    pxEnd->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( NULL );
    2060:	8b1d0000 	blhi	742068 <_etext+0x73fb98>
    2064:	07000010 	smladeq	r0, r0, r0, r0
    pxFirstFreeBlock = ( BlockLink_t * ) uxStartAddress;
    2068:	58000000 	stmdapl	r0, {}	@ <UNPREDICTABLE>
    pxFirstFreeBlock->xBlockSize = ( size_t ) ( uxEndAddress - ( portPOINTER_SIZE_TYPE ) pxFirstFreeBlock );
    206c:	60000022 	andvs	r0, r0, r2, lsr #32
    2070:	a5000002 	strge	r0, [r0, #-2]
    pxFirstFreeBlock->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxEnd );
    2074:	0d000011 	stceq	0, cr0, [r0, #-68]	@ 0xffffffbc
    2078:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    207c:	04010074 	streq	r0, [r1], #-116	@ 0xffffff8c
    2080:	00012307 	andeq	r2, r1, r7, lsl #6
    xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    2084:	05080100 	streq	r0, [r8, #-256]	@ 0xffffff00
    2088:	000000cf 	andeq	r0, r0, pc, asr #1
}
    208c:	f7040801 			@ <UNDEFINED> instruction: 0xf7040801
    2090:	01000000 	mrseq	r0, (UNDEF: 0)
    2094:	010d0601 	tsteq	sp, r1, lsl #12
    2098:	02010000 	andeq	r0, r1, #0
    209c:	00009605 	andeq	r9, r0, r5, lsl #12
    20a0:	05040100 	streq	r0, [r4, #-256]	@ 0xffffff00
    20a4:	000000d4 	ldrdeq	r0, [r0], -r4
    20a8:	0b080101 	bleq	2024b4 <_etext+0x1fffe4>
{
    20ac:	01000001 	tsteq	r0, r1
    20b0:	01530702 	cmpeq	r3, r2, lsl #14
    for( pxIterator = &xStart; heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) < pxBlockToInsert; pxIterator = heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) )
    20b4:	30020000 	andcc	r0, r2, r0
    20b8:	03000001 	movweq	r0, #1
    20bc:	00761934 	rsbseq	r1, r6, r4, lsr r9
    20c0:	650e0000 	strvs	r0, [lr, #-0]
    20c4:	01000000 	mrseq	r0, (UNDEF: 0)
    20c8:	011e0704 	tsteq	lr, r4, lsl #14
    puc = ( uint8_t * ) pxIterator;
    20cc:	08010000 	stmdaeq	r1, {}	@ <UNPREDICTABLE>
    if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    20d0:	00011907 	andeq	r1, r1, r7, lsl #18
    20d4:	00340200 	eorseq	r0, r4, r0, lsl #4
    20d8:	24040000 	strcs	r0, [r4], #-0
        pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    20dc:	00009011 	andeq	r9, r0, r1, lsl r0
    20e0:	00950300 	addseq	r0, r5, r0, lsl #6
    20e4:	a00f0000 	andge	r0, pc, r0
    20e8:	10000000 	andne	r0, r0, r0
        pxBlockToInsert = pxIterator;
    20ec:	000000a0 	andeq	r0, r0, r0, lsr #1
    puc = ( uint8_t * ) pxBlockToInsert;
    20f0:	02041100 	andeq	r1, r4, #0, 2
    if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) )
    20f4:	0000017e 	andeq	r0, r0, lr, ror r1
    20f8:	651a3a02 	ldrvs	r3, [sl, #-2562]	@ 0xfffff5fe
    20fc:	02000000 	andeq	r0, r0, #0
    2100:	00000173 	andeq	r0, r0, r3, ror r1
        if( heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) != pxEnd )
    2104:	501a3b02 	andspl	r3, sl, r2, lsl #22
    2108:	02000000 	andeq	r0, r0, #0
    210c:	00000172 	andeq	r0, r0, r2, ror r1
            pxBlockToInsert->xBlockSize += heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock )->xBlockSize;
    2110:	761a3c02 	ldrvc	r3, [sl], -r2, lsl #24
    2114:	01000000 	mrseq	r0, (UNDEF: 0)
    2118:	01140801 	tsteq	r4, r1, lsl #16
    211c:	a2030000 	andge	r0, r3, #0
            pxBlockToInsert->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock )->pxNextFreeBlock;
    2120:	02000000 	andeq	r0, r0, #0
    2124:	000010c8 	andeq	r1, r0, r8, asr #1
    2128:	e3122601 	tst	r2, #1048576	@ 0x100000
            pxBlockToInsert->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxEnd );
    212c:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
    2130:	000000d2 	ldrdeq	r0, [r0], -r2
        pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    2134:	0000e803 	andeq	lr, r0, r3, lsl #16
    2138:	60091200 	andvs	r1, r9, r0, lsl #4
    if( pxIterator != pxBlockToInsert )
    213c:	8d000010 	stchi	0, cr0, [r0, #-64]	@ 0xffffffc0
    2140:	0000ba14 	andeq	fp, r0, r4, lsl sl
        pxIterator->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxBlockToInsert );
    2144:	00030500 	andeq	r0, r3, r0, lsl #10
    2148:	13200000 	nopne	{0}	@ <UNPREDICTABLE>
}
    214c:	00000340 	andeq	r0, r0, r0, asr #6
    2150:	0c0dad05 	stceq	13, cr10, [sp], {5}
    2154:	000000ae 	andeq	r0, r0, lr, lsr #1
    2158:	0008e814 	andeq	lr, r8, r4, lsl r8
{
    215c:	0e080500 	cfsh32eq	mvfx0, mvfx8, #0
    2160:	1072041b 	rsbsne	r0, r2, fp, lsl r4
    size_t xBlocks = 0, xMaxSize = 0, xMinSize = portMAX_DELAY; /* portMAX_DELAY used as a portable way of getting the maximum value. */
    2164:	02e70000 	rsceq	r0, r7, #0
    2168:	00248420 	eoreq	r8, r4, r0, lsr #8
    216c:	00003400 	andeq	r3, r0, r0, lsl #8
    2170:	159c0100 	ldrne	r0, [ip, #256]	@ 0x100
    vTaskSuspendAll();
    2174:	0000104c 	andeq	r1, r0, ip, asr #32
        pxBlock = heapPROTECT_BLOCK_POINTER( xStart.pxNextFreeBlock );
    2178:	0601eb01 	streq	lr, [r1], -r1, lsl #22
        if( pxBlock != NULL )
    217c:	0000243e 	andeq	r2, r0, lr, lsr r4
    2180:	00000046 	andeq	r0, r0, r6, asr #32
                xBlocks++;
    2184:	01719c01 	cmneq	r1, r1, lsl #24
    2188:	f4160000 			@ <UNDEFINED> instruction: 0xf4160000
                if( pxBlock->xBlockSize > xMaxSize )
    218c:	44000002 	strmi	r0, [r0], #-2
    2190:	14000024 	strne	r0, [r0], #-36	@ 0xffffffdc
                    xMaxSize = pxBlock->xBlockSize;
    2194:	01000000 	mrseq	r0, (UNDEF: 0)
    2198:	570501f1 			@ <UNDEFINED> instruction: 0x570501f1
                if( pxBlock->xBlockSize < xMinSize )
    219c:	05000001 	streq	r0, [r0, #-1]
    21a0:	000002fd 	strdeq	r0, [r0], -sp
                    xMinSize = pxBlock->xBlockSize;
    21a4:	00749102 	rsbseq	r9, r4, r2, lsl #2
    21a8:	0002da06 	andeq	sp, r2, r6, lsl #20
                pxBlock = heapPROTECT_BLOCK_POINTER( pxBlock->pxNextFreeBlock );
    21ac:	00246e00 	eoreq	r6, r4, r0, lsl #28
            while( pxBlock != pxEnd )
    21b0:	00000800 	andeq	r0, r0, r0, lsl #16
    21b4:	05020200 	streq	r0, [r2, #-512]	@ 0xfffffe00
    21b8:	0002e70a 	andeq	lr, r2, sl, lsl #14
    ( void ) xTaskResumeAll();
    21bc:	70910200 	addsvc	r0, r1, r0, lsl #4
    pxHeapStats->xSizeOfLargestFreeBlockInBytes = xMaxSize;
    21c0:	20040000 	andcs	r0, r4, r0
    pxHeapStats->xSizeOfSmallestFreeBlockInBytes = xMinSize;
    21c4:	c7000010 	smladgt	r0, r0, r0, r0
    21c8:	23f80601 	mvnscs	r0, #1048576	@ 0x100000
    pxHeapStats->xNumberOfFreeBlocks = xBlocks;
    21cc:	00460000 	subeq	r0, r6, r0
    taskENTER_CRITICAL();
    21d0:	9c010000 	stcls	0, cr0, [r1], {-0}
        pxHeapStats->xAvailableHeapSpaceInBytes = xFreeBytesRemaining;
    21d4:	0001ea0b 	andeq	lr, r1, fp, lsl #20
    21d8:	c401bb00 	strgt	fp, [r1], #-2816	@ 0xfffff500
        pxHeapStats->xNumberOfSuccessfulAllocations = xNumberOfSuccessfulAllocations;
    21dc:	34000023 	strcc	r0, [r0], #-35	@ 0xffffffdd
    21e0:	01000000 	mrseq	r0, (UNDEF: 0)
        pxHeapStats->xNumberOfSuccessfulFrees = xNumberOfSuccessfulFrees;
    21e4:	0001b29c 	muleq	r1, ip, r2
    21e8:	02da0600 	sbcseq	r0, sl, #0, 12
        pxHeapStats->xMinimumEverFreeBytesRemaining = xMinimumEverFreeBytesRemaining;
    21ec:	23e00000 	mvncs	r0, #0
    21f0:	00080000 	andeq	r0, r8, r0
    taskEXIT_CRITICAL();
    21f4:	01c20000 	biceq	r0, r2, r0
}
    21f8:	02e70a09 	rsceq	r0, r7, #36864	@ 0x9000
    21fc:	91020000 	mrsls	r0, (UNDEF: 2)
    2200:	0b000074 	bleq	23d8 <vPortExitCritical+0x14>
    2204:	0000039f 	muleq	r0, pc, r3	@ <UNPREDICTABLE>
    2208:	239001aa 	orrscs	r0, r0, #-2147483606	@ 0x8000002a
    220c:	00340000 	eorseq	r0, r4, r0
    2210:	9c010000 	stcls	0, cr0, [r1], {-0}
    2214:	000001e1 	andeq	r0, r0, r1, ror #3
{
    2218:	0002f406 	andeq	pc, r2, r6, lsl #8
    pxEnd = NULL;
    221c:	00239600 	eoreq	r9, r3, r0, lsl #12
    2220:	00001400 	andeq	r1, r0, r0, lsl #8
    xFreeBytesRemaining = ( size_t ) 0U;
    2224:	0501ac00 	streq	sl, [r1, #-3072]	@ 0xfffff400
    xMinimumEverFreeBytesRemaining = ( size_t ) 0U;
    2228:	0002fd05 	andeq	pc, r2, r5, lsl #26
    222c:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
    xNumberOfSuccessfulAllocations = ( size_t ) 0U;
    2230:	17040000 	strne	r0, [r4, -r0]
    xNumberOfSuccessfulFrees = ( size_t ) 0U;
    2234:	a200000c 	andge	r0, r0, #12
    2238:	23840601 	orrcs	r0, r4, #1048576	@ 0x100000
}
    223c:	000c0000 	andeq	r0, ip, r0
    2240:	9c010000 	stcls	0, cr0, [r1], {-0}
    2244:	0000a017 	andeq	sl, r0, r7, lsl r0
    2248:	010c0100 	mrseq	r0, (UNDEF: 28)
    224c:	0000ae0c 	andeq	sl, r0, ip, lsl #28
    2250:	00232a00 	eoreq	r2, r3, r0, lsl #20
    2254:	00005a00 	andeq	r5, r0, r0, lsl #20
{
    2258:	299c0100 	ldmibcs	ip, {r8}
    225c:	18000002 	stmdane	r0, {r1}
    2260:	00002330 	andeq	r2, r0, r0, lsr r3
    pxTopOfStack--;                                                      /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
    2264:	00000006 	andeq	r0, r0, r6
    2268:	0010ba19 	andseq	fp, r0, r9, lsl sl
    *pxTopOfStack = portINITIAL_XPSR;                                    /* xPSR */
    226c:	011c0100 	tsteq	ip, r0, lsl #2
    2270:	00022e21 	andeq	r2, r2, r1, lsr #28
    pxTopOfStack--;
    2274:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
    *pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK; /* PC */
    2278:	de030000 	cdple	0, 0, cr0, cr3, cr0, {0}
    227c:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
    2280:	00000229 	andeq	r0, r0, r9, lsr #4
    pxTopOfStack--;
    2284:	0010e21a 	andseq	lr, r0, sl, lsl r2
    *pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;             /* LR */
    2288:	0df70100 	ldfeqe	f0, [r7]
    228c:	0000230a 	andeq	r2, r0, sl, lsl #6
    pxTopOfStack -= 5;                                                   /* R12, R3, R2 and R1. */
    2290:	00000020 	andeq	r0, r0, r0, lsr #32
    *pxTopOfStack = ( StackType_t ) pvParameters;                        /* R0 */
    2294:	d21b9c01 	andsle	r9, fp, #256	@ 0x100
    2298:	01000010 	tsteq	r0, r0, lsl r0
    pxTopOfStack -= 8;                                                   /* R11, R10, R9, R8, R7, R6, R5 and R4. */
    229c:	22e206e4 	rsccs	r0, r2, #228, 12	@ 0xe400000
    return pxTopOfStack;
    22a0:	00280000 	eoreq	r0, r8, r0
}
    22a4:	9c010000 	stcls	0, cr0, [r1], {-0}
    22a8:	0010331c 	andseq	r3, r0, ip, lsl r3
    22ac:	0dca0100 	stfeqe	f0, [sl]
{
    22b0:	000022b0 			@ <UNDEFINED> instruction: 0x000022b0
    22b4:	00000032 	andeq	r0, r0, r2, lsr r0
    volatile uint32_t ulDummy = 0UL;
    22b8:	02959c01 	addseq	r9, r5, #256	@ 0x100
    __asm volatile
    22bc:	44090000 	strmi	r0, [r9], #-0
    22c0:	cc000010 	stcgt	0, cr0, [r0], {16}
    22c4:	00007117 	andeq	r7, r0, r7, lsl r1
    22c8:	70910200 	addsvc	r0, r1, r0, lsl #4
}
    22cc:	0002f41d 	andeq	pc, r2, sp, lsl r4	@ <UNPREDICTABLE>
    while( ulDummy == 0 )
    22d0:	0022ba00 	eoreq	fp, r2, r0, lsl #20
    22d4:	00001400 	andeq	r1, r0, r0, lsl #8
}
    22d8:	05d50100 	ldrbeq	r0, [r5, #256]	@ 0x100
    22dc:	0002fd05 	andeq	pc, r2, r5, lsl #26
    22e0:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
    __asm volatile (
    22e4:	431e0000 	tstmi	lr, #0
    22e8:	01000007 	tsteq	r0, r7
    22ec:	00cd0fb6 	strheq	r0, [sp], #246	@ 0xf6
    22f0:	22580000 	subscs	r0, r8, #0
    22f4:	00580000 	subseq	r0, r8, r0
    22f8:	9c010000 	stcls	0, cr0, [r1], {-0}
    22fc:	000002da 	ldrdeq	r0, [r0], -sl
    2300:	000bfd07 	andeq	pc, fp, r7, lsl #26
    2304:	cd34b600 	ldcgt	6, cr11, [r4, #-0]
}
    2308:	02000000 	andeq	r0, r0, #0
    __asm volatile (
    230c:	19077491 	stmdbne	r7, {r0, r4, r7, sl, ip, sp, lr}
    2310:	b7000010 	smladlt	r0, r0, r0, r0
    2314:	00008435 	andeq	r8, r0, r5, lsr r4
    2318:	70910200 	addsvc	r0, r1, r0, lsl #4
    231c:	00014007 	andeq	r4, r1, r7
    2320:	a02db800 	eorge	fp, sp, r0, lsl #16
    2324:	02000000 	andeq	r0, r0, #0
}
    2328:	1f006c91 	svcne	0x00006c91
{
    232c:	0000038f 	andeq	r0, r0, pc, lsl #7
        const portISR_t * const pxVectorTable = portSCB_VTOR_REG;
    2330:	031ef802 	tsteq	lr, #131072	@ 0x20000	@ <UNPREDICTABLE>
    2334:	000002f4 	strdeq	r0, [r0], -r4
    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;
    2338:	00087420 	andeq	r7, r8, r0, lsr #8
    233c:	38f80200 	ldmcc	r8!, {r9}^
    2340:	00000065 	andeq	r0, r0, r5, rrx
    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;
    2344:	0a112100 	beq	44a74c <_etext+0x44827c>
    2348:	d4020000 	strle	r0, [r2], #-0
    234c:	5522031e 	strpl	r0, [r2, #-798]!	@ 0xfffffce2
    portNVIC_SHPR2_REG = 0;
    2350:	02000006 	andeq	r0, r0, #6
    vPortSetupTimerInterrupt();
    2354:	00650ed6 	ldrdeq	r0, [r5], #-230	@ 0xffffff1a	@ <UNPREDICTABLE>
    uxCriticalNesting = 0;
    2358:	00000000 	andeq	r0, r0, r0

Disassembly of section .debug_abbrev:

00000000 <.debug_abbrev>:
   0:	10001101 	andne	r1, r0, r1, lsl #2
   4:	12011106 	andne	r1, r1, #-2147483647	@ 0x80000001
   8:	1b0e0301 	blne	380c14 <_etext+0x37e744>
   c:	130e250e 	movwne	r2, #58638	@ 0xe50e
  10:	00000005 	andeq	r0, r0, r5
  14:	0b002401 	bleq	9020 <_etext+0x6b50>
  18:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
  1c:	0200000e 	andeq	r0, r0, #14
  20:	13490005 	movtne	r0, #36869	@ 0x9005
  24:	16030000 	strne	r0, [r3], -r0
  28:	3a0e0300 	bcc	380c30 <_etext+0x37e760>
  2c:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
  30:	0013490b 	andseq	r4, r3, fp, lsl #18
  34:	000f0400 	andeq	r0, pc, r0, lsl #8
  38:	4904210b 	stmdbmi	r4, {r0, r1, r3, r8, sp}
  3c:	05000013 	streq	r0, [r0, #-19]	@ 0xffffffed
  40:	13490026 	movtne	r0, #36902	@ 0x9026
  44:	34060000 	strcc	r0, [r6], #-0
  48:	3a0e0300 	bcc	380c50 <_etext+0x37e780>
  4c:	0b3b0121 	bleq	ec04d8 <_etext+0xebe008>
  50:	49112139 	ldmdbmi	r1, {r0, r3, r4, r5, r8, sp}
  54:	3c193f13 	ldccc	15, cr3, [r9], {19}
  58:	07000019 	smladeq	r0, r9, r0, r0
  5c:	08030034 	stmdaeq	r3, {r2, r4, r5}
  60:	3b01213a 	blcc	48550 <_etext+0x46080>
  64:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
  68:	00180213 	andseq	r0, r8, r3, lsl r2
  6c:	00050800 	andeq	r0, r5, r0, lsl #16
  70:	213a0e03 	teqcs	sl, r3, lsl #28
  74:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
  78:	13491a21 	movtne	r1, #39457	@ 0x9a21
  7c:	00001802 	andeq	r1, r0, r2, lsl #16
  80:	25011109 	strcs	r1, [r1, #-265]	@ 0xfffffef7
  84:	030b130e 	movweq	r1, #45838	@ 0xb30e
  88:	110e1b0e 	tstne	lr, lr, lsl #22
  8c:	10061201 	andne	r1, r6, r1, lsl #4
  90:	0a000017 	beq	f4 <_stext+0xf4>
  94:	0b0b0024 	bleq	2c012c <_etext+0x2bdc5c>
  98:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
  9c:	350b0000 	strcc	r0, [fp, #-0]
  a0:	00134900 	andseq	r4, r3, r0, lsl #18
  a4:	01150c00 	tsteq	r5, r0, lsl #24
  a8:	13011927 	movwne	r1, #6439	@ 0x1927
  ac:	0f0d0000 	svceq	0x000d0000
  b0:	000b0b00 	andeq	r0, fp, r0, lsl #22
  b4:	00130e00 	andseq	r0, r3, r0, lsl #28
  b8:	193c0e03 	ldmdbne	ip!, {r0, r1, r9, sl, fp}
  bc:	2e0f0000 	cdpcs	0, 0, cr0, cr15, cr0, {0}
  c0:	03193f00 	tsteq	r9, #0, 30
  c4:	3b0b3a0e 	blcc	2ce904 <_etext+0x2cc434>
  c8:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
  cc:	3c134919 			@ <UNDEFINED> instruction: 0x3c134919
  d0:	10000019 	andne	r0, r0, r9, lsl r0
  d4:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
  d8:	0b3a0e03 	bleq	e838ec <_etext+0xe8141c>
  dc:	0b39053b 	bleq	e415d0 <_etext+0xe3f100>
  e0:	13491927 	movtne	r1, #39207	@ 0x9927
  e4:	1301193c 	movwne	r1, #6460	@ 0x193c
  e8:	2e110000 	cdpcs	0, 1, cr0, cr1, cr0, {0}
  ec:	03193f01 	tsteq	r9, #1, 30
  f0:	3b0b3a0e 	blcc	2ce930 <_etext+0x2cc460>
  f4:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
  f8:	12011119 	andne	r1, r1, #1073741830	@ 0x40000006
  fc:	7c184006 	ldcvc	0, cr4, [r8], {6}
 100:	00130119 	andseq	r0, r3, r9, lsl r1
 104:	00341200 	eorseq	r1, r4, r0, lsl #4
 108:	0b3a0e03 	bleq	e8391c <_etext+0xe8144c>
 10c:	0b390b3b 	bleq	e42e00 <_etext+0xe40930>
 110:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
 114:	2e130000 	cdpcs	0, 1, cr0, cr3, cr0, {0}
 118:	3a0e0301 	bcc	380d24 <_etext+0x37e854>
 11c:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
 120:	1119270b 	tstne	r9, fp, lsl #14
 124:	40061201 	andmi	r1, r6, r1, lsl #4
 128:	01197a18 	tsteq	r9, r8, lsl sl
 12c:	14000013 	strne	r0, [r0], #-19	@ 0xffffffed
 130:	0e03012e 	adfeqsp	f0, f3, #0.5
 134:	0b3b0b3a 	bleq	ec2e24 <_etext+0xec0954>
 138:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
 13c:	06120111 			@ <UNDEFINED> instruction: 0x06120111
 140:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
 144:	01000000 	mrseq	r0, (UNDEF: 0)
 148:	0b0b0024 	bleq	2c01e0 <_etext+0x2bdd10>
 14c:	0e030b3e 	vmoveq.16	d3[0], r0
 150:	05020000 	streq	r0, [r2, #-0]
 154:	3a0e0300 	bcc	380d5c <_etext+0x37e88c>
 158:	213b0121 	teqcs	fp, r1, lsr #2
 15c:	490b3902 	stmdbmi	fp, {r1, r8, fp, ip, sp}
 160:	00180213 	andseq	r0, r8, r3, lsl r2
 164:	00340300 	eorseq	r0, r4, r0, lsl #6
 168:	213a0803 	teqcs	sl, r3, lsl #16
 16c:	390b3b01 	stmdbcc	fp, {r0, r8, r9, fp, ip, sp}
 170:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
 174:	04000018 	streq	r0, [r0], #-24	@ 0xffffffe8
 178:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
 17c:	0e030b13 	vmoveq.32	d3[0], r0
 180:	01110e1b 	tsteq	r1, fp, lsl lr
 184:	17100612 			@ <UNDEFINED> instruction: 0x17100612
 188:	24050000 	strcs	r0, [r5], #-0
 18c:	3e0b0b00 	vmlacc.f64	d0, d11, d0
 190:	0008030b 	andeq	r0, r8, fp, lsl #6
 194:	00160600 	andseq	r0, r6, r0, lsl #12
 198:	0b3a0e03 	bleq	e839ac <_etext+0xe814dc>
 19c:	0b390b3b 	bleq	e42e90 <_etext+0xe409c0>
 1a0:	00001349 	andeq	r1, r0, r9, asr #6
 1a4:	3f012e07 	svccc	0x00012e07
 1a8:	3a0e0319 	bcc	380e14 <_etext+0x37e944>
 1ac:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
 1b0:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
 1b4:	12011113 	andne	r1, r1, #-1073741820	@ 0xc0000004
 1b8:	7a184006 	bvc	6101d8 <_etext+0x60dd08>
 1bc:	00130119 	andseq	r0, r3, r9, lsl r1
 1c0:	00050800 	andeq	r0, r5, r0, lsl #16
 1c4:	0b3a0803 	bleq	e821d8 <_etext+0xe7fd08>
 1c8:	0b390b3b 	bleq	e42ebc <_etext+0xe409ec>
 1cc:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
    ldr r0, =_sidata            /* Address of init values in flash */
 1d0:	34090000 	strcc	r0, [r9], #-0
    ldr r2, =_edata             /* End of .data in RAM */
 1d4:	3a0e0300 	bcc	380ddc <_etext+0x37e90c>
    bcs zero_bss
 1d8:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    ldr r3, [r0], #4
 1dc:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
    str r3, [r1], #4
 1e0:	0a000018 	beq	248 <start+0x4>
    ldr r0, =_sbss              /* Start of .bss */
 1e4:	0111010b 	tsteq	r1, fp, lsl #2
    cmp r0, r1
 1e8:	00000612 	andeq	r0, r0, r2, lsl r6
    movs r2, #0
 1ec:	0b000f0b 	bleq	3e20 <_etext+0x1950>
    str r2, [r0], #4
 1f0:	0c00000b 	stceq	0, cr0, [r0], {11}
    bl start                    /* Call main/start function */
 1f4:	0b0b000f 	bleq	2c0238 <_etext+0x2bdd68>
    b hang                      /* If it returns, hang forever */
 1f8:	00001349 	andeq	r1, r0, r9, asr #6
    b .
 1fc:	00340100 	eorseq	r0, r4, r0, lsl #2
    b .
 200:	213a0e03 	teqcs	sl, r3, lsl #28
    b .
 204:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
    ldr r0, =_sidata            /* Address of init values in flash */
 208:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
    ldr r1, =_sdata             /* Start of .data in RAM */
 20c:	02000018 	andeq	r0, r0, #24
    ldr r2, =_edata             /* End of .data in RAM */
 210:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    ldr r0, =_sbss              /* Start of .bss */
 214:	3b01213a 	blcc	48704 <_etext+0x46234>
    ldr r1, =_ebss              /* End of .bss */
 218:	490b3905 	stmdbmi	fp, {r0, r2, r8, fp, ip, sp}
static void vTask1(void *pvParameters){
 21c:	00180213 	andseq	r0, r8, r3, lsl r2
 220:	010b0300 	mrseq	r0, (UNDEF: 59)
    volatile int a =0;
 224:	06120111 			@ <UNDEFINED> instruction: 0x06120111
        a++;
 228:	00001301 	andeq	r1, r0, r1, lsl #6
 22c:	0b000f04 	bleq	3e44 <_etext+0x1974>
static void vTask2(void *pvParameters){
 230:	13490421 	movtne	r0, #37921	@ 0x9421
 234:	26050000 	strcs	r0, [r5], -r0
    volatile int b =0;
 238:	00134900 	andseq	r4, r3, r0, lsl #18
        b++;
 23c:	000d0600 	andeq	r0, sp, r0, lsl #12
 240:	0b3a0e03 	bleq	e83a54 <_etext+0xe81584>
void start(){
 244:	0b390b3b 	bleq	e42f38 <_etext+0xe40a68>
 248:	0b381349 	bleq	e04f74 <_etext+0xe02aa4>
    uint32_t *src = &_sidata;//Source flash
 24c:	16070000 	strne	r0, [r7], -r0
    uint32_t *dst = &_sdata;//Destination RAM
 250:	3a0e0300 	bcc	380e58 <_etext+0x37e988>
        *dst++ = *src++; //copy word and increment pointer
 254:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
 258:	0013490b 	andseq	r4, r3, fp, lsl #18
 25c:	00050800 	andeq	r0, r5, r0, lsl #16
 260:	00001349 	andeq	r1, r0, r9, asr #6
    while(dst < &_edata){
 264:	11010b09 	tstne	r1, r9, lsl #22
 268:	00061201 	andeq	r1, r6, r1, lsl #4
    dst = &_sbss;
 26c:	00240a00 	eoreq	r0, r4, r0, lsl #20
    while(dst < &_ebss){
 270:	0b3e0b0b 	bleq	f82ea4 <_etext+0xf809d4>
        *dst++ = 0; //zero word and increment pointer
 274:	00000e03 	andeq	r0, r0, r3, lsl #28
 278:	4900350b 	stmdbmi	r0, {r0, r1, r3, r8, sl, ip, sp}
    while(dst < &_ebss){
 27c:	0c000013 	stceq	0, cr0, [r0], {19}
 280:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
    xReturn = xTaskCreate(vTask1,"T1",configMINIMAL_STACK_SIZE,NULL,1,NULL);  // 256*4 = 1k stack size
 284:	213a0e03 	teqcs	sl, r3, lsl #28
 288:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
 28c:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
 290:	12011113 	andne	r1, r1, #-1073741820	@ 0xc0000004
 294:	7c184006 	ldcvc	0, cr4, [r8], {6}
 298:	00130119 	andseq	r0, r3, r9, lsl r1
    xReturn = xTaskCreate(vTask2,"T2",configMINIMAL_STACK_SIZE,NULL,1,NULL);
 29c:	000d0d00 	andeq	r0, sp, r0, lsl #26
 2a0:	213a0e03 	teqcs	sl, r3, lsl #28
 2a4:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
 2a8:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
 2ac:	0e00000b 	cdpeq	0, 0, cr0, cr0, cr11, {0}
 2b0:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
    xPortStartScheduler();
 2b4:	213a0e03 	teqcs	sl, r3, lsl #28
    return;
 2b8:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
 2bc:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
 2c0:	12011113 	andne	r1, r1, #-1073741820	@ 0xc0000004
 2c4:	7a184006 	bvc	6102e4 <_etext+0x60de14>
 2c8:	00130119 	andseq	r0, r3, r9, lsl r1
 2cc:	00340f00 	eorseq	r0, r4, r0, lsl #30
 2d0:	18021331 	stmdane	r2, {r0, r4, r5, r8, r9, ip}
 2d4:	01100000 	tsteq	r0, r0
 2d8:	01134901 	tsteq	r3, r1, lsl #18
 2dc:	11000013 	tstne	r0, r3, lsl r0
 2e0:	13490021 	movtne	r0, #36897	@ 0x9021
void *memset(void *dest, int c, size_t count) {
 2e4:	00000b2f 	andeq	r0, r0, pc, lsr #22
 2e8:	03011312 	movweq	r1, #4882	@ 0x1312
 2ec:	3a0b0b0e 	bcc	2c2f2c <_etext+0x2c0a5c>
    unsigned char *ptr = (unsigned char *)dest;
 2f0:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    unsigned char value = (unsigned char)c;
 2f4:	0013010b 	andseq	r0, r3, fp, lsl #2
    for (size_t i = 0; i < count; i++) {
 2f8:	00281300 	eoreq	r1, r8, r0, lsl #6
 2fc:	0b1c0e03 	bleq	703b10 <_etext+0x701640>
        ptr[i] = value;
 300:	2e140000 	cdpcs	0, 1, cr0, cr4, cr0, {0}
 304:	03193f01 	tsteq	r9, #1, 30
    for (size_t i = 0; i < count; i++) {
 308:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
 30c:	0b39053b 	bleq	e41800 <_etext+0xe3f330>
 310:	01111927 	tsteq	r1, r7, lsr #18
 314:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
 318:	1301197a 	movwne	r1, #6522	@ 0x197a
 31c:	2e150000 	cdpcs	0, 1, cr0, cr5, cr0, {0}
 320:	3a0e0301 	bcc	380f2c <_etext+0x37ea5c>
    {
 324:	053b0121 	ldreq	r0, [fp, #-289]!	@ 0xfffffedf
 328:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
 32c:	06120111 			@ <UNDEFINED> instruction: 0x06120111
 330:	197c1840 	ldmdbne	ip!, {r6, fp, ip}^
            pxStack = pvPortMallocStack( ( ( ( size_t ) uxStackDepth ) * sizeof( StackType_t ) ) );
 334:	00001301 	andeq	r1, r0, r1, lsl #6
 338:	31011d16 	tstcc	r1, r6, lsl sp
 33c:	12011113 	andne	r1, r1, #-1073741820	@ 0xc0000004
            if( pxStack != NULL )
 340:	01215806 			@ <UNDEFINED> instruction: 0x01215806
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 344:	0b570559 	bleq	15c18b0 <_etext+0x15bf3e0>
 348:	2e170000 	cdpcs	0, 1, cr0, cr7, cr0, {0}
                if( pxNewTCB != NULL )
 34c:	03193f01 	tsteq	r9, #1, 30
 350:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
                    ( void ) memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
 354:	2139053b 	teqcs	r9, fp, lsr r5
 358:	11192706 	tstne	r9, r6, lsl #14
                    pxNewTCB->pxStack = pxStack;
 35c:	40061201 	andmi	r1, r6, r1, lsl #4
 360:	01197c18 	tsteq	r9, r8, lsl ip
                    vPortFreeStack( pxStack );
 364:	18000013 	stmdane	r0, {r0, r1, r4}
 368:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
                pxNewTCB = NULL;
 36c:	3b02213a 	blcc	8885c <_etext+0x8638c>
        if( pxNewTCB != NULL )
 370:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
 374:	19000013 	stmdbne	r0, {r0, r1, r4}
            prvInitialiseNewTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 378:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
 37c:	213a0e03 	teqcs	sl, r3, lsl #28
 380:	39053b06 	stmdbcc	r5, {r1, r2, r8, r9, fp, ip, sp}
 384:	19270621 	stmdbne	r7!, {r0, r5, r9, sl}
 388:	1301193c 	movwne	r1, #6460	@ 0x193c
 38c:	2e1a0000 	cdpcs	0, 1, cr0, cr10, cr0, {0}
 390:	03193f00 	tsteq	r9, #0, 30
    }
 394:	3b0b3a0e 	blcc	2cebd4 <_etext+0x2cc704>
 398:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
    {
 39c:	00193c19 	andseq	r3, r9, r9, lsl ip
 3a0:	012e1b00 			@ <UNDEFINED> instruction: 0x012e1b00
 3a4:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
 3a8:	0b3b0b3a 	bleq	ec3098 <_etext+0xec0bc8>
        pxNewTCB = prvCreateTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask );
 3ac:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
 3b0:	193c1349 	ldmdbne	ip!, {r0, r3, r6, r8, r9, ip}
 3b4:	00001301 	andeq	r1, r0, r1, lsl #6
 3b8:	3100051c 	tstcc	r0, ip, lsl r5
 3bc:	00180213 	andseq	r0, r8, r3, lsl r2
        if( pxNewTCB != NULL )
 3c0:	00161d00 	andseq	r1, r6, r0, lsl #26
 3c4:	213a0e03 	teqcs	sl, r3, lsl #28
            prvAddNewTaskToReadyList( pxNewTCB );
 3c8:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
            xReturn = pdPASS;
 3cc:	0013490b 	andseq	r4, r3, fp, lsl #18
 3d0:	011d1e00 	tsteq	sp, r0, lsl #28
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 3d4:	01111331 	tsteq	r1, r1, lsr r3
        return xReturn;
 3d8:	21580612 	cmpcs	r8, r2, lsl r6
    }
 3dc:	57055901 	strpl	r5, [r5, -r1, lsl #18]
 3e0:	13013221 	movwne	r3, #4641	@ 0x1221
{
 3e4:	2e1f0000 	cdpcs	0, 1, cr0, cr15, cr0, {0}
 3e8:	3a0e0300 	bcc	380ff0 <_etext+0x37eb20>
 3ec:	053b0121 	ldreq	r0, [fp, #-289]!	@ 0xfffffedf
        pxTopOfStack = &( pxNewTCB->pxStack[ uxStackDepth - ( configSTACK_DEPTH_TYPE ) 1 ] );
 3f0:	270d2139 	smladxcs	sp, r9, r1, r2
 3f4:	12011119 	andne	r1, r1, #1073741830	@ 0x40000006
 3f8:	7a184006 	bvc	610418 <_etext+0x60df48>
 3fc:	20000019 	andcs	r0, r0, r9, lsl r0
 400:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	@ <UNPREDICTABLE>
        pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 404:	213a0e03 	teqcs	sl, r3, lsl #28
 408:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
    if( pcName != NULL )
 40c:	19270621 	stmdbne	r7!, {r0, r5, r9, sl}
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 410:	06120111 			@ <UNDEFINED> instruction: 0x06120111
 414:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 418:	2e210000 	cdpcs	0, 2, cr0, cr1, cr0, {0}
 41c:	3a0e0301 	bcc	381028 <_etext+0x37eb58>
 420:	053b0121 	ldreq	r0, [fp, #-289]!	@ 0xfffffedf
 424:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
 428:	01111349 	tsteq	r1, r9, asr #6
            if( pcName[ x ] == ( char ) 0x00 )
 42c:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
 430:	1301197c 	movwne	r1, #6524	@ 0x197c
 434:	2e220000 	cdpcs	0, 2, cr0, cr2, cr0, {0}
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 438:	3a0e0301 	bcc	381044 <_etext+0x37eb74>
 43c:	0b3b0221 	bleq	ec0cc8 <_etext+0xebe7f8>
 440:	271e2139 			@ <UNDEFINED> instruction: 0x271e2139
                break;
 444:	03212019 			@ <UNDEFINED> instruction: 0x03212019
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1U ] = '\0';
 448:	00001301 	andeq	r1, r0, r1, lsl #6
 44c:	03000523 	movweq	r0, #1315	@ 0x523
    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 450:	02213a0e 	eoreq	r3, r1, #57344	@ 0xe000
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 454:	0b390b3b 	bleq	e43148 <_etext+0xe40c78>
    pxNewTCB->uxPriority = uxPriority;
 458:	00001349 	andeq	r1, r0, r9, asr #6
 45c:	25011124 	strcs	r1, [r1, #-292]	@ 0xfffffedc
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 460:	030b130e 	movweq	r1, #45838	@ 0xb30e
 464:	110e1b0e 	tstne	lr, lr, lsl #22
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 468:	10061201 	andne	r1, r6, r1, lsl #4
 46c:	25000017 	strcs	r0, [r0, #-23]	@ 0xffffffe9
 470:	0b0b0024 	bleq	2c0508 <_etext+0x2be038>
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 474:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority );
 478:	0f260000 	svceq	0x00260000
 47c:	000b0b00 	andeq	r0, fp, r0, lsl #22
 480:	01152700 	tsteq	r5, r0, lsl #14
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 484:	13011927 	movwne	r1, #6439	@ 0x1927
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 488:	13280000 			@ <UNDEFINED> instruction: 0x13280000
 48c:	0b0e0301 	bleq	381098 <_etext+0x37ebc8>
 490:	3b0b3a0b 	blcc	2cecc4 <_etext+0x2cc7f4>
 494:	010b3905 	tsteq	fp, r5, lsl #18
    if( pxCreatedTask != NULL )
 498:	29000013 	stmdbcs	r0, {r0, r1, r4}
 49c:	0b3e0104 	bleq	f808b4 <_etext+0xf7e3e4>
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 4a0:	13490b0b 	movtne	r0, #39691	@ 0x9b0b
}
 4a4:	0b3b0b3a 	bleq	ec3194 <_etext+0xec0cc4>
 4a8:	13010b39 	movwne	r0, #6969	@ 0x1b39
    {
 4ac:	342a0000 	strtcc	r0, [sl], #-0
 4b0:	3a0e0300 	bcc	3810b8 <_etext+0x37ebe8>
        taskENTER_CRITICAL();
 4b4:	39053b0b 	stmdbcc	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
            uxCurrentNumberOfTasks = ( UBaseType_t ) ( uxCurrentNumberOfTasks + 1U );
 4b8:	3f13490b 	svccc	0x0013490b
 4bc:	00180219 	andseq	r0, r8, r9, lsl r2
 4c0:	012e2b00 			@ <UNDEFINED> instruction: 0x012e2b00
            if( pxCurrentTCB == NULL )
 4c4:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
 4c8:	053b0b3a 	ldreq	r0, [fp, #-2874]!	@ 0xfffff4c6
                pxCurrentTCB = pxNewTCB;
 4cc:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
                if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 4d0:	193c1349 	ldmdbne	ip!, {r0, r3, r6, r8, r9, ip}
 4d4:	00001301 	andeq	r1, r0, r1, lsl #6
                    prvInitialiseTaskLists();
 4d8:	3f002e2c 	svccc	0x00002e2c
 4dc:	3a0e0319 	bcc	381148 <_etext+0x37ec78>
                if( xSchedulerRunning == pdFALSE )
 4e0:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
 4e4:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
                    if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 4e8:	00193c13 	andseq	r3, r9, r3, lsl ip
 4ec:	012e2d00 			@ <UNDEFINED> instruction: 0x012e2d00
 4f0:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
                        pxCurrentTCB = pxNewTCB;
 4f4:	0b3b0b3a 	bleq	ec31e4 <_etext+0xec0d14>
 4f8:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
            uxTaskNumber++;
 4fc:	1301193c 	movwne	r1, #6460	@ 0x193c
 500:	2e2e0000 	cdpcs	0, 2, cr0, cr14, cr0, {0}
            prvAddTaskToReadyList( pxNewTCB );
 504:	03193f00 	tsteq	r9, #0, 30
 508:	3b0b3a0e 	blcc	2ced48 <_etext+0x2cc878>
 50c:	270b3905 	strcs	r3, [fp, -r5, lsl #18]
 510:	11134919 	tstne	r3, r9, lsl r9
 514:	40061201 	andmi	r1, r6, r1, lsl #4
 518:	00197a18 	andseq	r7, r9, r8, lsl sl
 51c:	00342f00 	eorseq	r2, r4, r0, lsl #30
 520:	0b3a0803 	bleq	e82534 <_etext+0xe80064>
 524:	0b39053b 	bleq	e41a18 <_etext+0xe3f548>
 528:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
 52c:	2e300000 	cdpcs	0, 3, cr0, cr0, cr0, {0}
 530:	3a0e0301 	bcc	38113c <_etext+0x37ec6c>
 534:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
 538:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
 53c:	010b2013 	tsteq	fp, r3, lsl r0
 540:	31000013 	tstcc	r0, r3, lsl r0
 544:	0e03012e 	adfeqsp	f0, f3, #0.5
 548:	0b3b0b3a 	bleq	ec3238 <_etext+0xec0d68>
 54c:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
 550:	0b201349 	bleq	80527c <_etext+0x802dac>
 554:	01000000 	mrseq	r0, (UNDEF: 0)
 558:	0b0b0024 	bleq	2c05f0 <_etext+0x2be120>
 55c:	0e030b3e 	vmoveq.16	d3[0], r0
 560:	0d020000 	stceq	0, cr0, [r2, #-0]
 564:	3a0e0300 	bcc	38116c <_etext+0x37ec9c>
 568:	0b3b0421 	bleq	ec15f4 <_etext+0xebf124>
 56c:	13490b39 	movtne	r0, #39737	@ 0x9b39
 570:	00000b38 	andeq	r0, r0, r8, lsr fp
 574:	03000503 	movweq	r0, #1283	@ 0x503
 578:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
 57c:	0b390b3b 	bleq	e43270 <_etext+0xe40da0>
 580:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
 584:	16040000 	strne	r0, [r4], -r0
        taskEXIT_CRITICAL();
 588:	3a0e0300 	bcc	381190 <_etext+0x37ecc0>
        if( xSchedulerRunning != pdFALSE )
 58c:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
 590:	0013490b 	andseq	r4, r3, fp, lsl #18
            taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxNewTCB );
 594:	000f0500 	andeq	r0, pc, r0, lsl #10
 598:	4904210b 	stmdbmi	r4, {r0, r1, r3, r8, sp}
 59c:	06000013 			@ <UNDEFINED> instruction: 0x06000013
 5a0:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
 5a4:	3b01213a 	blcc	48a94 <_etext+0x465c4>
 5a8:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
 5ac:	00180213 	andseq	r0, r8, r3, lsl r2
    }
 5b0:	00260700 	eoreq	r0, r6, r0, lsl #14
 5b4:	00001349 	andeq	r1, r0, r9, asr #6
 5b8:	03011308 	movweq	r1, #4872	@ 0x1308
 5bc:	3a0b0b0e 	bcc	2c31fc <_etext+0x2c0d2c>
 5c0:	0b3b0421 	bleq	ec164c <_etext+0xebf17c>
 5c4:	13010b39 	movwne	r0, #6969	@ 0x1b39
 5c8:	2e090000 	cdpcs	0, 0, cr0, cr9, cr0, {0}
 5cc:	03193f01 	tsteq	r9, #1, 30
 5d0:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
{
 5d4:	21390b3b 	teqcs	r9, fp, lsr fp
 5d8:	11192706 	tstne	r9, r6, lsl #14
    BaseType_t xReturn = pdPASS;
 5dc:	40061201 	andmi	r1, r6, r1, lsl #4
    char cIdleName[ configMAX_TASK_NAME_LEN ] = { 0 };
 5e0:	01197a18 	tsteq	r9, r8, lsl sl
 5e4:	0a000013 	beq	638 <prvCreateIdleTasks+0x64>
 5e8:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
    TaskFunction_t pxIdleTaskFunction = NULL;
 5ec:	0e030b13 	vmoveq.32	d3[0], r0
    for( xIdleTaskNameIndex = 0U; xIdleTaskNameIndex < ( configMAX_TASK_NAME_LEN - taskRESERVED_TASK_NAME_LENGTH ); xIdleTaskNameIndex++ )
 5f0:	01110e1b 	tsteq	r1, fp, lsl lr
        cIdleName[ xIdleTaskNameIndex ] = configIDLE_TASK_NAME[ xIdleTaskNameIndex ];
 5f4:	17100612 			@ <UNDEFINED> instruction: 0x17100612
 5f8:	240b0000 	strcs	r0, [fp], #-0
 5fc:	3e0b0b00 	vmlacc.f64	d0, d11, d0
 600:	0008030b 	andeq	r0, r8, fp, lsl #6
 604:	000f0c00 	andeq	r0, pc, r0, lsl #24
        if( cIdleName[ xIdleTaskNameIndex ] == ( char ) 0x00 )
 608:	00000b0b 	andeq	r0, r0, fp, lsl #22
 60c:	3f012e0d 	svccc	0x00012e0d
 610:	3a0e0319 	bcc	38127c <_etext+0x37edac>
    for( xIdleTaskNameIndex = 0U; xIdleTaskNameIndex < ( configMAX_TASK_NAME_LEN - taskRESERVED_TASK_NAME_LENGTH ); xIdleTaskNameIndex++ )
 614:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
 618:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
 61c:	12011113 	andne	r1, r1, #-1073741820	@ 0xc0000004
            break;
 620:	7a184006 	bvc	610640 <_etext+0x60e170>
    cIdleName[ xIdleTaskNameIndex ] = '\0';
 624:	00130119 	andseq	r0, r3, r9, lsl r1
 628:	012e0e00 			@ <UNDEFINED> instruction: 0x012e0e00
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
 62c:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
 630:	0b3b0b3a 	bleq	ec3320 <_etext+0xec0e50>
            pxIdleTaskFunction = &prvIdleTask;
 634:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
            xReturn = xTaskCreate( pxIdleTaskFunction,
 638:	06120111 			@ <UNDEFINED> instruction: 0x06120111
 63c:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
 640:	01000000 	mrseq	r0, (UNDEF: 0)
 644:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
 648:	3b01213a 	blcc	48b38 <_etext+0x46668>
 64c:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
 650:	00180213 	andseq	r0, r8, r3, lsl r2
        if( xReturn != pdPASS )
 654:	00240200 	eoreq	r0, r4, r0, lsl #4
 658:	0b3e0b0b 	bleq	f8328c <_etext+0xf80dbc>
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
 65c:	00000e03 	andeq	r0, r0, r3, lsl #28
 660:	03003403 	movweq	r3, #1027	@ 0x403
 664:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
            break;
 668:	0b39053b 	bleq	e41b5c <_etext+0xe3f68c>
}
 66c:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
 670:	0d040000 	stceq	0, cr0, [r4, #-0]
 674:	3a0e0300 	bcc	38127c <_etext+0x37edac>
 678:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
 67c:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
{
 680:	0500000b 	streq	r0, [r0, #-11]
 684:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
    xReturn = prvCreateIdleTasks();
 688:	0b3b0b3a 	bleq	ec3378 <_etext+0xec0ea8>
    if( xReturn == pdPASS )
 68c:	13490b39 	movtne	r0, #39737	@ 0x9b39
 690:	0f060000 	svceq	0x00060000
    __asm volatile
 694:	04210b00 	strteq	r0, [r1], #-2816	@ 0xfffff500
 698:	00001349 	andeq	r1, r0, r9, asr #6
 69c:	03000507 	movweq	r0, #1287	@ 0x507
 6a0:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
}
 6a4:	0b39053b 	bleq	e41b98 <_etext+0xe3f6c8>
        xNextTaskUnblockTime = portMAX_DELAY;
 6a8:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
 6ac:	05080000 	streq	r0, [r8, #-0]
        xSchedulerRunning = pdTRUE;
 6b0:	00134900 	andseq	r4, r3, r0, lsl #18
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 6b4:	002e0900 	eoreq	r0, lr, r0, lsl #18
 6b8:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
        ( void ) xPortStartScheduler();
 6bc:	3b01213a 	blcc	48bac <_etext+0x466dc>
    ( void ) uxTopUsedPriority;
 6c0:	06213905 	strteq	r3, [r1], -r5, lsl #18
}
 6c4:	01111927 	tsteq	r1, r7, lsr #18
 6c8:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
 6cc:	0000197a 	andeq	r1, r0, sl, ror r9
 6d0:	0300340a 	movweq	r3, #1034	@ 0x40a
 6d4:	01213a08 			@ <UNDEFINED> instruction: 0x01213a08
 6d8:	0b39053b 	bleq	e41bcc <_etext+0xe3f6fc>
{
 6dc:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
 6e0:	130b0000 	movwne	r0, #45056	@ 0xb000
    __asm volatile
 6e4:	0b0e0301 	bleq	3812f0 <_etext+0x37ee20>
 6e8:	3b0b3a0b 	blcc	2cef1c <_etext+0x2cca4c>
 6ec:	1021390b 	eorne	r3, r1, fp, lsl #18
 6f0:	00001301 	andeq	r1, r0, r1, lsl #6
}
 6f4:	3f002e0c 	svccc	0x00002e0c
    xSchedulerRunning = pdFALSE;
 6f8:	3a0e0319 	bcc	381364 <_etext+0x37ee94>
    vPortEndScheduler();
 6fc:	0b3b0421 	bleq	ec1788 <_etext+0xebf2b8>
}
 700:	270d2139 	smladxcs	sp, r9, r1, r2
 704:	00193c19 	andseq	r3, r9, r9, lsl ip
 708:	012e0d00 			@ <UNDEFINED> instruction: 0x012e0d00
{
 70c:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
        uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended + 1U );
 710:	3b01213a 	blcc	48c00 <_etext+0x46730>
 714:	06213905 	strteq	r3, [r1], -r5, lsl #18
 718:	01111927 	tsteq	r1, r7, lsr #18
}
 71c:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
 720:	1301197c 	movwne	r1, #6524	@ 0x197c
 724:	2e0e0000 	cdpcs	0, 0, cr0, cr14, cr0, {0}
{
 728:	3a0e0301 	bcc	381334 <_etext+0x37ee64>
 72c:	053b0121 	ldreq	r0, [fp, #-289]!	@ 0xfffffedf
    TCB_t * pxTCB = NULL;
 730:	270d2139 	smladxcs	sp, r9, r1, r2
    BaseType_t xAlreadyYielded = pdFALSE;
 734:	12011119 	andne	r1, r1, #1073741830	@ 0x40000006
        taskENTER_CRITICAL();
 738:	7a184006 	bvc	610758 <_etext+0x60e288>
            const BaseType_t xCoreID = ( BaseType_t ) portGET_CORE_ID();
 73c:	00130119 	andseq	r0, r3, r9, lsl r1
            uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended - 1U );
 740:	002e0f00 	eoreq	r0, lr, r0, lsl #30
 744:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
            if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 748:	3b01213a 	blcc	48c38 <_etext+0x46768>
 74c:	08213905 	stmdaeq	r1!, {r0, r2, r8, fp, ip, sp}
 750:	13491927 	movtne	r1, #39207	@ 0x9927
                if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 754:	06120111 			@ <UNDEFINED> instruction: 0x06120111
 758:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 75c:	11100000 	tstne	r0, r0
                        pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 760:	130e2501 	movwne	r2, #58625	@ 0xe501
 764:	1b0e030b 	blne	381398 <_etext+0x37eec8>
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 768:	1201110e 	andne	r1, r1, #-2147483645	@ 0x80000003
 76c:	00171006 	andseq	r1, r7, r6
 770:	00261100 	eoreq	r1, r6, r0, lsl #2
 774:	00001349 	andeq	r1, r0, r9, asr #6
 778:	0b002412 	bleq	97c8 <_etext+0x72f8>
 77c:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
 780:	13000008 	movwne	r0, #8
 784:	0b0b000f 	bleq	2c07c8 <_etext+0x2be2f8>
 788:	01140000 	tsteq	r4, r0
 78c:	01134901 	tsteq	r3, r1, lsl #18
 790:	15000013 	strne	r0, [r0, #-19]	@ 0xffffffed
 794:	13490021 	movtne	r0, #36897	@ 0x9021
 798:	0000052f 	andeq	r0, r0, pc, lsr #10
 79c:	3f012e16 	svccc	0x00012e16
 7a0:	3a0e0319 	bcc	38140c <_etext+0x37ef3c>
                        listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 7a4:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
 7a8:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
 7ac:	01193c13 	tsteq	r9, r3, lsl ip
 7b0:	17000013 	smladne	r0, r3, r0, r0
 7b4:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	@ <UNPREDICTABLE>
 7b8:	0b3a0e03 	bleq	e83fcc <_etext+0xe81afc>
 7bc:	0b39053b 	bleq	e41cb0 <_etext+0xe3f7e0>
 7c0:	13491927 	movtne	r1, #39207	@ 0x9927
 7c4:	0000193c 	andeq	r1, r0, ip, lsr r9
 7c8:	3f002e18 	svccc	0x00002e18
 7cc:	3a0e0319 	bcc	381438 <_etext+0x37ef68>
 7d0:	39053b0b 	stmdbcc	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
 7d4:	3c19270b 	ldccc	7, cr2, [r9], {11}
 7d8:	19000019 	stmdbne	r0, {r0, r3, r4}
 7dc:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
 7e0:	0b3a0e03 	bleq	e83ff4 <_etext+0xe81b24>
                        prvAddTaskToReadyList( pxTCB );
 7e4:	0b39053b 	bleq	e41cd8 <_etext+0xe3f808>
 7e8:	13491927 	movtne	r1, #39207	@ 0x9927
 7ec:	06120111 			@ <UNDEFINED> instruction: 0x06120111
 7f0:	197c1840 	ldmdbne	ip!, {r6, fp, ip}^
 7f4:	00001301 	andeq	r1, r0, r1, lsl #6
 7f8:	0300051a 	movweq	r0, #1306	@ 0x51a
 7fc:	3b0b3a08 	blcc	2cf024 <_etext+0x2ccb54>
 800:	490b3905 	stmdbmi	fp, {r0, r2, r8, fp, ip, sp}
 804:	00180213 	andseq	r0, r8, r3, lsl r2
 808:	012e1b00 			@ <UNDEFINED> instruction: 0x012e1b00
 80c:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
 810:	0b3b0b3a 	bleq	ec3500 <_etext+0xec1030>
 814:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
 818:	01111349 	tsteq	r1, r9, asr #6
 81c:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
 820:	0000197c 	andeq	r1, r0, ip, ror r9
 824:	0300051c 	movweq	r0, #1308	@ 0x51c
 828:	3b0b3a0e 	blcc	2cf068 <_etext+0x2ccb98>
 82c:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
 830:	00180213 	andseq	r0, r8, r3, lsl r2
 834:	24010000 	strcs	r0, [r1], #-0
 838:	3e0b0b00 	vmlacc.f64	d0, d11, d0
 83c:	000e030b 	andeq	r0, lr, fp, lsl #6
 840:	00160200 	andseq	r0, r6, r0, lsl #4
 844:	0b3a0e03 	bleq	e84058 <_etext+0xe81b88>
 848:	0b390b3b 	bleq	e4353c <_etext+0xe4106c>
 84c:	00001349 	andeq	r1, r0, r9, asr #6
 850:	0b000f03 	bleq	4464 <_etext+0x1f94>
 854:	13490421 	movtne	r0, #37921	@ 0x9421
 858:	2e040000 	cdpcs	0, 0, cr0, cr4, cr0, {0}
 85c:	03193f00 	tsteq	r9, #0, 30
 860:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 864:	0b39053b 	bleq	e41d58 <_etext+0xe3f888>
 868:	01111927 	tsteq	r1, r7, lsr #18
 86c:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
 870:	0000197a 	andeq	r1, r0, sl, ror r9
                                xYieldPendings[ xCoreID ] = pdTRUE;
 874:	31003405 	tstcc	r0, r5, lsl #8
 878:	00180213 	andseq	r0, r8, r3, lsl r2
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 87c:	011d0600 	tsteq	sp, r0, lsl #12
 880:	01111331 	tsteq	r1, r1, lsr r3
 884:	21580612 	cmpcs	r8, r2, lsl r6
                    if( pxTCB != NULL )
 888:	57055901 	strpl	r5, [r5, -r1, lsl #18]
                        prvResetNextTaskUnblockTime();
 88c:	0700000b 	streq	r0, [r0, -fp]
                        TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 890:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
 894:	3b01213a 	blcc	48d84 <_etext+0x468b4>
                        if( xPendedCounts > ( TickType_t ) 0U )
 898:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
                                if( xTaskIncrementTick() != pdFALSE )
 89c:	00180213 	andseq	r0, r8, r3, lsl r2
 8a0:	00260800 	eoreq	r0, r6, r0, lsl #16
 8a4:	00001349 	andeq	r1, r0, r9, asr #6
                                    xYieldPendings[ xCoreID ] = pdTRUE;
 8a8:	03003409 	movweq	r3, #1033	@ 0x409
 8ac:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
                                --xPendedCounts;
 8b0:	0b390b3b 	bleq	e435a4 <_etext+0xe410d4>
 8b4:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
                            } while( xPendedCounts > ( TickType_t ) 0U );
 8b8:	050a0000 	streq	r0, [sl, #-0]
                            xPendedTicks = 0;
 8bc:	02133100 	andseq	r3, r3, #0, 2
 8c0:	0b000018 	bleq	928 <xTaskGetTickCount+0x10>
                    if( xYieldPendings[ xCoreID ] != pdFALSE )
 8c4:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
 8c8:	213a0e03 	teqcs	sl, r3, lsl #28
 8cc:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
                            xAlreadyYielded = pdTRUE;
 8d0:	19270621 	stmdbne	r7!, {r0, r5, r9, sl}
                            taskYIELD_TASK_CORE_IF_USING_PREEMPTION( pxCurrentTCB );
 8d4:	06120111 			@ <UNDEFINED> instruction: 0x06120111
 8d8:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
 8dc:	00001301 	andeq	r1, r0, r1, lsl #6
 8e0:	2501110c 	strcs	r1, [r1, #-268]	@ 0xfffffef4
 8e4:	030b130e 	movweq	r1, #45838	@ 0xb30e
        taskEXIT_CRITICAL();
 8e8:	110e1b0e 	tstne	lr, lr, lsl #22
}
 8ec:	10061201 	andne	r1, r6, r1, lsl #4
 8f0:	0d000017 	stceq	0, cr0, [r0, #-92]	@ 0xffffffa4
 8f4:	0b0b0024 	bleq	2c098c <_etext+0x2be4bc>
 8f8:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
 8fc:	350e0000 	strcc	r0, [lr, #-0]
 900:	00134900 	andseq	r4, r3, r0, lsl #18
 904:	01150f00 	tsteq	r5, r0, lsl #30
 908:	13011927 	movwne	r1, #6439	@ 0x1927
 90c:	05100000 	ldreq	r0, [r0, #-0]
 910:	00134900 	andseq	r4, r3, r0, lsl #18
 914:	000f1100 	andeq	r1, pc, r0, lsl #2
{
 918:	00000b0b 	andeq	r0, r0, fp, lsl #22
 91c:	27001512 	smladcs	r0, r2, r5, r1
        xTicks = xTickCount;
 920:	13000019 	movwne	r0, #25
    return xTicks;
 924:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	@ <UNPREDICTABLE>
}
 928:	0b3a0e03 	bleq	e8413c <_etext+0xe81c6c>
 92c:	0b39053b 	bleq	e41e20 <_etext+0xe3f950>
 930:	13491927 	movtne	r1, #39207	@ 0x9927
{
 934:	0000193c 	andeq	r1, r0, ip, lsr r9
 938:	3f002e14 	svccc	0x00002e14
    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
 93c:	3a0e0319 	bcc	3815a8 <_etext+0x37f0d8>
        xReturn = xTickCount;
 940:	39053b0b 	stmdbcc	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    return xReturn;
 944:	3c19270b 	ldccc	7, cr2, [r9], {11}
}
 948:	15000019 	strne	r0, [r0, #-25]	@ 0xffffffe7
 94c:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
 950:	0b3a0e03 	bleq	e84164 <_etext+0xe81c94>
{
 954:	0b39053b 	bleq	e41e48 <_etext+0xe3f978>
    return uxCurrentNumberOfTasks;
 958:	01111927 	tsteq	r1, r7, lsr #18
}
 95c:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
 960:	1301197c 	movwne	r1, #6524	@ 0x197c
 964:	1d160000 	ldcne	0, cr0, [r6, #-0]
{
 968:	11133101 	tstne	r3, r1, lsl #2
 96c:	58061201 	stmdapl	r6, {r0, r9, ip}
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 970:	5705590b 	strpl	r5, [r5, -fp, lsl #18]
 974:	0013010b 	andseq	r0, r3, fp, lsl #2
 978:	012e1700 			@ <UNDEFINED> instruction: 0x012e1700
 97c:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
    return &( pxTCB->pcTaskName[ 0 ] );
 980:	053b0b3a 	ldreq	r0, [fp, #-2874]!	@ 0xfffff4c6
}
 984:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
 988:	01111349 	tsteq	r1, r9, asr #6
 98c:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
 990:	1301197c 	movwne	r1, #6524	@ 0x197c
{
 994:	0b180000 	bleq	60099c <_etext+0x5fe4cc>
 998:	12011101 	andne	r1, r1, #1073741824	@ 0x40000000
    vTaskSuspendAll();
 99c:	19000006 	stmdbne	r0, {r1, r2}
    taskENTER_CRITICAL();
 9a0:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
        xPendedTicks += xTicksToCatchUp;
 9a4:	053b0b3a 	ldreq	r0, [fp, #-2874]!	@ 0xfffff4c6
 9a8:	13490b39 	movtne	r0, #39737	@ 0x9b39
 9ac:	00001802 	andeq	r1, r0, r2, lsl #16
    taskEXIT_CRITICAL();
 9b0:	03002e1a 	movweq	r2, #3610	@ 0xe1a
    xYieldOccurred = xTaskResumeAll();
 9b4:	3b0b3a0e 	blcc	2cf1f4 <_etext+0x2ccd24>
 9b8:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
}
 9bc:	12011119 	andne	r1, r1, #1073741830	@ 0x40000006
 9c0:	7a184006 	bvc	6109e0 <_etext+0x60e510>
 9c4:	1b000019 	blne	a30 <xTaskIncrementTick+0x68>
{
 9c8:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	@ <UNPREDICTABLE>
 9cc:	0b3a0e03 	bleq	e841e0 <_etext+0xe81d10>
    BaseType_t xSwitchRequired = pdFALSE;
 9d0:	0b390b3b 	bleq	e436c4 <_etext+0xe411f4>
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 9d4:	01111927 	tsteq	r1, r7, lsr #18
 9d8:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 9dc:	0000197a 	andeq	r1, r0, sl, ror r9
 9e0:	03012e1c 	movweq	r2, #7708	@ 0x1e1c
        xTickCount = xConstTickCount;
 9e4:	3b0b3a0e 	blcc	2cf224 <_etext+0x2ccd54>
 9e8:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
        if( xConstTickCount == ( TickType_t ) 0U )
 9ec:	12011119 	andne	r1, r1, #1073741830	@ 0x40000006
            taskSWITCH_DELAYED_LISTS();
 9f0:	7a184006 	bvc	610a10 <_etext+0x60e540>
 9f4:	00130119 	andseq	r0, r3, r9, lsl r1
 9f8:	011d1d00 	tsteq	sp, r0, lsl #26
 9fc:	01111331 	tsteq	r1, r1, lsr r3
 a00:	0b580612 	bleq	1602250 <_etext+0x15ffd80>
 a04:	0b570b59 	bleq	15c3770 <_etext+0x15c12a0>
 a08:	2e1e0000 	cdpcs	0, 1, cr0, cr14, cr0, {0}
 a0c:	03193f01 	tsteq	r9, #1, 30
 a10:	3b0b3a0e 	blcc	2cf250 <_etext+0x2ccd80>
        if( xConstTickCount >= xNextTaskUnblockTime )
 a14:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
 a18:	11134919 	tstne	r3, r9, lsl r9
 a1c:	40061201 	andmi	r1, r6, r1, lsl #4
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 a20:	01197a18 	tsteq	r9, r8, lsl sl
 a24:	1f000013 	svcne	0x00000013
                    xNextTaskUnblockTime = portMAX_DELAY;
 a28:	0e03012e 	adfeqsp	f0, f3, #0.5
 a2c:	0b3b0b3a 	bleq	ec371c <_etext+0xec124c>
                    break;
 a30:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 a34:	13010b20 	movwne	r0, #6944	@ 0x1b20
 a38:	05200000 	streq	r0, [r0, #-0]!
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 a3c:	3a0e0300 	bcc	381644 <_etext+0x37f174>
 a40:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
                    if( xConstTickCount < xItemValue )
 a44:	0013490b 	andseq	r4, r3, fp, lsl #18
 a48:	012e2100 			@ <UNDEFINED> instruction: 0x012e2100
                        xNextTaskUnblockTime = xItemValue;
 a4c:	0b3a0e03 	bleq	e84260 <_etext+0xe81d90>
                        break;
 a50:	0b390b3b 	bleq	e43744 <_etext+0xe41274>
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 a54:	0b201927 	bleq	806ef8 <_etext+0x804a28>
 a58:	34220000 	strtcc	r0, [r2], #-0
 a5c:	3a0e0300 	bcc	381664 <_etext+0x37f194>
 a60:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
 a64:	0013490b 	andseq	r4, r3, fp, lsl #18
	...

Disassembly of section .debug_aranges:

00000000 <.debug_aranges>:
   0:	0000001c 	andeq	r0, r0, ip, lsl r0
   4:	00000002 	andeq	r0, r0, r2
   8:	00040000 	andeq	r0, r4, r0
   c:	00000000 	andeq	r0, r0, r0
  10:	000001d0 	ldrdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
  14:	0000004c 	andeq	r0, r0, ip, asr #32
	...
  20:	0000001c 	andeq	r0, r0, ip, lsl r0
  24:	00260002 	eoreq	r0, r6, r2
  28:	00040000 	andeq	r0, r4, r0
  2c:	00000000 	andeq	r0, r0, r0
  30:	0000021c 	andeq	r0, r0, ip, lsl r2
  34:	000000c8 	andeq	r0, r0, r8, asr #1
	...
  40:	0000001c 	andeq	r0, r0, ip, lsl r0
  44:	023e0002 	eorseq	r0, lr, #2
  48:	00040000 	andeq	r0, r4, r0
  4c:	00000000 	andeq	r0, r0, r0
  50:	000002e4 	andeq	r0, r0, r4, ror #5
  54:	0000003e 	andeq	r0, r0, lr, lsr r0
	...
  60:	0000001c 	andeq	r0, r0, ip, lsl r0
  64:	03110002 	tsteq	r1, #2
  68:	00040000 	andeq	r0, r4, r0
  6c:	00000000 	andeq	r0, r0, r0
  70:	00000324 	andeq	r0, r0, r4, lsr #6
  74:	000018ec 	andeq	r1, r0, ip, ror #17
	...
  80:	0000001c 	andeq	r0, r0, ip, lsl r0
  84:	190b0002 	stmdbne	fp, {r1}
  88:	00040000 	andeq	r0, r4, r0
  8c:	00000000 	andeq	r0, r0, r0
  90:	00001c10 	andeq	r1, r0, r0, lsl ip
  94:	0000015e 	andeq	r0, r0, lr, asr r1
	...
  a0:	0000001c 	andeq	r0, r0, ip, lsl r0
  a4:	1ba50002 	blne	fe9400b4 <__StackTop+0xde93e0b4>
  a8:	00040000 	andeq	r0, r4, r0
  ac:	00000000 	andeq	r0, r0, r0
  b0:	00001d70 	andeq	r1, r0, r0, ror sp
  b4:	000004e8 	andeq	r0, r0, r8, ror #9
	...
  c0:	0000001c 	andeq	r0, r0, ip, lsl r0
  c4:	20510002 	subscs	r0, r1, r2
  c8:	00040000 	andeq	r0, r4, r0
  cc:	00000000 	andeq	r0, r0, r0
  d0:	00002258 	andeq	r2, r0, r8, asr r2
  d4:	00000260 	andeq	r0, r0, r0, ror #4
	...

Disassembly of section .debug_str:

00000000 <.debug_str>:
       0:	746f6f62 	strbtvc	r6, [pc], #-3938	@ 8 <_stext+0x8>
       4:	2f00532e 	svccs	0x0000532e
       8:	6b726f77 	blvs	1c9bdec <_etext+0x1c9991c>
       c:	63617073 	cmnvs	r1, #115	@ 0x73
      10:	462f7365 	strtmi	r7, [pc], -r5, ror #6
      14:	52656572 	rsbpl	r6, r5, #478150656	@ 0x1c800000
      18:	2f534f54 	svccs	0x00534f54
      1c:	74726f70 	ldrbtvc	r6, [r2], #-3952	@ 0xfffff090
      20:	554e4700 	strbpl	r4, [lr, #-1792]	@ 0xfffff900
      24:	20534120 	subscs	r4, r3, r0, lsr #2
      28:	32342e32 	eorscc	r2, r4, #800	@ 0x320
      2c:	64735f00 	ldrbtvs	r5, [r3], #-3840	@ 0xfffff100
      30:	00617461 	rsbeq	r7, r1, r1, ror #8
      34:	6b736154 	blvs	1cd858c <_etext+0x1cd60bc>
      38:	636e7546 	cmnvs	lr, #293601280	@ 0x11800000
      3c:	6e6f6974 			@ <UNDEFINED> instruction: 0x6e6f6974
      40:	4700745f 	smlsdmi	r0, pc, r4, r7	@ <UNPREDICTABLE>
      44:	4320554e 			@ <UNDEFINED> instruction: 0x4320554e
      48:	31203731 			@ <UNDEFINED> instruction: 0x31203731
      4c:	2e322e33 	mrccs	14, 1, r2, cr2, cr3, {1}
      50:	30322031 	eorscc	r2, r2, r1, lsr r0
      54:	30313332 	eorscc	r3, r1, r2, lsr r3
      58:	2d203930 			@ <UNDEFINED> instruction: 0x2d203930
      5c:	7568746d 	strbvc	r7, [r8, #-1133]!	@ 0xfffffb93
      60:	2d20626d 	sfmcs	f6, 4, [r0, #-436]!	@ 0xfffffe4c
      64:	7570636d 	ldrbvc	r6, [r0, #-877]!	@ 0xfffffc93
      68:	726f633d 	rsbvc	r6, pc, #-201326592	@ 0xf4000000
      6c:	2d786574 	cfldr64cs	mvdx6, [r8, #-464]!	@ 0xfffffe30
      70:	2d20336d 	stccs	3, cr3, [r0, #-436]!	@ 0xfffffe4c
      74:	6f6c666d 	svcvs	0x006c666d
      78:	612d7461 			@ <UNDEFINED> instruction: 0x612d7461
      7c:	733d6962 	teqvc	sp, #1605632	@ 0x188000
      80:	2074666f 	rsbscs	r6, r4, pc, ror #12
      84:	72616d2d 	rsbvc	r6, r1, #2880	@ 0xb40
      88:	613d6863 	teqvs	sp, r3, ror #16
      8c:	37766d72 			@ <UNDEFINED> instruction: 0x37766d72
      90:	2d206d2d 	stccs	13, cr6, [r0, #-180]!	@ 0xffffff4c
      94:	68730067 	ldmdavs	r3!, {r0, r1, r2, r5, r6}^
      98:	2074726f 	rsbscs	r7, r4, pc, ror #4
      9c:	00746e69 	rsbseq	r6, r4, r9, ror #28
      a0:	726f5078 	rsbvc	r5, pc, #120	@ 0x78
      a4:	61745374 	cmnvs	r4, r4, ror r3
      a8:	63537472 	cmpvs	r3, #1912602624	@ 0x72000000
      ac:	75646568 	strbvc	r6, [r4, #-1384]!	@ 0xfffffa98
      b0:	0072656c 	rsbseq	r6, r2, ip, ror #10
      b4:	6b736154 	blvs	1cd860c <_etext+0x1cd613c>
      b8:	646e6148 	strbtvs	r6, [lr], #-328	@ 0xfffffeb8
      bc:	745f656c 	ldrbvc	r6, [pc], #-1388	@ c4 <_stext+0xc4>
      c0:	64655f00 	strbtvs	r5, [r5], #-3840	@ 0xfffff100
      c4:	00617461 	rsbeq	r7, r1, r1, ror #8
      c8:	73615476 	cmnvc	r1, #1979711488	@ 0x76000000
      cc:	6c00326b 	sfmvs	f3, 4, [r0], {107}	@ 0x6b
      d0:	20676e6f 	rsbcs	r6, r7, pc, ror #28
      d4:	676e6f6c 	strbvs	r6, [lr, -ip, ror #30]!
      d8:	746e6920 	strbtvc	r6, [lr], #-2336	@ 0xfffff6e0
      dc:	62655f00 	rsbvs	r5, r5, #0, 30
      e0:	74007373 	strvc	r7, [r0], #-883	@ 0xfffffc8d
      e4:	61546b73 	cmpvs	r4, r3, ror fp
      e8:	6f436b73 	svcvs	0x00436b73
      ec:	6f72746e 	svcvs	0x0072746e
      f0:	6f6c426c 	svcvs	0x006c426c
      f4:	6c006b63 			@ <UNDEFINED> instruction: 0x6c006b63
      f8:	20676e6f 	rsbcs	r6, r7, pc, ror #28
      fc:	62756f64 	rsbsvs	r6, r5, #100, 30	@ 0x190
     100:	5f00656c 	svcpl	0x0000656c
     104:	61646973 	smcvs	18067	@ 0x4693
     108:	75006174 	strvc	r6, [r0, #-372]	@ 0xfffffe8c
     10c:	6769736e 	strbvs	r7, [r9, -lr, ror #6]!
     110:	2064656e 	rsbcs	r6, r4, lr, ror #10
     114:	72616863 	rsbvc	r6, r1, #6488064	@ 0x630000
     118:	6e6f6c00 	cdpvs	12, 6, cr6, cr15, cr0, {0}
     11c:	6f6c2067 	svcvs	0x006c2067
     120:	7520676e 	strvc	r6, [r0, #-1902]!	@ 0xfffff892
     124:	6769736e 	strbvs	r7, [r9, -lr, ror #6]!
     128:	2064656e 	rsbcs	r6, r4, lr, ror #10
     12c:	00746e69 	rsbseq	r6, r4, r9, ror #28
     130:	746e6975 	strbtvc	r6, [lr], #-2421	@ 0xfffff68b
     134:	745f3233 	ldrbvc	r3, [pc], #-563	@ 13c <_stext+0x13c>
     138:	61547600 	cmpvs	r4, r0, lsl #12
     13c:	00316b73 	eorseq	r6, r1, r3, ror fp
     140:	61507670 	cmpvs	r0, r0, ror r6
     144:	656d6172 	strbvs	r6, [sp, #-370]!	@ 0xfffffe8e
     148:	73726574 	cmnvc	r2, #116, 10	@ 0x1d000000
     14c:	61747300 	cmnvs	r4, r0, lsl #6
     150:	73007472 	movwvc	r7, #1138	@ 0x472
     154:	74726f68 	ldrbtvc	r6, [r2], #-3944	@ 0xfffff098
     158:	736e7520 	cmnvc	lr, #32, 10	@ 0x8000000
     15c:	656e6769 	strbvs	r6, [lr, #-1897]!	@ 0xfffff897
     160:	6e692064 	cdpvs	0, 6, cr2, cr9, cr4, {3}
     164:	54780074 	ldrbtpl	r0, [r8], #-116	@ 0xffffff8c
     168:	436b7361 	cmnmi	fp, #-2080374783	@ 0x84000001
     16c:	74616572 	strbtvc	r6, [r1], #-1394	@ 0xfffffa8e
     170:	42550065 	subsmi	r0, r5, #101	@ 0x65
     174:	54657361 	strbtpl	r7, [r5], #-865	@ 0xfffffc9f
     178:	5f657079 	svcpl	0x00657079
     17c:	74530074 	ldrbvc	r0, [r3], #-116	@ 0xffffff8c
     180:	546b6361 	strbtpl	r6, [fp], #-865	@ 0xfffffc9f
     184:	5f657079 	svcpl	0x00657079
     188:	74730074 	ldrbtvc	r0, [r3], #-116	@ 0xffffff8c
     18c:	2e747261 	cdpcs	2, 7, cr7, cr4, cr1, {3}
     190:	735f0063 	cmpvc	pc, #99	@ 0x63
     194:	00737362 	rsbseq	r7, r3, r2, ror #6
     198:	657a6973 	ldrbvs	r6, [sl, #-2419]!	@ 0xfffff68d
     19c:	7000745f 	andvc	r7, r0, pc, asr r4
     1a0:	4674726f 	ldrbtmi	r7, [r4], -pc, ror #4
     1a4:	74636e75 	strbtvc	r6, [r3], #-3701	@ 0xfffff18b
     1a8:	736e6f69 	cmnvc	lr, #420	@ 0x1a4
     1ac:	6400632e 	strvs	r6, [r0], #-814	@ 0xfffffcd2
     1b0:	00747365 	rsbseq	r7, r4, r5, ror #6
     1b4:	756c6176 	strbvc	r6, [ip, #-374]!	@ 0xfffffe8a
     1b8:	6f630065 	svcvs	0x00630065
     1bc:	00746e75 	rsbseq	r6, r4, r5, ror lr
     1c0:	736d656d 	cmnvc	sp, #457179136	@ 0x1b400000
     1c4:	78007465 	stmdavc	r0, {r0, r2, r5, r6, sl, ip, sp, lr}
     1c8:	65726f43 	ldrbvs	r6, [r2, #-3907]!	@ 0xfffff0bd
     1cc:	70004449 	andvc	r4, r0, r9, asr #8
    ldr r0, =_sidata            /* Address of init values in flash */
     1d0:	73615463 	cmnvc	r1, #1660944384	@ 0x63000000
    ldr r2, =_edata             /* End of .data in RAM */
     1d4:	6d614e6b 	stclvs	14, cr4, [r1, #-428]!	@ 0xfffffe54
    bcs zero_bss
     1d8:	78750065 	ldmdavc	r5!, {r0, r2, r5, r6}^
    ldr r3, [r0], #4
     1dc:	626d754e 	rsbvs	r7, sp, #327155712	@ 0x13800000
    str r3, [r1], #4
     1e0:	664f7265 	strbvs	r7, [pc], -r5, ror #4
    ldr r0, =_sbss              /* Start of .bss */
     1e4:	6d657449 	cfstrdvs	mvd7, [r5, #-292]!	@ 0xfffffedc
    cmp r0, r1
     1e8:	50760073 	rsbspl	r0, r6, r3, ror r0
    movs r2, #0
     1ec:	4574726f 	ldrbmi	r7, [r4, #-623]!	@ 0xfffffd91
    str r2, [r0], #4
     1f0:	43746978 	cmnmi	r4, #120, 18	@ 0x1e0000
    bl start                    /* Call main/start function */
     1f4:	69746972 	ldmdbvs	r4!, {r1, r4, r5, r6, r8, fp, sp, lr}^
    b hang                      /* If it returns, hang forever */
     1f8:	006c6163 	rsbeq	r6, ip, r3, ror #2
    b .
     1fc:	72507875 	subsvc	r7, r0, #7667712	@ 0x750000
    b .
     200:	69726f69 	ldmdbvs	r2!, {r0, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
    b .
     204:	70007974 	andvc	r7, r0, r4, ror r9
    ldr r0, =_sidata            /* Address of init values in flash */
     208:	6e6f4378 	mcrvs	3, 3, r4, cr15, cr8, {3}
    ldr r1, =_sdata             /* Start of .data in RAM */
     20c:	694c7473 	stmdbvs	ip, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
    ldr r2, =_edata             /* End of .data in RAM */
     210:	75007473 	strvc	r7, [r0, #-1139]	@ 0xfffffb8d
    ldr r0, =_sbss              /* Start of .bss */
     214:	7469426c 	strbtvc	r4, [r9], #-620	@ 0xfffffd94
    ldr r1, =_ebss              /* End of .bss */
     218:	436f5473 	cmnmi	pc, #1929379840	@ 0x73000000
static void vTask1(void *pvParameters){
     21c:	7261656c 	rsbvc	r6, r1, #108, 10	@ 0x1b000000
     220:	78456e4f 	stmdavc	r5, {r0, r1, r2, r3, r6, r9, sl, fp, sp, lr}^
    volatile int a =0;
     224:	75007469 	strvc	r7, [r0, #-1129]	@ 0xfffffb97
        a++;
     228:	73615478 	cmnvc	r1, #120, 8	@ 0x78000000
     22c:	7465476b 	strbtvc	r4, [r5], #-1899	@ 0xfffff895
static void vTask2(void *pvParameters){
     230:	626d754e 	rsbvs	r7, sp, #327155712	@ 0x13800000
     234:	664f7265 	strbvs	r7, [pc], -r5, ror #4
    volatile int b =0;
     238:	6b736154 	blvs	1cd8790 <_etext+0x1cd62c0>
        b++;
     23c:	78700073 	ldmdavc	r0!, {r0, r1, r4, r5, r6}^
     240:	68676948 	stmdavs	r7!, {r3, r6, r8, fp, sp, lr}^
void start(){
     244:	72507265 	subsvc	r7, r0, #1342177286	@ 0x50000006
     248:	69726f69 	ldmdbvs	r2!, {r0, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
    uint32_t *src = &_sidata;//Source flash
     24c:	61547974 	cmpvs	r4, r4, ror r9
    uint32_t *dst = &_sdata;//Destination RAM
     250:	6f576b73 	svcvs	0x00576b73
        *dst++ = *src++; //copy word and increment pointer
     254:	006e656b 	rsbeq	r6, lr, fp, ror #10
     258:	416f4e65 	cmnmi	pc, r5, ror #28
     25c:	6f697463 	svcvs	0x00697463
     260:	7875006e 	ldmdavc	r5!, {r1, r2, r3, r5, r6}^
    while(dst < &_edata){
     264:	52706f54 	rsbspl	r6, r0, #84, 30	@ 0x150
     268:	79646165 	stmdbvc	r4!, {r0, r2, r5, r6, r8, sp, lr}^
    dst = &_sbss;
     26c:	6f697250 	svcvs	0x00697250
    while(dst < &_ebss){
     270:	79746972 	ldmdbvc	r4!, {r1, r4, r5, r6, r8, fp, sp, lr}^
        *dst++ = 0; //zero word and increment pointer
     274:	44787000 	ldrbtmi	r7, [r8], #-0
     278:	79616c65 	stmdbvc	r1!, {r0, r2, r5, r6, sl, fp, sp, lr}^
    while(dst < &_ebss){
     27c:	694c6465 	stmdbvs	ip, {r0, r2, r5, r6, sl, sp, lr}^
     280:	70007473 	andvc	r7, r0, r3, ror r4
    xReturn = xTaskCreate(vTask1,"T1",configMINIMAL_STACK_SIZE,NULL,1,NULL);  // 256*4 = 1k stack size
     284:	65764578 	ldrbvs	r4, [r6, #-1400]!	@ 0xfffffa88
     288:	694c746e 	stmdbvs	ip, {r1, r2, r3, r5, r6, sl, ip, sp, lr}^
     28c:	78007473 	stmdavc	r0, {r0, r1, r4, r5, r6, sl, ip, sp, lr}
     290:	65686353 	strbvs	r6, [r8, #-851]!	@ 0xfffffcad
     294:	656c7564 	strbvs	r7, [ip, #-1380]!	@ 0xfffffa9c
     298:	6e755272 	mrcvs	2, 3, r5, cr5, cr2, {3}
    xReturn = xTaskCreate(vTask2,"T2",configMINIMAL_STACK_SIZE,NULL,1,NULL);
     29c:	676e696e 	strbvs	r6, [lr, -lr, ror #18]!
     2a0:	49787000 	ldmdbmi	r8!, {ip, sp, lr}^
     2a4:	7865646e 	stmdavc	r5!, {r1, r2, r3, r5, r6, sl, sp, lr}^
     2a8:	49547800 	ldmdbmi	r4, {fp, ip, sp, lr}^
     2ac:	4f5f454d 	svcmi	0x005f454d
     2b0:	75005455 	strvc	r5, [r0, #-1109]	@ 0xfffffbab
    xPortStartScheduler();
     2b4:	7469426c 	strbtvc	r4, [r9], #-620	@ 0xfffffd94
    return;
     2b8:	436f5473 	cmnmi	pc, #1929379840	@ 0x73000000
     2bc:	7261656c 	rsbvc	r6, r1, #108, 10	@ 0x1b000000
     2c0:	65507800 	ldrbvs	r7, [r0, #-2048]	@ 0xfffff800
     2c4:	6465646e 	strbtvs	r6, [r5], #-1134	@ 0xfffffb92
     2c8:	6e756f43 	cdpvs	15, 7, cr6, cr5, cr3, {2}
     2cc:	78007374 	stmdavc	r0, {r2, r4, r5, r6, r8, r9, ip, sp, lr}
     2d0:	5453494c 	ldrbpl	r4, [r3], #-2380	@ 0xfffff6b4
     2d4:	4554495f 	ldrbmi	r4, [r4, #-2399]	@ 0xfffff6a1
     2d8:	7870004d 	ldmdavc	r0!, {r0, r2, r3, r6}^
     2dc:	64616552 	strbtvs	r6, [r1], #-1362	@ 0xfffffaae
     2e0:	73615479 	cmnvc	r1, #2030043136	@ 0x79000000
void *memset(void *dest, int c, size_t count) {
     2e4:	694c736b 	stmdbvs	ip, {r0, r1, r3, r5, r6, r8, r9, ip, sp, lr}^
     2e8:	00737473 	rsbseq	r7, r3, r3, ror r4
     2ec:	724f6375 	subvc	r6, pc, #-738197503	@ 0xd4000001
    unsigned char *ptr = (unsigned char *)dest;
     2f0:	6e696769 	cdpvs	7, 6, cr6, cr9, cr9, {3}
    unsigned char value = (unsigned char)c;
     2f4:	6f4e6c61 	svcvs	0x004e6c61
    for (size_t i = 0; i < count; i++) {
     2f8:	79666974 	stmdbvc	r6!, {r2, r4, r5, r6, r8, fp, sp, lr}^
     2fc:	74617453 	strbtvc	r7, [r1], #-1107	@ 0xfffffbad
        ptr[i] = value;
     300:	54760065 	ldrbtpl	r0, [r6], #-101	@ 0xffffff9b
     304:	536b7361 	cmnpl	fp, #-2080374783	@ 0x84000001
    for (size_t i = 0; i < count; i++) {
     308:	69547465 	ldmdbvs	r4, {r0, r2, r5, r6, sl, ip, sp, lr}^
     30c:	754f656d 	strbvc	r6, [pc, #-1389]	@ fffffda7 <__StackTop+0xdfffdda7>
     310:	61745374 	cmnvs	r4, r4, ror r3
     314:	78006574 	stmdavc	r0, {r2, r4, r5, r6, r8, sl, sp, lr}
     318:	6b736154 	blvs	1cd8870 <_etext+0x1cd63a0>
     31c:	656e6547 	strbvs	r6, [lr, #-1351]!	@ 0xfffffab9
     320:	4e636972 			@ <UNDEFINED> instruction: 0x4e636972
    {
     324:	6669746f 	strbtvs	r7, [r9], -pc, ror #8
     328:	6f724679 	svcvs	0x00724679
     32c:	5253496d 	subspl	r4, r3, #1785856	@ 0x1b4000
     330:	69597800 	ldmdbvs	r9, {fp, ip, sp, lr}^
            pxStack = pvPortMallocStack( ( ( ( size_t ) uxStackDepth ) * sizeof( StackType_t ) ) );
     334:	50646c65 	rsbpl	r6, r4, r5, ror #24
     338:	69646e65 	stmdbvs	r4!, {r0, r2, r5, r6, r9, sl, fp, sp, lr}^
     33c:	0073676e 	rsbseq	r6, r3, lr, ror #14
            if( pxStack != NULL )
     340:	73615478 	cmnvc	r1, #120, 8	@ 0x78000000
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
     344:	636e496b 	cmnvs	lr, #1753088	@ 0x1ac000
     348:	656d6572 	strbvs	r6, [sp, #-1394]!	@ 0xfffffa8e
                if( pxNewTCB != NULL )
     34c:	6954746e 	ldmdbvs	r4, {r1, r2, r3, r5, r6, sl, ip, sp, lr}^
     350:	75006b63 	strvc	r6, [r0, #-2915]	@ 0xfffff49d
                    ( void ) memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
     354:	7469426c 	strbtvc	r4, [r9], #-620	@ 0xfffffd94
     358:	0070616d 	rsbseq	r6, r0, sp, ror #2
                    pxNewTCB->pxStack = pxStack;
     35c:	6c654478 	cfstrdvs	mvd4, [r5], #-480	@ 0xfffffe20
     360:	64657961 	strbtvs	r7, [r5], #-2401	@ 0xfffff69f
                    vPortFreeStack( pxStack );
     364:	6b736154 	blvs	1cd88bc <_etext+0x1cd63ec>
     368:	7473694c 	ldrbtvc	r6, [r3], #-2380	@ 0xfffff6b4
                pxNewTCB = NULL;
     36c:	44780031 	ldrbtmi	r0, [r8], #-49	@ 0xffffffcf
        if( pxNewTCB != NULL )
     370:	79616c65 	stmdbvc	r1!, {r0, r2, r5, r6, sl, fp, sp, lr}^
     374:	61546465 	cmpvs	r4, r5, ror #8
            prvInitialiseNewTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
     378:	694c6b73 	stmdbvs	ip, {r0, r1, r4, r5, r6, r8, r9, fp, sp, lr}^
     37c:	00327473 	eorseq	r7, r2, r3, ror r4
     380:	65764f78 	ldrbvs	r4, [r6, #-3960]!	@ 0xfffff088
     384:	6f6c6672 	svcvs	0x006c6672
     388:	756f4377 	strbvc	r4, [pc, #-887]!	@ 19 <_stext+0x19>
     38c:	7600746e 	strvc	r7, [r0], -lr, ror #8
     390:	74726f50 	ldrbtvc	r6, [r2], #-3920	@ 0xfffff0b0
    }
     394:	42746553 	rsbsmi	r6, r4, #348127232	@ 0x14c00000
     398:	50455341 	subpl	r5, r5, r1, asr #6
    {
     39c:	76004952 			@ <UNDEFINED> instruction: 0x76004952
     3a0:	74726f50 	ldrbtvc	r6, [r2], #-3920	@ 0xfffff0b0
     3a4:	65746e45 	ldrbvs	r6, [r4, #-3653]!	@ 0xfffff1bb
     3a8:	69724372 	ldmdbvs	r2!, {r1, r4, r5, r6, r8, r9, lr}^
        pxNewTCB = prvCreateTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask );
     3ac:	61636974 	smcvs	13972	@ 0x3694
     3b0:	5478006c 	ldrbtpl	r0, [r8], #-108	@ 0xffffff94
     3b4:	436b7361 	cmnmi	fp, #-2080374783	@ 0x84000001
     3b8:	68637461 	stmdavs	r3!, {r0, r5, r6, sl, ip, sp, lr}^
     3bc:	69547055 	ldmdbvs	r4, {r0, r2, r4, r6, ip, sp, lr}^
        if( pxNewTCB != NULL )
     3c0:	00736b63 	rsbseq	r6, r3, r3, ror #22
     3c4:	61506c75 	cmpvs	r0, r5, ror ip
            prvAddNewTaskToReadyList( pxNewTCB );
     3c8:	656d6172 	strbvs	r6, [sp, #-370]!	@ 0xfffffe8e
            xReturn = pdPASS;
     3cc:	73726574 	cmnvc	r2, #116, 10	@ 0x1d000000
     3d0:	49787500 	ldmdbmi	r8!, {r8, sl, ip, sp, lr}^
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     3d4:	7865646e 	stmdavc	r5!, {r1, r2, r3, r5, r6, sl, sp, lr}^
        return xReturn;
     3d8:	6c436f54 	mcrrvs	15, 5, r6, r3, cr4
    }
     3dc:	00726165 	rsbseq	r6, r2, r5, ror #2
     3e0:	546b7374 	strbtpl	r7, [fp], #-884	@ 0xfffffc8c
{
     3e4:	75004243 	strvc	r4, [r0, #-579]	@ 0xfffffdbd
     3e8:	76615378 			@ <UNDEFINED> instruction: 0x76615378
     3ec:	6e496465 	cdpvs	4, 4, cr6, cr9, cr5, {3}
        pxTopOfStack = &( pxNewTCB->pxStack[ uxStackDepth - ( configSTACK_DEPTH_TYPE ) 1 ] );
     3f0:	72726574 	rsbsvc	r6, r2, #116, 10	@ 0x1d000000
     3f4:	53747075 	cmnpl	r4, #117	@ 0x75
     3f8:	75746174 	ldrbvc	r6, [r4, #-372]!	@ 0xfffffe8c
     3fc:	63750073 	cmnvs	r5, #115	@ 0x73
     400:	69746f4e 	ldmdbvs	r4!, {r1, r2, r3, r6, r8, r9, sl, fp, sp, lr}^
        pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     404:	74537966 	ldrbvc	r7, [r3], #-2406	@ 0xfffff69a
     408:	00657461 	rsbeq	r7, r5, r1, ror #8
    if( pcName != NULL )
     40c:	694c7875 	stmdbvs	ip, {r0, r2, r4, r5, r6, fp, ip, sp, lr}^
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     410:	65527473 	ldrbvs	r7, [r2, #-1139]	@ 0xfffffb8d
     414:	65766f6d 	ldrbvs	r6, [r6, #-3949]!	@ 0xfffff093
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     418:	4f6c7500 	svcmi	0x006c7500
     41c:	69676972 	stmdbvs	r7!, {r1, r4, r5, r6, r8, fp, sp, lr}^
     420:	426c616e 	rsbmi	r6, ip, #-2147483621	@ 0x8000001b
     424:	50455341 	subpl	r5, r5, r1, asr #6
     428:	78004952 	stmdavc	r0, {r1, r4, r6, r8, fp, lr}
            if( pcName[ x ] == ( char ) 0x00 )
     42c:	6b736154 	blvs	1cd8984 <_etext+0x1cd64b4>
     430:	656e6547 	strbvs	r6, [lr, #-1351]!	@ 0xfffffab9
     434:	4e636972 			@ <UNDEFINED> instruction: 0x4e636972
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     438:	6669746f 	strbtvs	r7, [r9], -pc, ror #8
     43c:	78700079 	ldmdavc	r0!, {r0, r3, r4, r5, r6}^
     440:	6c626e55 	stclvs	14, cr6, [r2], #-340	@ 0xfffffeac
                break;
     444:	656b636f 	strbvs	r6, [fp, #-879]!	@ 0xfffffc91
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1U ] = '\0';
     448:	42435464 	submi	r5, r3, #100, 8	@ 0x64000000
     44c:	6c437800 	mcrrvs	8, 0, r7, r3, cr0
    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
     450:	43726165 	cmnmi	r2, #1073741849	@ 0x40000019
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
     454:	746e756f 	strbtvc	r7, [lr], #-1391	@ 0xfffffa91
    pxNewTCB->uxPriority = uxPriority;
     458:	78456e4f 	stmdavc	r5, {r0, r1, r2, r3, r6, r9, sl, fp, sp, lr}^
     45c:	70007469 	andvc	r7, r0, r9, ror #8
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     460:	72437672 	subvc	r7, r3, #119537664	@ 0x7200000
     464:	65746165 	ldrbvs	r6, [r4, #-357]!	@ 0xfffffe9b
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     468:	6b736154 	blvs	1cd89c0 <_etext+0x1cd64f0>
     46c:	6c457800 	mcrrvs	8, 0, r7, r5, cr0
     470:	65737061 	ldrbvs	r7, [r3, #-97]!	@ 0xffffff9f
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     474:	6d695464 	cfstrdvs	mvd5, [r9, #-400]!	@ 0xfffffe70
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority );
     478:	53650065 	cmnpl	r5, #101	@ 0x65
     47c:	61567465 	cmpvs	r6, r5, ror #8
     480:	5765756c 	strbpl	r7, [r5, -ip, ror #10]!
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     484:	4f687469 	svcmi	0x00687469
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     488:	77726576 			@ <UNDEFINED> instruction: 0x77726576
     48c:	65746972 	ldrbvs	r6, [r4, #-2418]!	@ 0xfffff68e
     490:	61547800 	cmpvs	r4, r0, lsl #16
     494:	65476b73 	strbvs	r6, [r7, #-2931]	@ 0xfffff48d
    if( pxCreatedTask != NULL )
     498:	63695474 	cmnvs	r9, #116, 8	@ 0x74000000
     49c:	756f436b 	strbvc	r4, [pc, #-875]!	@ 139 <_stext+0x139>
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     4a0:	7246746e 	subvc	r7, r6, #1845493760	@ 0x6e000000
}
     4a4:	53496d6f 	movtpl	r6, #40303	@ 0x9d6f
     4a8:	6c750052 	ldclvs	0, cr0, [r5], #-328	@ 0xfffffeb8
    {
     4ac:	73746942 	cmnvc	r4, #1081344	@ 0x108000
     4b0:	6c436f54 	mcrrvs	15, 5, r6, r3, cr4
        taskENTER_CRITICAL();
     4b4:	4f726165 	svcmi	0x00726165
            uxCurrentNumberOfTasks = ( UBaseType_t ) ( uxCurrentNumberOfTasks + 1U );
     4b8:	746e456e 	strbtvc	r4, [lr], #-1390	@ 0xfffffa92
     4bc:	78007972 	stmdavc	r0, {r1, r4, r5, r6, r8, fp, ip, sp, lr}
     4c0:	656c6449 	strbvs	r6, [ip, #-1097]!	@ 0xfffffbb7
            if( pxCurrentTCB == NULL )
     4c4:	6b736154 	blvs	1cd8a1c <_etext+0x1cd654c>
     4c8:	656d614e 	strbvs	r6, [sp, #-334]!	@ 0xfffffeb2
                pxCurrentTCB = pxNewTCB;
     4cc:	65646e49 	strbvs	r6, [r4, #-3657]!	@ 0xfffff1b7
                if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     4d0:	50780078 	rsbspl	r0, r8, r8, ror r0
     4d4:	69646e65 	stmdbvs	r4!, {r0, r2, r5, r6, r9, sl, fp, sp, lr}^
                    prvInitialiseTaskLists();
     4d8:	6552676e 	ldrbvs	r6, [r2, #-1902]	@ 0xfffff892
     4dc:	4c796461 	cfldrdmi	mvd6, [r9], #-388	@ 0xfffffe7c
                if( xSchedulerRunning == pdFALSE )
     4e0:	00747369 	rsbseq	r7, r4, r9, ror #6
     4e4:	49767270 	ldmdbmi	r6!, {r4, r5, r6, r9, ip, sp, lr}^
                    if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     4e8:	6974696e 	ldmdbvs	r4!, {r1, r2, r3, r5, r6, r8, fp, sp, lr}^
     4ec:	73696c61 	cmnvc	r9, #24832	@ 0x6100
     4f0:	73615465 	cmnvc	r1, #1694498816	@ 0x65000000
                        pxCurrentTCB = pxNewTCB;
     4f4:	73694c6b 	cmnvc	r9, #27392	@ 0x6b00
     4f8:	70007374 	andvc	r7, r0, r4, ror r3
            uxTaskNumber++;
     4fc:	65725078 	ldrbvs	r5, [r2, #-120]!	@ 0xffffff88
     500:	756f6976 	strbvc	r6, [pc, #-2422]!	@ fffffb92 <__StackTop+0xdfffdb92>
            prvAddTaskToReadyList( pxNewTCB );
     504:	54760073 	ldrbtpl	r0, [r6], #-115	@ 0xffffff8d
     508:	526b7361 	rsbpl	r7, fp, #-2080374783	@ 0x84000001
     50c:	74657365 	strbtvc	r7, [r5], #-869	@ 0xfffffc9b
     510:	74617453 	strbtvc	r7, [r1], #-1107	@ 0xfffffbad
     514:	78700065 	ldmdavc	r0!, {r0, r2, r5, r6}^
     518:	706d6554 	rsbvc	r6, sp, r4, asr r5
     51c:	54787500 	ldrbtpl	r7, [r8], #-1280	@ 0xfffffb00
     520:	7355706f 	cmpvc	r5, #111	@ 0x6f
     524:	72506465 	subsvc	r6, r0, #1694498816	@ 0x65000000
     528:	69726f69 	ldmdbvs	r2!, {r0, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
     52c:	76007974 			@ <UNDEFINED> instruction: 0x76007974
     530:	6b736154 	blvs	1cd8a88 <_etext+0x1cd65b8>
     534:	70737553 	rsbsvc	r7, r3, r3, asr r5
     538:	41646e65 	cmnmi	r4, r5, ror #28
     53c:	75006c6c 	strvc	r6, [r0, #-3180]	@ 0xfffff394
     540:	61745378 	cmnvs	r4, r8, ror r3
     544:	65446b63 	strbvs	r6, [r4, #-2915]	@ 0xfffff49d
     548:	00687470 	rsbeq	r7, r8, r0, ror r4
     54c:	746f4e65 	strbtvc	r4, [pc], #-3685	@ 554 <prvAddNewTaskToReadyList+0xa8>
     550:	41796669 	cmnmi	r9, r9, ror #12
     554:	6f697463 	svcvs	0x00697463
     558:	4965006e 	stmdbmi	r5!, {r1, r2, r3, r5, r6}^
     55c:	6572636e 	ldrbvs	r6, [r2, #-878]!	@ 0xfffffc92
     560:	746e656d 	strbtvc	r6, [lr], #-1389	@ 0xfffffa93
     564:	494d7800 	stmdbmi	sp, {fp, ip, sp, lr}^
     568:	4c5f494e 	mrrcmi	9, 4, r4, pc, cr14	@ <UNPREDICTABLE>
     56c:	5f545349 	svcpl	0x00545349
     570:	4d455449 	cfstrdmi	mvd5, [r5, #-292]	@ 0xfffffedc
     574:	69547800 	ldmdbvs	r4, {fp, ip, sp, lr}^
     578:	6f436b63 	svcvs	0x00436b63
     57c:	00746e75 	rsbseq	r6, r4, r5, ror lr
     580:	53494c78 	movtpl	r4, #40056	@ 0x9c78
     584:	54760054 	ldrbtpl	r0, [r6], #-84	@ 0xffffffac
        taskEXIT_CRITICAL();
     588:	456b7361 	strbmi	r7, [fp, #-865]!	@ 0xfffffc9f
        if( xSchedulerRunning != pdFALSE )
     58c:	6353646e 	cmpvs	r3, #1845493760	@ 0x6e000000
     590:	75646568 	strbvc	r6, [r4, #-1384]!	@ 0xfffffa98
            taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxNewTCB );
     594:	0072656c 	rsbseq	r6, r2, ip, ror #10
     598:	6e6f4378 	mcrvs	3, 3, r4, cr15, cr8, {3}
     59c:	69547473 	ldmdbvs	r4, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
     5a0:	6f436b63 	svcvs	0x00436b63
     5a4:	00746e75 	rsbseq	r6, r4, r5, ror lr
     5a8:	614e6370 	hvcvs	58928	@ 0xe630
     5ac:	7000656d 	andvc	r6, r0, sp, ror #10
    }
     5b0:	65764f78 	ldrbvs	r4, [r6, #-3960]!	@ 0xfffff088
     5b4:	6f6c6672 	svcvs	0x006c6672
     5b8:	6c654477 	cfstrdvs	mvd4, [r5], #-476	@ 0xfffffe24
     5bc:	64657961 	strbtvs	r7, [r5], #-2401	@ 0xfffff69f
     5c0:	6b736154 	blvs	1cd8b18 <_etext+0x1cd6648>
     5c4:	7473694c 	ldrbtvc	r6, [r3], #-2380	@ 0xfffff6b4
     5c8:	61547600 	cmpvs	r4, r0, lsl #12
     5cc:	6c506b73 	mrrcvs	11, 7, r6, r0, cr3
     5d0:	4f656361 	svcmi	0x00656361
{
     5d4:	6576456e 	ldrbvs	r4, [r6, #-1390]!	@ 0xfffffa92
     5d8:	694c746e 	stmdbvs	ip, {r1, r2, r3, r5, r6, sl, ip, sp, lr}^
    BaseType_t xReturn = pdPASS;
     5dc:	78007473 	stmdavc	r0, {r0, r1, r4, r5, r6, sl, ip, sp, lr}
    char cIdleName[ configMAX_TASK_NAME_LEN ] = { 0 };
     5e0:	656c6449 	strbvs	r6, [ip, #-1097]!	@ 0xfffffbb7
     5e4:	6b736154 	blvs	1cd8b3c <_etext+0x1cd666c>
     5e8:	646e6148 	strbtvs	r6, [lr], #-328	@ 0xfffffeb8
    TaskFunction_t pxIdleTaskFunction = NULL;
     5ec:	0073656c 	rsbseq	r6, r3, ip, ror #10
    for( xIdleTaskNameIndex = 0U; xIdleTaskNameIndex < ( configMAX_TASK_NAME_LEN - taskRESERVED_TASK_NAME_LENGTH ); xIdleTaskNameIndex++ )
     5f0:	6f4e6c75 	svcvs	0x004e6c75
        cIdleName[ xIdleTaskNameIndex ] = configIDLE_TASK_NAME[ xIdleTaskNameIndex ];
     5f4:	69666974 	stmdbvs	r6!, {r2, r4, r5, r6, r8, fp, sp, lr}^
     5f8:	61566465 	cmpvs	r6, r5, ror #8
     5fc:	0065756c 	rsbeq	r7, r5, ip, ror #10
     600:	73615476 	cmnvc	r1, #1979711488	@ 0x76000000
     604:	6d65526b 	sfmvs	f5, 2, [r5, #-428]!	@ 0xfffffe54
        if( cIdleName[ xIdleTaskNameIndex ] == ( char ) 0x00 )
     608:	4665766f 	strbtmi	r7, [r5], -pc, ror #12
     60c:	556d6f72 	strbpl	r6, [sp, #-3954]!	@ 0xfffff08e
     610:	64726f6e 	ldrbtvs	r6, [r2], #-3950	@ 0xfffff092
    for( xIdleTaskNameIndex = 0U; xIdleTaskNameIndex < ( configMAX_TASK_NAME_LEN - taskRESERVED_TASK_NAME_LENGTH ); xIdleTaskNameIndex++ )
     614:	64657265 	strbtvs	r7, [r5], #-613	@ 0xfffffd9b
     618:	6e657645 	cdpvs	6, 6, cr7, cr5, cr5, {2}
     61c:	73694c74 	cmnvc	r9, #116, 24	@ 0x7400
            break;
     620:	54780074 	ldrbtpl	r0, [r8], #-116	@ 0xffffff8c
    cIdleName[ xIdleTaskNameIndex ] = '\0';
     624:	526b7361 	rsbpl	r7, fp, #-2080374783	@ 0x84000001
     628:	766f6d65 	strbtvc	r6, [pc], -r5, ror #26
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
     62c:	6f724665 	svcvs	0x00724665
     630:	6576456d 	ldrbvs	r4, [r6, #-1389]!	@ 0xfffffa93
            pxIdleTaskFunction = &prvIdleTask;
     634:	694c746e 	stmdbvs	ip, {r1, r2, r3, r5, r6, sl, ip, sp, lr}^
            xReturn = xTaskCreate( pxIdleTaskFunction,
     638:	65007473 	strvs	r7, [r0, #-1139]	@ 0xfffffb8d
     63c:	56746553 			@ <UNDEFINED> instruction: 0x56746553
     640:	65756c61 	ldrbvs	r6, [r5, #-3169]!	@ 0xfffff39f
     644:	68746957 	ldmdavs	r4!, {r0, r1, r2, r4, r6, r8, fp, sp, lr}^
     648:	4f74756f 	svcmi	0x0074756f
     64c:	77726576 			@ <UNDEFINED> instruction: 0x77726576
     650:	65746972 	ldrbvs	r6, [r4, #-2418]!	@ 0xfffff68e
        if( xReturn != pdPASS )
     654:	4e6c7500 	cdpmi	5, 6, cr7, cr12, cr0, {0}
     658:	41427765 	cmpmi	r2, r5, ror #14
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
     65c:	52504553 	subspl	r4, r0, #348127232	@ 0x14c00000
     660:	54780049 	ldrbtpl	r0, [r8], #-73	@ 0xffffffb7
     664:	476b7361 	strbmi	r7, [fp, -r1, ror #6]!
            break;
     668:	72656e65 	rsbvc	r6, r5, #1616	@ 0x650
}
     66c:	6f4e6369 	svcvs	0x004e6369
     670:	79666974 	stmdbvc	r6!, {r2, r4, r5, r6, r8, fp, sp, lr}^
     674:	74696157 	strbtvc	r6, [r9], #-343	@ 0xfffffea9
     678:	76727000 	ldrbtvc	r7, [r2], -r0
     67c:	656c6449 	strbvs	r6, [ip, #-1097]!	@ 0xfffffbb7
{
     680:	6b736154 	blvs	1cd8bd8 <_etext+0x1cd6708>
     684:	694c7800 	stmdbvs	ip, {fp, ip, sp, lr}^
    xReturn = prvCreateIdleTasks();
     688:	6e457473 	mcrvs	4, 2, r7, cr5, cr3, {3}
    if( xReturn == pdPASS )
     68c:	6c750064 	ldclvs	0, cr0, [r5], #-400	@ 0xfffffe70
     690:	6b736154 	blvs	1cd8be8 <_etext+0x1cd6718>
    __asm volatile
     694:	656e6547 	strbvs	r6, [lr, #-1351]!	@ 0xfffffab9
     698:	4e636972 			@ <UNDEFINED> instruction: 0x4e636972
     69c:	6669746f 	strbtvs	r7, [r9], -pc, ror #8
     6a0:	6b615479 	blvs	185588c <_etext+0x18533bc>
}
     6a4:	694d0065 	stmdbvs	sp, {r0, r2, r5, r6}^
        xNextTaskUnblockTime = portMAX_DELAY;
     6a8:	694c696e 	stmdbvs	ip, {r1, r2, r3, r5, r6, r8, fp, sp, lr}^
     6ac:	74497473 	strbvc	r7, [r9], #-1139	@ 0xfffffb8d
        xSchedulerRunning = pdTRUE;
     6b0:	745f6d65 	ldrbvc	r6, [pc], #-3429	@ 6b8 <vTaskStartScheduler+0x38>
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
     6b4:	76727000 	ldrbtvc	r7, [r2], -r0
     6b8:	4e646441 	cdpmi	4, 6, cr6, cr4, cr1, {2}
        ( void ) xPortStartScheduler();
     6bc:	61547765 	cmpvs	r4, r5, ror #14
    ( void ) uxTopUsedPriority;
     6c0:	6f546b73 	svcvs	0x00546b73
}
     6c4:	64616552 	strbtvs	r6, [r1], #-1362	@ 0xfffffaae
     6c8:	73694c79 	cmnvc	r9, #30976	@ 0x7900
     6cc:	69750074 	ldmdbvs	r5!, {r2, r4, r5, r6}^
     6d0:	5f38746e 	svcpl	0x0038746e
     6d4:	72700074 	rsbsvc	r0, r0, #116	@ 0x74
     6d8:	65724376 	ldrbvs	r4, [r2, #-886]!	@ 0xfffffc8a
{
     6dc:	49657461 	stmdbmi	r5!, {r0, r5, r6, sl, ip, sp, lr}^
     6e0:	54656c64 	strbtpl	r6, [r5], #-3172	@ 0xfffff39c
    __asm volatile
     6e4:	736b7361 	cmnvc	fp, #-2080374783	@ 0x84000001
     6e8:	4e787000 	cdpmi	0, 7, cr7, cr8, cr0, {0}
     6ec:	43547765 	cmpmi	r4, #26476544	@ 0x1940000
     6f0:	78700042 	ldmdavc	r0!, {r1, r6}^
}
     6f4:	6b736154 	blvs	1cd8c4c <_etext+0x1cd677c>
    xSchedulerRunning = pdFALSE;
     6f8:	65646f43 	strbvs	r6, [r4, #-3907]!	@ 0xfffff0bd
    vPortEndScheduler();
     6fc:	69597800 	ldmdbvs	r9, {fp, ip, sp, lr}^
}
     700:	4f646c65 	svcmi	0x00646c65
     704:	72756363 	rsbsvc	r6, r5, #-1946157055	@ 0x8c000001
     708:	00646572 	rsbeq	r6, r4, r2, ror r5
{
     70c:	6f6d654d 	svcvs	0x006d654d
        uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended + 1U );
     710:	65527972 	ldrbvs	r7, [r2, #-2418]	@ 0xfffff68e
     714:	6e6f6967 	vnmulvs.f16	s13, s30, s15	@ <UNPREDICTABLE>
     718:	7800745f 	stmdavc	r0, {r0, r1, r2, r3, r4, r6, sl, ip, sp, lr}
}
     71c:	7478654e 	ldrbtvc	r6, [r8], #-1358	@ 0xfffffab2
     720:	6b736154 	blvs	1cd8c78 <_etext+0x1cd67a8>
     724:	6c626e55 	stclvs	14, cr6, [r2], #-340	@ 0xfffffeac
{
     728:	546b636f 	strbtpl	r6, [fp], #-879	@ 0xfffffc91
     72c:	00656d69 	rsbeq	r6, r5, r9, ror #26
    TCB_t * pxTCB = NULL;
     730:	6f506c75 	svcvs	0x00506c75
    BaseType_t xAlreadyYielded = pdFALSE;
     734:	61527472 	cmpvs	r2, r2, ror r4
        taskENTER_CRITICAL();
     738:	42657369 	rsbmi	r7, r5, #-1543503871	@ 0xa4000001
            const BaseType_t xCoreID = ( BaseType_t ) portGET_CORE_ID();
     73c:	50455341 	subpl	r5, r5, r1, asr #6
            uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended - 1U );
     740:	70004952 	andvc	r4, r0, r2, asr r9
     744:	726f5078 	rsbvc	r5, pc, #120	@ 0x78
            if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
     748:	696e4974 	stmdbvs	lr!, {r2, r4, r5, r6, r8, fp, lr}^
     74c:	6c616974 			@ <UNDEFINED> instruction: 0x6c616974
     750:	53657369 	cmnpl	r5, #-1543503871	@ 0xa4000001
                if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     754:	6b636174 	blvs	18d8d2c <_etext+0x18d685c>
     758:	52787500 	rsbspl	r7, r8, #0, 10
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     75c:	72757465 	rsbsvc	r7, r5, #1694498816	@ 0x65000000
                        pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     760:	6c75006e 	ldclvs	0, cr0, [r5], #-440	@ 0xfffffe48
     764:	75746552 	ldrbvc	r6, [r4, #-1362]!	@ 0xfffffaae
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
     768:	75006e72 	strvc	r6, [r0, #-3698]	@ 0xfffff18e
     76c:	7361546c 	cmnvc	r1, #108, 8	@ 0x6c000000
     770:	6e65476b 	cdpvs	7, 6, cr4, cr5, cr11, {3}
     774:	63697265 	cmnvs	r9, #1342177286	@ 0x50000006
     778:	69746f4e 	ldmdbvs	r4!, {r1, r2, r3, r6, r8, r9, sl, fp, sp, lr}^
     77c:	61567966 	cmpvs	r6, r6, ror #18
     780:	4365756c 	cmnmi	r5, #108, 10	@ 0x1b000000
     784:	7261656c 	rsbvc	r6, r1, #108, 10	@ 0x1b000000
     788:	50637500 	rsbpl	r7, r3, r0, lsl #10
     78c:	4374726f 	cmnmi	r4, #-268435450	@ 0xf0000006
     790:	746e756f 	strbtvc	r7, [lr], #-1391	@ 0xfffffa91
     794:	6461654c 	strbtvs	r6, [r1], #-1356	@ 0xfffffab4
     798:	5a676e69 	bpl	19dc144 <_etext+0x19d9c74>
     79c:	736f7265 	cmnvc	pc, #1342177286	@ 0x50000006
     7a0:	4c6c7500 	cfstr64mi	mvdx7, [ip], #-0
                        listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
     7a4:	74676e65 	strbtvc	r6, [r7], #-3685	@ 0xfffff19b
     7a8:	426e4968 	rsbmi	r4, lr, #104, 18	@ 0x1a0000
     7ac:	73657479 	cmnvc	r5, #2030043136	@ 0x79000000
     7b0:	76727000 	ldrbtvc	r7, [r2], -r0
     7b4:	65736552 	ldrbvs	r6, [r3, #-1362]!	@ 0xfffffaae
     7b8:	78654e74 	stmdavc	r5!, {r2, r4, r5, r6, r9, sl, fp, lr}^
     7bc:	73615474 	cmnvc	r1, #116, 8	@ 0x74000000
     7c0:	626e556b 	rsbvs	r5, lr, #448790528	@ 0x1ac00000
     7c4:	6b636f6c 	blvs	18dc57c <_etext+0x18da0ac>
     7c8:	656d6954 	strbvs	r6, [sp, #-2388]!	@ 0xfffff6ac
     7cc:	69547800 	ldmdbvs	r4, {fp, ip, sp, lr}^
     7d0:	6e4f656d 	cdpvs	5, 4, cr6, cr15, cr13, {3}
     7d4:	65746e45 	ldrbvs	r6, [r4, #-3653]!	@ 0xfffff1bb
     7d8:	676e6972 			@ <UNDEFINED> instruction: 0x676e6972
     7dc:	4e787000 	cdpmi	0, 7, cr7, cr8, cr0, {0}
     7e0:	00747865 	rsbseq	r7, r4, r5, ror #16
                        prvAddTaskToReadyList( pxTCB );
     7e4:	506c7570 	rsbpl	r7, ip, r0, ror r5
     7e8:	69766572 	ldmdbvs	r6!, {r1, r4, r5, r6, r8, sl, sp, lr}^
     7ec:	4e73756f 	cdpmi	5, 7, cr7, cr3, cr15, {3}
     7f0:	6669746f 	strbtvs	r7, [r9], -pc, ror #8
     7f4:	74616369 	strbtvc	r6, [r1], #-873	@ 0xfffffc97
     7f8:	566e6f69 	strbtpl	r6, [lr], -r9, ror #30
     7fc:	65756c61 	ldrbvs	r6, [r5, #-3169]!	@ 0xfffff39f
     800:	54787000 	ldrbtpl	r7, [r8], #-0
     804:	4f656d69 	svcmi	0x00656d69
     808:	2e007475 	mcrcs	4, 0, r7, cr0, cr5, {3}
     80c:	72462f2e 	subvc	r2, r6, #46, 30	@ 0xb8
     810:	54526565 	ldrbpl	r6, [r2], #-1381	@ 0xfffffa9b
     814:	4b2d534f 	blmi	b55558 <_etext+0xb53088>
     818:	656e7265 	strbvs	r7, [lr, #-613]!	@ 0xfffffd9b
     81c:	61742f6c 	cmnvs	r4, ip, ror #30
     820:	2e736b73 	vmovcs.s8	r6, d3[7]
     824:	54780063 	ldrbtpl	r0, [r8], #-99	@ 0xffffff9d
     828:	476b7361 	strbmi	r7, [fp, -r1, ror #6]!
     82c:	69547465 	ldmdbvs	r4, {r0, r2, r5, r6, sl, ip, sp, lr}^
     830:	6f436b63 	svcvs	0x00436b63
     834:	00746e75 	rsbseq	r6, r4, r5, ror lr
     838:	656d6954 	strbvs	r6, [sp, #-2388]!	@ 0xfffff6ac
     83c:	5f74754f 	svcpl	0x0074754f
     840:	54760074 	ldrbtpl	r0, [r6], #-116	@ 0xffffff8c
     844:	496b7361 	stmdbmi	fp!, {r0, r5, r6, r8, r9, ip, sp, lr}^
     848:	7265746e 	rsbvc	r7, r5, #1845493760	@ 0x6e000000
     84c:	536c616e 	cmnpl	ip, #-2147483621	@ 0x8000001b
     850:	69547465 	ldmdbvs	r4, {r0, r2, r5, r6, sl, ip, sp, lr}^
     854:	754f656d 	strbvc	r6, [pc, #-1389]	@ 2ef <memset+0xb>
     858:	61745374 	cmnvs	r4, r4, ror r3
     85c:	75006574 	strvc	r6, [r0, #-1396]	@ 0xfffffa8c
     860:	73615478 	cmnvc	r1, #120, 8	@ 0x78000000
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     864:	6d754e6b 	ldclvs	14, cr4, [r5, #-428]!	@ 0xfffffe54
     868:	00726562 	rsbseq	r6, r2, r2, ror #10
     86c:	74634165 	strbtvc	r4, [r3], #-357	@ 0xfffffe9b
     870:	006e6f69 	rsbeq	r6, lr, r9, ror #30
                                xYieldPendings[ xCoreID ] = pdTRUE;
     874:	654e6c75 	strbvs	r6, [lr, #-3189]	@ 0xfffff38b
     878:	73614d77 	cmnvc	r1, #7616	@ 0x1dc0
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     87c:	6c61566b 	stclvs	6, cr5, [r1], #-428	@ 0xfffffe54
     880:	75006575 	strvc	r6, [r0, #-1397]	@ 0xfffffa8b
     884:	73615478 	cmnvc	r1, #120, 8	@ 0x78000000
                    if( pxTCB != NULL )
     888:	7365526b 	cmnvc	r5, #-1342177274	@ 0xb0000006
                        prvResetNextTaskUnblockTime();
     88c:	76457465 	strbvc	r7, [r5], -r5, ror #8
                        TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
     890:	49746e65 	ldmdbmi	r4!, {r0, r2, r5, r6, r9, sl, fp, sp, lr}^
     894:	566d6574 			@ <UNDEFINED> instruction: 0x566d6574
                        if( xPendedCounts > ( TickType_t ) 0U )
     898:	65756c61 	ldrbvs	r6, [r5, #-3169]!	@ 0xfffff39f
                                if( xTaskIncrementTick() != pdFALSE )
     89c:	73694c00 	cmnvc	r9, #0, 24
     8a0:	00745f74 	rsbseq	r5, r4, r4, ror pc
     8a4:	73615478 	cmnvc	r1, #120, 8	@ 0x78000000
                                    xYieldPendings[ xCoreID ] = pdTRUE;
     8a8:	516f546b 	cmnpl	pc, fp, ror #8
     8ac:	79726575 	ldmdbvc	r2!, {r0, r2, r4, r5, r6, r8, sl, sp, lr}^
                                --xPendedCounts;
     8b0:	63695400 	cmnvs	r9, #0, 8
     8b4:	7079546b 	rsbsvc	r5, r9, fp, ror #8
                            } while( xPendedCounts > ( TickType_t ) 0U );
     8b8:	00745f65 	rsbseq	r5, r4, r5, ror #30
                            xPendedTicks = 0;
     8bc:	73615478 	cmnvc	r1, #120, 8	@ 0x78000000
     8c0:	4e6f546b 	cdpmi	4, 6, cr5, cr15, cr11, {3}
                    if( xYieldPendings[ xCoreID ] != pdFALSE )
     8c4:	6669746f 	strbtvs	r7, [r9], -pc, ror #8
     8c8:	54780079 	ldrbtpl	r0, [r8], #-121	@ 0xffffff87
     8cc:	006b7361 	rsbeq	r7, fp, r1, ror #6
                            xAlreadyYielded = pdTRUE;
     8d0:	74655365 	strbtvc	r5, [r5], #-869	@ 0xfffffc9b
                            taskYIELD_TASK_CORE_IF_USING_PREEMPTION( pxCurrentTCB );
     8d4:	73746942 	cmnvc	r4, #1081344	@ 0x108000
     8d8:	454d7800 	strbmi	r7, [sp, #-2048]	@ 0xfffff800
     8dc:	59524f4d 	ldmdbpl	r2, {r0, r2, r3, r6, r8, r9, sl, fp, lr}^
     8e0:	4745525f 	smlsldmi	r5, r5, pc, r2	@ <UNPREDICTABLE>
     8e4:	004e4f49 	subeq	r4, lr, r9, asr #30
        taskEXIT_CRITICAL();
     8e8:	73615476 	cmnvc	r1, #1979711488	@ 0x76000000
}
     8ec:	6977536b 	ldmdbvs	r7!, {r0, r1, r3, r5, r6, r8, r9, ip, lr}^
     8f0:	43686374 	cmnmi	r8, #116, 6	@ 0xd0000001
     8f4:	65746e6f 	ldrbvs	r6, [r4, #-3695]!	@ 0xfffff191
     8f8:	78007478 	stmdavc	r0, {r3, r4, r5, r6, sl, ip, sp, lr}
     8fc:	4f6d754e 	svcmi	0x006d754e
     900:	65764f66 	ldrbvs	r4, [r6, #-3942]!	@ 0xfffff09a
     904:	6f6c6672 	svcvs	0x006c6672
     908:	70007377 	andvc	r7, r0, r7, ror r3
     90c:	6e6f4376 	mcrvs	3, 3, r4, cr15, cr6, {3}
     910:	6e696174 	mcrvs	1, 3, r6, cr9, cr4, {3}
     914:	70007265 	andvc	r7, r0, r5, ror #4
{
     918:	72754378 	rsbsvc	r4, r5, #120, 6	@ 0xe0000001
     91c:	746e6572 	strbtvc	r6, [lr], #-1394	@ 0xfffffa8e
        xTicks = xTickCount;
     920:	00424354 	subeq	r4, r2, r4, asr r3
    return xTicks;
     924:	6f685378 	svcvs	0x00685378
}
     928:	42646c75 	rsbmi	r6, r4, #29952	@ 0x7500
     92c:	6b636f6c 	blvs	18dc6e4 <_etext+0x18da214>
     930:	64496300 	strbvs	r6, [r9], #-768	@ 0xfffffd00
{
     934:	614e656c 	cmpvs	lr, ip, ror #10
     938:	7600656d 	strvc	r6, [r0], -sp, ror #10
    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
     93c:	7473694c 	ldrbtvc	r6, [r3], #-2380	@ 0xfffff6b4
        xReturn = xTickCount;
     940:	74696e49 	strbtvc	r6, [r9], #-3657	@ 0xfffff1b7
    return xReturn;
     944:	696c6169 	stmdbvs	ip!, {r0, r3, r5, r6, r8, sp, lr}^
}
     948:	74496573 	strbvc	r6, [r9], #-1395	@ 0xfffffa8d
     94c:	70006d65 	andvc	r6, r0, r5, ror #26
     950:	6e497672 	mcrvs	6, 2, r7, cr9, cr2, {3}
{
     954:	61697469 	cmnvs	r9, r9, ror #8
    return uxCurrentNumberOfTasks;
     958:	6573696c 	ldrbvs	r6, [r3, #-2412]!	@ 0xfffff694
}
     95c:	5477654e 	ldrbtpl	r6, [r7], #-1358	@ 0xfffffab2
     960:	006b7361 	rsbeq	r7, fp, r1, ror #6
     964:	65744978 	ldrbvs	r4, [r4, #-2424]!	@ 0xfffff688
{
     968:	6c61566d 	stclvs	6, cr5, [r1], #-436	@ 0xfffffe4c
     96c:	78006575 	stmdavc	r0, {r0, r2, r4, r5, r6, r8, sl, sp, lr}
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     970:	6b736154 	blvs	1cd8ec8 <_etext+0x1cd69f8>
     974:	75736552 	ldrbvc	r6, [r3, #-1362]!	@ 0xfffffaae
     978:	6c41656d 	cfstr64vs	mvdx6, [r1], {109}	@ 0x6d
     97c:	7870006c 	ldmdavc	r0!, {r2, r3, r5, r6}^
    return &( pxTCB->pcTaskName[ 0 ] );
     980:	616c6544 	cmnvs	ip, r4, asr #10
}
     984:	54646579 	strbtpl	r6, [r4], #-1401	@ 0xfffffa87
     988:	4c6b7361 	stclmi	3, cr7, [fp], #-388	@ 0xfffffe7c
     98c:	00747369 	rsbseq	r7, r4, r9, ror #6
     990:	69775378 	ldmdbvs	r7!, {r3, r4, r5, r6, r8, r9, ip, lr}^
{
     994:	52686374 	rsbpl	r6, r8, #116, 6	@ 0xd0000001
     998:	69757165 	ldmdbvs	r5!, {r0, r2, r5, r6, r8, ip, sp, lr}^
    vTaskSuspendAll();
     99c:	00646572 	rsbeq	r6, r4, r2, ror r5
    taskENTER_CRITICAL();
     9a0:	74537870 	ldrbvc	r7, [r3], #-2160	@ 0xfffff790
        xPendedTicks += xTicksToCatchUp;
     9a4:	006b6361 	rsbeq	r6, fp, r1, ror #6
     9a8:	61566c75 	cmpvs	r6, r5, ror ip
     9ac:	0065756c 	rsbeq	r7, r5, ip, ror #10
    taskEXIT_CRITICAL();
     9b0:	73615478 	cmnvc	r1, #120, 8	@ 0x78000000
    xYieldOccurred = xTaskResumeAll();
     9b4:	6568436b 	strbvs	r4, [r8, #-875]!	@ 0xfffffc95
     9b8:	6f466b63 	svcvs	0x00466b63
}
     9bc:	6d695472 	cfstrdvs	mvd5, [r9, #-456]!	@ 0xfffffe38
     9c0:	74754f65 	ldrbtvc	r4, [r5], #-3941	@ 0xfffff09b
     9c4:	6f507600 	svcvs	0x00507600
{
     9c8:	72467472 	subvc	r7, r6, #1912602624	@ 0x72000000
     9cc:	70006565 	andvc	r6, r0, r5, ror #10
    BaseType_t xSwitchRequired = pdFALSE;
     9d0:	6c644978 			@ <UNDEFINED> instruction: 0x6c644978
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
     9d4:	73615465 	cmnvc	r1, #1694498816	@ 0x65000000
     9d8:	6e75466b 	cdpvs	6, 7, cr4, cr5, cr11, {3}
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     9dc:	6f697463 	svcvs	0x00697463
     9e0:	6375006e 	cmnvs	r5, #110	@ 0x6e
        xTickCount = xConstTickCount;
     9e4:	75746552 	ldrbvc	r6, [r4, #-1362]!	@ 0xfffffaae
     9e8:	70006e72 	andvc	r6, r0, r2, ror lr
        if( xConstTickCount == ( TickType_t ) 0U )
     9ec:	6f4e6c75 	svcvs	0x004e6c75
            taskSWITCH_DELAYED_LISTS();
     9f0:	69666974 	stmdbvs	r6!, {r2, r4, r5, r6, r8, fp, sp, lr}^
     9f4:	69746163 	ldmdbvs	r4!, {r0, r1, r5, r6, r8, sp, lr}^
     9f8:	61566e6f 	cmpvs	r6, pc, ror #28
     9fc:	0065756c 	rsbeq	r7, r5, ip, ror #10
     a00:	73615476 	cmnvc	r1, #1979711488	@ 0x76000000
     a04:	73694d6b 	cmnvc	r9, #6848	@ 0x1ac0
     a08:	59646573 	stmdbpl	r4!, {r0, r1, r4, r5, r6, r8, sl, sp, lr}^
     a0c:	646c6569 	strbtvs	r6, [ip], #-1385	@ 0xfffffa97
     a10:	6f507600 	svcvs	0x00507600
        if( xConstTickCount >= xNextTaskUnblockTime )
     a14:	61527472 	cmpvs	r2, r2, ror r4
     a18:	42657369 	rsbmi	r7, r5, #-1543503871	@ 0xa4000001
     a1c:	50455341 	subpl	r5, r5, r1, asr #6
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     a20:	70004952 	andvc	r4, r0, r2, asr r9
     a24:	73615463 	cmnvc	r1, #1660944384	@ 0x63000000
                    xNextTaskUnblockTime = portMAX_DELAY;
     a28:	7465476b 	strbtvc	r4, [r5], #-1899	@ 0xfffff895
     a2c:	656d614e 	strbvs	r6, [sp, #-334]!	@ 0xfffffeb2
                    break;
     a30:	69547800 	ldmdbvs	r4, {fp, ip, sp, lr}^
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     a34:	00736b63 	rsbseq	r6, r3, r3, ror #22
     a38:	73615476 	cmnvc	r1, #1979711488	@ 0x76000000
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     a3c:	6174536b 	cmnvs	r4, fp, ror #6
     a40:	63537472 	cmpvs	r3, #1912602624	@ 0x72000000
                    if( xConstTickCount < xItemValue )
     a44:	75646568 	strbvc	r6, [r4, #-1384]!	@ 0xfffffa98
     a48:	0072656c 	rsbseq	r6, r2, ip, ror #10
                        xNextTaskUnblockTime = xItemValue;
     a4c:	6e614378 	mcrvs	3, 3, r4, cr1, cr8, {3}
                        break;
     a50:	636f6c42 	cmnvs	pc, #16896	@ 0x4200
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
     a54:	646e496b 	strbtvs	r4, [lr], #-2411	@ 0xfffff695
     a58:	6e696665 	cdpvs	6, 6, cr6, cr9, cr5, {3}
     a5c:	6c657469 	cfstrdvs	mvd7, [r5], #-420	@ 0xfffffe5c
     a60:	76700079 			@ <UNDEFINED> instruction: 0x76700079
     a64:	65736142 	ldrbvs	r6, [r3, #-322]!	@ 0xfffffebe
     a68:	72646441 	rsbvc	r6, r4, #1090519040	@ 0x41000000
     a6c:	00737365 	rsbseq	r7, r3, r5, ror #6
     a70:	73615476 	cmnvc	r1, #1979711488	@ 0x76000000
     a74:	6e65476b 	cdpvs	7, 6, cr4, cr5, cr11, {3}
     a78:	63697265 	cmnvs	r9, #1342177286	@ 0x50000006
     a7c:	69746f4e 	ldmdbvs	r4!, {r1, r2, r3, r6, r8, r9, sl, fp, sp, lr}^
     a80:	69477966 	stmdbvs	r7, {r1, r2, r5, r6, r8, fp, ip, sp, lr}^
     a84:	72466576 	subvc	r6, r6, #494927872	@ 0x1d800000
     a88:	53496d6f 	movtpl	r6, #40303	@ 0x9d6f
     a8c:	54760052 	ldrbtpl	r0, [r6], #-82	@ 0xffffffae
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     a90:	506b7361 	rsbpl	r7, fp, r1, ror #6
     a94:	6563616c 	strbvs	r6, [r3, #-364]!	@ 0xfffffe94
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
     a98:	6e556e4f 	cdpvs	14, 5, cr6, cr5, cr15, {2}
     a9c:	6564726f 	strbvs	r7, [r4, #-623]!	@ 0xfffffd91
     aa0:	45646572 	strbmi	r6, [r4, #-1394]!	@ 0xfffffa8e
     aa4:	746e6576 	strbtvc	r6, [lr], #-1398	@ 0xfffffa8a
     aa8:	7473694c 	ldrbtvc	r6, [r3], #-2380	@ 0xfffff6b4
     aac:	694c7600 	stmdbvs	ip, {r9, sl, ip, sp, lr}^
     ab0:	6e497473 	mcrvs	4, 2, r7, cr9, cr3, {3}
     ab4:	61697469 	cmnvs	r9, r9, ror #8
     ab8:	6573696c 	ldrbvs	r6, [r3, #-2412]!	@ 0xfffff694
     abc:	54787000 	ldrbtpl	r7, [r8], #-0
     ac0:	736b6369 	cmnvc	fp, #-1543503871	@ 0xa4000001
     ac4:	61576f54 	cmpvs	r7, r4, asr pc
     ac8:	76007469 	strvc	r7, [r0], -r9, ror #8
     acc:	7473694c 	ldrbtvc	r6, [r3], #-2380	@ 0xfffff6b4
     ad0:	65736e49 	ldrbvs	r6, [r3, #-3657]!	@ 0xfffff1b7
     ad4:	75007472 	strvc	r7, [r0, #-1138]	@ 0xfffffb8e
                    prvAddTaskToReadyList( pxTCB );
     ad8:	706f5478 	rsbvc	r5, pc, r8, ror r4	@ <UNPREDICTABLE>
     adc:	6f697250 	svcvs	0x00697250
     ae0:	79746972 	ldmdbvc	r4!, {r1, r4, r5, r6, r8, fp, sp, lr}^
     ae4:	42435400 	submi	r5, r3, #0, 8
     ae8:	7000745f 	andvc	r7, r0, pc, asr r4
     aec:	6e774f76 	mrcvs	15, 3, r4, cr7, cr6, {3}
     af0:	78007265 	stmdavc	r0, {r0, r2, r5, r6, r9, ip, sp, lr}
     af4:	65726c41 	ldrbvs	r6, [r2, #-3137]!	@ 0xfffff3bf
     af8:	59796461 	ldmdbpl	r9!, {r0, r5, r6, sl, sp, lr}^
     afc:	646c6569 	strbtvs	r6, [ip], #-1385	@ 0xfffffa97
     b00:	78006465 	stmdavc	r0, {r0, r2, r5, r6, sl, sp, lr}
     b04:	6b736154 	blvs	1cd905c <_etext+0x1cd6b8c>
     b08:	43746547 	cmnmi	r4, #297795584	@ 0x11c00000
     b0c:	65727275 	ldrbvs	r7, [r2, #-629]!	@ 0xfffffd8b
     b10:	6154746e 	cmpvs	r4, lr, ror #8
     b14:	61486b73 	hvcvs	34483	@ 0x86b3
     b18:	656c646e 	strbvs	r6, [ip, #-1134]!	@ 0xfffffb92
     b1c:	45787000 	ldrbmi	r7, [r8, #-0]!
     b20:	746e6576 	strbtvc	r6, [lr], #-1398	@ 0xfffffa8a
     b24:	7473694c 	ldrbtvc	r6, [r3], #-2380	@ 0xfffff6b4
     b28:	6d657449 	cfstrdvs	mvd7, [r5, #-292]!	@ 0xfffffedc
     b2c:	65507800 	ldrbvs	r7, [r0, #-2048]	@ 0xfffff800
     b30:	6465646e 	strbtvs	r6, [r5], #-1134	@ 0xfffffb92
     b34:	6b636954 	blvs	18db08c <_etext+0x18d8bbc>
     b38:	54780073 	ldrbtpl	r0, [r8], #-115	@ 0xffffff8d
     b3c:	736b6369 	cmnvc	fp, #-1543503871	@ 0xa4000001
     b40:	61436f54 	cmpvs	r3, r4, asr pc
     b44:	55686374 	strbpl	r6, [r8, #-884]!	@ 0xfffffc8c
     b48:	52780070 	rsbspl	r0, r8, #112	@ 0x70
     b4c:	6f696765 	svcvs	0x00696765
     b50:	7000736e 	andvc	r7, r0, lr, ror #6
     b54:	64417672 	strbvs	r7, [r1], #-1650	@ 0xfffff98e
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     b58:	72754364 	rsbsvc	r4, r5, #100, 6	@ 0x90000001
     b5c:	746e6572 	strbtvc	r6, [lr], #-1394	@ 0xfffffa8e
     b60:	6b736154 	blvs	1cd90b8 <_etext+0x1cd6be8>
     b64:	65446f54 	strbvs	r6, [r4, #-3924]	@ 0xfffff0ac
                                xSwitchRequired = pdTRUE;
     b68:	6579616c 	ldrbvs	r6, [r9, #-364]!	@ 0xfffffe94
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     b6c:	73694c64 	cmnvc	r9, #100, 24	@ 0x6400
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > 1U )
     b70:	54780074 	ldrbtpl	r0, [r8], #-116	@ 0xffffff8c
     b74:	476b7361 	strbmi	r7, [fp, -r1, ror #6]!
     b78:	75437465 	strbvc	r7, [r3, #-1125]	@ 0xfffffb9b
     b7c:	6e657272 	mcrvs	2, 3, r7, cr5, cr2, {3}
     b80:	73615474 	cmnvc	r1, #116, 8	@ 0x74000000
     b84:	6e61486b 	cdpvs	8, 6, cr4, cr1, cr11, {3}
                    xSwitchRequired = pdTRUE;
     b88:	46656c64 	strbtmi	r6, [r5], -r4, ror #24
                if( xYieldPendings[ 0 ] != pdFALSE )
     b8c:	6f43726f 	svcvs	0x0043726f
     b90:	75006572 	strvc	r6, [r0, #-1394]	@ 0xfffffa8e
                    xSwitchRequired = pdTRUE;
     b94:	72754378 	rsbsvc	r4, r5, #120, 6	@ 0xe0000001
        xPendedTicks += 1U;
     b98:	746e6572 	strbtvc	r6, [lr], #-1394	@ 0xfffffa8e
     b9c:	626d754e 	rsbvs	r7, sp, #327155712	@ 0x13800000
     ba0:	664f7265 	strbvs	r7, [pc], -r5, ror #4
}
     ba4:	6b736154 	blvs	1cd90fc <_etext+0x1cd6c2c>
     ba8:	54780073 	ldrbtpl	r0, [r8], #-115	@ 0xffffff8d
     bac:	54656d69 	strbtpl	r6, [r5], #-3433	@ 0xfffff297
     bb0:	6b61576f 	blvs	1856974 <_etext+0x18544a4>
     bb4:	53780065 	cmnpl	r8, #101	@ 0x65
     bb8:	65746174 	ldrbvs	r6, [r4, #-372]!	@ 0xfffffe8c
     bbc:	7473694c 	ldrbtvc	r6, [r3], #-2380	@ 0xfffff6b4
     bc0:	6d657449 	cfstrdvs	mvd7, [r5, #-292]!	@ 0xfffffedc
     bc4:	54787000 	ldrbtpl	r7, [r8], #-0
     bc8:	78004243 	stmdavc	r0, {r0, r1, r6, r9, lr}
     bcc:	6b736154 	blvs	1cd9124 <_etext+0x1cd6c54>
     bd0:	656e6547 	strbvs	r6, [lr, #-1351]!	@ 0xfffffab9
     bd4:	4e636972 			@ <UNDEFINED> instruction: 0x4e636972
    {
     bd8:	6669746f 	strbtvs	r7, [r9], -pc, ror #8
     bdc:	61745379 	cmnvs	r4, r9, ror r3
        if( uxSchedulerSuspended != ( UBaseType_t ) 0U )
     be0:	6c436574 	cfstr64vs	mvdx6, [r3], {116}	@ 0x74
     be4:	00726165 	rsbseq	r6, r2, r5, ror #2
            xYieldPendings[ 0 ] = pdTRUE;
     be8:	63537875 	cmpvs	r3, #7667712	@ 0x750000
    }
     bec:	75646568 	strbvc	r6, [r4, #-1384]!	@ 0xfffffa98
            xYieldPendings[ 0 ] = pdFALSE;
     bf0:	5372656c 	cmnpl	r2, #108, 10	@ 0x1b000000
            taskSELECT_HIGHEST_PRIORITY_TASK();
     bf4:	65707375 	ldrbvs	r7, [r0, #-885]!	@ 0xfffffc8b
     bf8:	6465646e 	strbtvs	r6, [r5], #-1134	@ 0xfffffb92
        __asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
     bfc:	54787000 	ldrbtpl	r7, [r8], #-0
     c00:	664f706f 	strbvs	r7, [pc], -pc, rrx
     c04:	63617453 	cmnvs	r1, #1392508928	@ 0x53000000
     c08:	7670006b 	ldrbtvc	r0, [r0], -fp, rrx
     c0c:	74726f50 	ldrbtvc	r6, [r2], #-3920	@ 0xfffff0b0
     c10:	6c6c614d 	stfvse	f6, [ip], #-308	@ 0xfffffecc
     c14:	7600636f 	strvc	r6, [r0], -pc, ror #6
     c18:	74726f50 	ldrbtvc	r6, [r2], #-3920	@ 0xfffff0b0
     c1c:	53646e45 	cmnpl	r4, #1104	@ 0x450
     c20:	64656863 	strbtvs	r6, [r5], #-2147	@ 0xfffff79d
     c24:	72656c75 	rsbvc	r6, r5, #29952	@ 0x7500
     c28:	4c787000 	ldclmi	0, cr7, [r8], #-0
     c2c:	00747369 	rsbseq	r7, r4, r9, ror #6
     c30:	6e497875 	mcrvs	8, 2, r7, cr9, cr5, {3}
     c34:	54786564 	ldrbtpl	r6, [r8], #-1380	@ 0xfffffa9c
     c38:	746f4e6f 	strbtvc	r4, [pc], #-3695	@ c40 <vTaskSwitchContext+0x68>
     c3c:	00796669 	rsbseq	r6, r9, r9, ror #12
     c40:	72437870 	subvc	r7, r3, #112, 16	@ 0x700000
            portTASK_SWITCH_HOOK( pxCurrentTCB );
     c44:	65746165 	ldrbvs	r6, [r4, #-357]!	@ 0xfffffe9b
    }
     c48:	73615464 	cmnvc	r1, #100, 8	@ 0x64000000
     c4c:	7270006b 	rsbsvc	r0, r0, #107	@ 0x6b
     c50:	65684376 	strbvs	r4, [r8, #-886]!	@ 0xfffffc8a
     c54:	61546b63 	cmpvs	r4, r3, ror #22
     c58:	57736b73 			@ <UNDEFINED> instruction: 0x57736b73
     c5c:	69746961 	ldmdbvs	r4!, {r0, r5, r6, r8, fp, sp, lr}^
     c60:	6554676e 	ldrbvs	r6, [r4, #-1902]	@ 0xfffff892
{
     c64:	6e696d72 	mcrvs	13, 3, r6, cr9, cr2, {3}
     c68:	6f697461 	svcvs	0x00697461
     c6c:	7870006e 	ldmdavc	r0!, {r1, r2, r3, r5, r6}^
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     c70:	7265764f 	rsbvc	r7, r5, #82837504	@ 0x4f00000
     c74:	776f6c66 	strbvc	r6, [pc, -r6, ror #24]!
     c78:	616c6544 	cmnvs	ip, r4, asr #10
    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     c7c:	4c646579 	cfstr64mi	mvdx6, [r4], #-484	@ 0xfffffe1c
     c80:	00747369 	rsbseq	r7, r4, r9, ror #6
}
     c84:	6e497875 	mcrvs	8, 2, r7, cr9, cr5, {3}
     c88:	54786564 	ldrbtpl	r6, [r8], #-1380	@ 0xfffffa9c
     c8c:	6961576f 	stmdbvs	r1!, {r0, r1, r2, r3, r5, r6, r8, r9, sl, ip, lr}^
{
     c90:	006e4f74 	rsbeq	r4, lr, r4, ror pc
     c94:	462f2e2e 	strtmi	r2, [pc], -lr, lsr #28
     c98:	52656572 	rsbpl	r6, r5, #478150656	@ 0x1c800000
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     c9c:	2d534f54 	ldclcs	15, cr4, [r3, #-336]	@ 0xfffffeb0
     ca0:	6e72654b 	cdpvs	5, 7, cr6, cr2, cr11, {2}
     ca4:	6c2f6c65 	stcvs	12, cr6, [pc], #-404	@ b18 <xTaskIncrementTick+0x150>
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     ca8:	2e747369 	cdpcs	3, 7, cr7, cr4, cr9, {3}
     cac:	78700063 	ldmdavc	r0!, {r0, r1, r5, r6}^
     cb0:	6d657449 	cfstrdvs	mvd7, [r5, #-292]!	@ 0xfffffedc
     cb4:	65526f54 	ldrbvs	r6, [r2, #-3924]	@ 0xfffff0ac
     cb8:	65766f6d 	ldrbvs	r6, [r6, #-3949]!	@ 0xfffff093
     cbc:	694c7600 	stmdbvs	ip, {r9, sl, ip, sp, lr}^
     cc0:	6e497473 	mcrvs	4, 2, r7, cr9, cr3, {3}
     cc4:	74726573 	ldrbtvc	r6, [r2], #-1395	@ 0xfffffa8d
     cc8:	00646e45 	rsbeq	r6, r4, r5, asr #28
     ccc:	6c615678 	stclvs	6, cr5, [r1], #-480	@ 0xfffffe20
     cd0:	664f6575 			@ <UNDEFINED> instruction: 0x664f6575
     cd4:	65736e49 	ldrbvs	r6, [r3, #-3657]!	@ 0xfffff1b7
     cd8:	6f697472 	svcvs	0x00697472
     cdc:	7870006e 	ldmdavc	r0!, {r1, r2, r3, r5, r6}^
     ce0:	6d657449 	cfstrdvs	mvd7, [r5, #-292]!	@ 0xfffffedc
     ce4:	49787000 	ldmdbmi	r8!, {ip, sp, lr}^
     ce8:	61726574 	cmnvs	r2, r4, ror r5
    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     cec:	00726f74 	rsbseq	r6, r2, r4, ror pc
     cf0:	654e7870 	strbvs	r7, [lr, #-2160]	@ 0xfffff790
}
     cf4:	73694c77 	cmnvc	r9, #30464	@ 0x7700
     cf8:	65744974 	ldrbvs	r4, [r4, #-2420]!	@ 0xfffff68c
     cfc:	7870006d 	ldmdavc	r0!, {r0, r2, r3, r5, r6}^
{
     d00:	76657250 			@ <UNDEFINED> instruction: 0x76657250
     d04:	73756f69 	cmnvc	r5, #420	@ 0x1a4
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     d08:	636f6c42 	cmnvs	pc, #16896	@ 0x4200
     d0c:	7870006b 	ldmdavc	r0!, {r0, r1, r3, r5, r6}^
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
     d10:	70616548 	rsbvc	r6, r1, r8, asr #10
     d14:	74617453 	strbtvc	r7, [r1], #-1107	@ 0xfffffbad
     d18:	4d780073 	ldclmi	0, cr0, [r8, #-460]!	@ 0xfffffe34
     d1c:	6d696e69 	stclvs	14, cr6, [r9, #-420]!	@ 0xfffffe5c
     d20:	76456d75 			@ <UNDEFINED> instruction: 0x76456d75
     d24:	72467265 	subvc	r7, r6, #1342177286	@ 0x50000006
     d28:	79426565 	stmdbvc	r2, {r0, r2, r5, r6, r8, sl, sp, lr}^
     d2c:	52736574 	rsbspl	r6, r3, #116, 10	@ 0x1d000000
     d30:	69616d65 	stmdbvs	r1!, {r0, r2, r5, r6, r8, sl, fp, sp, lr}^
     d34:	676e696e 	strbvs	r6, [lr, -lr, ror #18]!
     d38:	61654800 	cmnvs	r5, r0, lsl #16
     d3c:	61745370 	cmnvs	r4, r0, ror r3
     d40:	745f7374 	ldrbvc	r7, [pc], #-884	@ d48 <xTaskRemoveFromEventList+0x48>
     d44:	42787000 	rsbsmi	r7, r8, #0
     d48:	6b636f6c 	blvs	18dcb00 <_etext+0x18da630>
     d4c:	694d7800 	stmdbvs	sp, {fp, ip, sp, lr}^
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
     d50:	7a69536e 	bvc	1a55b10 <_etext+0x1a53640>
     d54:	4e780065 	cdpmi	0, 7, cr0, cr8, cr5, {3}
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
     d58:	65626d75 	strbvs	r6, [r2, #-3445]!	@ 0xfffff28b
     d5c:	46664f72 	uqsub16mi	r4, r6, r2
     d60:	42656572 	rsbmi	r6, r5, #478150656	@ 0x1c800000
     d64:	6b636f6c 	blvs	18dcb1c <_etext+0x18da64c>
     d68:	78700073 	ldmdavc	r0!, {r0, r1, r4, r5, r6}^
     d6c:	00646e45 	rsbeq	r6, r4, r5, asr #28
     d70:	49767270 	ldmdbmi	r6!, {r4, r5, r6, r9, ip, sp, lr}^
     d74:	7265736e 	rsbvc	r7, r5, #-1207959551	@ 0xb8000001
     d78:	6f6c4274 	svcvs	0x006c4274
     d7c:	6e496b63 	vmlsvs.f64	d22, d9, d19
     d80:	72466f74 	subvc	r6, r6, #116, 30	@ 0x1d0
     d84:	694c6565 	stmdbvs	ip, {r0, r2, r5, r6, r8, sl, sp, lr}^
     d88:	78007473 	stmdavc	r0, {r0, r1, r4, r5, r6, sl, ip, sp, lr}
     d8c:	74726f50 	ldrbtvc	r6, [r2], #-3920	@ 0xfffff0b0
     d90:	65736552 	ldrbvs	r6, [r3, #-1362]!	@ 0xfffffaae
        prvAddTaskToReadyList( pxUnblockedTCB );
     d94:	61654874 	smcvs	21636	@ 0x5484
     d98:	6e694d70 	mcrvs	13, 3, r4, cr9, cr0, {3}
     d9c:	6d756d69 	ldclvs	13, cr6, [r5, #-420]!	@ 0xfffffe5c
     da0:	72657645 	rsbvc	r7, r5, #72351744	@ 0x4500000
     da4:	65657246 	strbvs	r7, [r5, #-582]!	@ 0xfffffdba
     da8:	70616548 	rsbvc	r6, r1, r8, asr #10
     dac:	657a6953 	ldrbvs	r6, [sl, #-2387]!	@ 0xfffff6ad
     db0:	425f4100 	subsmi	r4, pc, #0, 2
     db4:	4b434f4c 	blmi	10d4aec <_etext+0x10d261c>
     db8:	4e494c5f 	mcrmi	12, 2, r4, cr9, cr15, {2}
     dbc:	7875004b 	ldmdavc	r5!, {r0, r1, r3, r6}^
     dc0:	72617453 	rsbvc	r7, r1, #1392508928	@ 0x53000000
     dc4:	64644174 	strbtvs	r4, [r4], #-372	@ 0xfffffe8c
     dc8:	73736572 	cmnvc	r3, #478150656	@ 0x1c800000
     dcc:	69537800 	ldmdbvs	r3, {fp, ip, sp, lr}^
     dd0:	664f657a 			@ <UNDEFINED> instruction: 0x664f657a
     dd4:	6c616d53 	stclvs	13, cr6, [r1], #-332	@ 0xfffffeb4
     dd8:	7473656c 	ldrbtvc	r6, [r3], #-1388	@ 0xfffffa94
     ddc:	65657246 	strbvs	r7, [r5, #-582]!	@ 0xfffffdba
     de0:	636f6c42 	cmnvs	pc, #16896	@ 0x4200
     de4:	426e496b 	rsbmi	r4, lr, #1753088	@ 0x1ac000
     de8:	73657479 	cmnvc	r5, #2030043136	@ 0x79000000
     dec:	6c417800 	mcrrvs	8, 0, r7, r1, cr0
     df0:	61636f6c 	cmnvs	r3, ip, ror #30
     df4:	42646574 	rsbmi	r6, r4, #116, 10	@ 0x1d000000
     df8:	6b636f6c 	blvs	18dcbb0 <_etext+0x18da6e0>
     dfc:	657a6953 	ldrbvs	r6, [sl, #-2387]!	@ 0xfffff6ad
     e00:	45787500 	ldrbmi	r7, [r8, #-1280]!	@ 0xfffffb00
     e04:	6441646e 	strbvs	r6, [r1], #-1134	@ 0xfffffb92
     e08:	73657264 	cmnvc	r5, #100, 4	@ 0x40000006
     e0c:	78700073 	ldmdavc	r0!, {r0, r1, r4, r5, r6}^
     e10:	4277654e 	rsbsmi	r6, r7, #327155712	@ 0x13800000
     e14:	6b636f6c 	blvs	18dcbcc <_etext+0x18da6fc>
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     e18:	6b6e694c 	blvs	1b9b350 <_etext+0x1b98e80>
     e1c:	6f507800 	svcvs	0x00507800
     e20:	65477472 	strbvs	r7, [r7, #-1138]	@ 0xfffffb8e
     e24:	65724674 	ldrbvs	r4, [r2, #-1652]!	@ 0xfffff98c
     e28:	61654865 	cmnvs	r5, r5, ror #16
     e2c:	7a695370 	bvc	1a55bf4 <_etext+0x1a53724>
     e30:	41780065 	cmnmi	r8, r5, rrx
     e34:	74696464 	strbtvc	r6, [r9], #-1124	@ 0xfffffb9c
     e38:	616e6f69 	cmnvs	lr, r9, ror #30
     e3c:	7165526c 	cmnvc	r5, ip, ror #4
     e40:	65726975 	ldrbvs	r6, [r2, #-2421]!	@ 0xfffff68b
     e44:	7a695364 	bvc	1a55bdc <_etext+0x1a5370c>
     e48:	76700065 	ldrbtvc	r0, [r0], -r5, rrx
     e4c:	75746552 	ldrbvc	r6, [r4, #-1362]!	@ 0xfffffaae
        if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     e50:	76006e72 			@ <UNDEFINED> instruction: 0x76006e72
     e54:	74726f50 	ldrbtvc	r6, [r2], #-3920	@ 0xfffff0b0
     e58:	70616548 	rsbvc	r6, r1, r8, asr #10
     e5c:	65736552 	ldrbvs	r6, [r3, #-1362]!	@ 0xfffffaae
            xReturn = pdTRUE;
     e60:	61745374 	cmnvs	r4, r4, ror r3
            xYieldPendings[ 0 ] = pdTRUE;
     e64:	78006574 	stmdavc	r0, {r2, r4, r5, r6, r8, sl, sp, lr}
     e68:	5378614d 	cmnpl	r8, #1073741843	@ 0x40000013
            xReturn = pdFALSE;
     e6c:	00657a69 	rsbeq	r7, r5, r9, ror #20
}
     e70:	726f5078 	rsbvc	r5, pc, #120	@ 0x78
     e74:	74654774 	strbtvc	r4, [r5], #-1908	@ 0xfffff88c
     e78:	696e694d 	stmdbvs	lr!, {r0, r2, r3, r6, r8, fp, sp, lr}^
     e7c:	456d756d 	strbmi	r7, [sp, #-1389]!	@ 0xfffffa93
     e80:	46726576 			@ <UNDEFINED> instruction: 0x46726576
     e84:	48656572 	stmdami	r5!, {r1, r4, r5, r6, r8, sl, sp, lr}^
     e88:	53706165 	cmnpl	r0, #1073741849	@ 0x40000019
     e8c:	00657a69 	rsbeq	r7, r5, r9, ror #20
     e90:	636f6c42 	cmnvs	pc, #16896	@ 0x4200
{
     e94:	6e694c6b 	cdpvs	12, 6, cr4, cr9, cr11, {3}
     e98:	00745f6b 	rsbseq	r5, r4, fp, ror #30
     e9c:	6d754e78 	ldclvs	14, cr4, [r5, #-480]!	@ 0xfffffe20
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     ea0:	4f726562 	svcmi	0x00726562
     ea4:	63755366 	cmnvs	r5, #-1744830463	@ 0x98000001
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem );
     ea8:	73736563 	cmnvc	r3, #415236096	@ 0x18c00000
     eac:	416c7566 	cmnmi	ip, r6, ror #10
    listREMOVE_ITEM( pxEventListItem );
     eb0:	636f6c6c 	cmnvs	pc, #108, 24	@ 0x6c00
     eb4:	6f697461 	svcvs	0x00697461
     eb8:	7800736e 	stmdavc	r0, {r1, r2, r3, r5, r6, r8, r9, ip, sp, lr}
     ebc:	69617641 	stmdbvs	r1!, {r0, r6, r9, sl, ip, sp, lr}^
     ec0:	6c62616c 	stfvse	f6, [r2], #-432	@ 0xfffffe50
     ec4:	61654865 	cmnvs	r5, r5, ror #16
     ec8:	61705370 	cmnvs	r0, r0, ror r3
     ecc:	6e496563 	cdpvs	5, 4, cr6, cr9, cr3, {3}
     ed0:	65747942 	ldrbvs	r7, [r4, #-2370]!	@ 0xfffff6be
     ed4:	48780073 	ldmdami	r8!, {r0, r1, r4, r5, r6}^
     ed8:	53706165 	cmnpl	r0, #1073741849	@ 0x40000019
     edc:	63757274 	cmnvs	r5, #116, 4	@ 0x40000007
     ee0:	7a695374 	bvc	1a55cb8 <_etext+0x1a537e8>
     ee4:	76700065 	ldrbtvc	r0, [r0], -r5, rrx
     ee8:	74726f50 	ldrbtvc	r6, [r2], #-3920	@ 0xfffff0b0
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
     eec:	6c6c6143 	stfvse	f6, [ip], #-268	@ 0xfffffef4
     ef0:	2e00636f 	cdpcs	3, 0, cr6, cr0, cr15, {3}
     ef4:	72462f2e 	subvc	r2, r6, #46, 30	@ 0xb8
     ef8:	54526565 	ldrbpl	r6, [r2], #-1381	@ 0xfffffa9b
     efc:	4b2d534f 	blmi	b55c40 <_etext+0xb53770>
     f00:	656e7265 	strbvs	r7, [lr, #-613]!	@ 0xfffffd9b
     f04:	6f702f6c 	svcvs	0x00702f6c
     f08:	62617472 	rsbvs	r7, r1, #1912602624	@ 0x72000000
     f0c:	4d2f656c 	cfstr32mi	mvfx6, [pc, #-432]!	@ d64 <xTaskRemoveFromEventList+0x64>
     f10:	614d6d65 	cmpvs	sp, r5, ror #26
     f14:	682f676e 	stmdavs	pc!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}	@ <UNPREDICTABLE>
     f18:	5f706165 	svcpl	0x00706165
     f1c:	00632e34 	rsbeq	r2, r3, r4, lsr lr
     f20:	65724678 	ldrbvs	r4, [r2, #-1656]!	@ 0xfffff988
     f24:	74794265 	ldrbtvc	r4, [r9], #-613	@ 0xfffffd9b
    prvAddTaskToReadyList( pxUnblockedTCB );
     f28:	65527365 	ldrbvs	r7, [r2, #-869]	@ 0xfffffc9b
     f2c:	6e69616d 	powvsez	f6, f1, #5.0
     f30:	00676e69 	rsbeq	r6, r7, r9, ror #28
     f34:	7a695378 	bvc	1a55d1c <_etext+0x1a5384c>
     f38:	4c664f65 	stclmi	15, cr4, [r6], #-404	@ 0xfffffe6c
     f3c:	65677261 	strbvs	r7, [r7, #-609]!	@ 0xfffffd9f
     f40:	72467473 	subvc	r7, r6, #1929379840	@ 0x73000000
     f44:	6c426565 	cfstr64vs	mvdx6, [r2], {101}	@ 0x65
     f48:	496b636f 	stmdbmi	fp!, {r0, r1, r2, r3, r5, r6, r8, r9, sp, lr}^
     f4c:	7479426e 	ldrbtvc	r4, [r9], #-622	@ 0xfffffd92
     f50:	70007365 	andvc	r7, r0, r5, ror #6
     f54:	65487672 	strbvs	r7, [r8, #-1650]	@ 0xfffff98e
     f58:	6e497061 	cdpvs	0, 4, cr7, cr9, cr1, {3}
     f5c:	70007469 	andvc	r7, r0, r9, ror #8
     f60:	6f6c4278 	svcvs	0x006c4278
     f64:	6f546b63 	svcvs	0x00546b63
     f68:	65736e49 	ldrbvs	r6, [r3, #-3657]!	@ 0xfffff1b7
     f6c:	70007472 	andvc	r7, r0, r2, ror r4
     f70:	78654e78 	stmdavc	r5!, {r3, r4, r5, r6, r9, sl, fp, lr}^
     f74:	65724674 	ldrbvs	r4, [r2, #-1652]!	@ 0xfffff98c
     f78:	6f6c4265 	svcvs	0x006c4265
     f7c:	78006b63 	stmdavc	r0, {r0, r1, r5, r6, r8, r9, fp, sp, lr}
     f80:	61746f54 	cmnvs	r4, r4, asr pc
     f84:	6165486c 	cmnvs	r5, ip, ror #16
     f88:	7a695370 	bvc	1a55d50 <_etext+0x1a53880>
     f8c:	4e780065 	cdpmi	0, 7, cr0, cr8, cr5, {3}
     f90:	65626d75 	strbvs	r6, [r2, #-3445]!	@ 0xfffff28b
     f94:	53664f72 	cmnpl	r6, #456	@ 0x1c8
     f98:	65636375 	strbvs	r6, [r3, #-885]!	@ 0xfffffc8b
     f9c:	75667373 	strbvc	r7, [r6, #-883]!	@ 0xfffffc8d
     fa0:	6572466c 	ldrbvs	r4, [r2, #-1644]!	@ 0xfffff994
     fa4:	78007365 	stmdavc	r0, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
     fa8:	636f6c42 	cmnvs	pc, #16896	@ 0x4200
        if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     fac:	7a69536b 	bvc	1a55d60 <_etext+0x1a53890>
     fb0:	53780065 	cmnpl	r8, #101	@ 0x65
     fb4:	74726174 	ldrbtvc	r6, [r2], #-372	@ 0xfffffe8c
            xYieldPendings[ 0 ] = pdTRUE;
     fb8:	6c427800 	mcrrvs	8, 0, r7, r2, cr0
     fbc:	736b636f 	cmnvc	fp, #-1140850687	@ 0xbc000001
}
     fc0:	754e7800 	strbvc	r7, [lr, #-2048]	@ 0xfffff800
     fc4:	7870006d 	ldmdavc	r0!, {r0, r2, r3, r5, r6}^
     fc8:	73726946 	cmnvc	r2, #1146880	@ 0x118000
     fcc:	65724674 	ldrbvs	r4, [r2, #-1652]!	@ 0xfffff98c
     fd0:	6f6c4265 	svcvs	0x006c4265
     fd4:	78006b63 	stmdavc	r0, {r0, r1, r5, r6, r8, r9, fp, sp, lr}
{
     fd8:	746e6157 	strbtvc	r6, [lr], #-343	@ 0xfffffea9
     fdc:	69536465 	ldmdbvs	r3, {r0, r2, r5, r6, sl, sp, lr}^
    taskENTER_CRITICAL();
     fe0:	7600657a 			@ <UNDEFINED> instruction: 0x7600657a
        pxTimeOut->xOverflowCount = xNumOfOverflows;
     fe4:	74726f50 	ldrbtvc	r6, [r2], #-3920	@ 0xfffff0b0
     fe8:	74696e49 	strbtvc	r6, [r9], #-3657	@ 0xfffff1b7
        pxTimeOut->xTimeOnEntering = xTickCount;
     fec:	696c6169 	stmdbvs	ip!, {r0, r3, r5, r6, r8, sp, lr}^
     ff0:	6c426573 	cfstr64vs	mvdx6, [r2], {115}	@ 0x73
    taskEXIT_CRITICAL();
     ff4:	736b636f 	cmnvc	fp, #-1140850687	@ 0xbc000001
}
     ff8:	6f507600 	svcvs	0x00507600
     ffc:	65477472 	strbvs	r7, [r7, #-1138]	@ 0xfffffb8e
    1000:	61654874 	smcvs	21636	@ 0x5484
    1004:	61745370 	cmnvs	r4, r0, ror r3
{
    1008:	70007374 	andvc	r7, r0, r4, ror r3
    100c:	6e694c78 	mcrvs	12, 3, r4, cr9, cr8, {3}
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    1010:	6375006b 	cmnvs	r5, #107	@ 0x6b
    1014:	70616548 	rsbvc	r6, r1, r8, asr #10
    pxTimeOut->xTimeOnEntering = xTickCount;
    1018:	43787000 	cmnmi	r8, #0
    101c:	0065646f 	rsbeq	r6, r5, pc, ror #8
}
    1020:	726f5078 	rsbvc	r5, pc, #120	@ 0x78
    1024:	6e655074 	mcrvs	0, 3, r5, cr5, cr4, {3}
    1028:	48565364 	ldmdami	r6, {r2, r5, r6, r8, r9, ip, lr}^
    102c:	6c646e61 	stclvs	14, cr6, [r4], #-388	@ 0xfffffe7c
    1030:	70007265 	andvc	r7, r0, r5, ror #4
{
    1034:	61547672 	cmpvs	r4, r2, ror r6
    1038:	78456b73 	stmdavc	r5, {r0, r1, r4, r5, r6, r8, r9, fp, sp, lr}^
    103c:	72457469 	subvc	r7, r5, #1761607680	@ 0x69000000
    taskENTER_CRITICAL();
    1040:	00726f72 	rsbseq	r6, r2, r2, ror pc
        const TickType_t xConstTickCount = xTickCount;
    1044:	75446c75 	strbvc	r6, [r4, #-3189]	@ 0xfffff38b
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    1048:	00796d6d 	rsbseq	r6, r9, sp, ror #26
    104c:	726f5078 	rsbvc	r5, pc, #120	@ 0x78
    1050:	73795374 	cmnvc	r9, #116, 6	@ 0xd0000001
        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) )
    1054:	6b636954 	blvs	18db5ac <_etext+0x18d90dc>
    1058:	646e6148 	strbtvs	r6, [lr], #-328	@ 0xfffffeb8
    105c:	0072656c 	rsbseq	r6, r2, ip, ror #10
    1060:	72437875 	subvc	r7, r3, #7667712	@ 0x750000
    1064:	63697469 	cmnvs	r9, #1761607680	@ 0x69000000
            xReturn = pdTRUE;
    1068:	654e6c61 	strbvs	r6, [lr, #-3169]	@ 0xfffff39f
            *pxTicksToWait = ( TickType_t ) 0;
    106c:	6e697473 	mcrvs	4, 3, r7, cr9, cr3, {3}
    1070:	50760067 	rsbspl	r0, r6, r7, rrx
        else if( xElapsedTime < *pxTicksToWait )
    1074:	5374726f 	cmnpl	r4, #-268435450	@ 0xf0000006
    1078:	70757465 	rsbsvc	r7, r5, r5, ror #8
    107c:	656d6954 	strbvs	r6, [sp, #-2388]!	@ 0xfffff6ac
            *pxTicksToWait -= xElapsedTime;
    1080:	746e4972 	strbtvc	r4, [lr], #-2418	@ 0xfffff68e
    1084:	75727265 	ldrbvc	r7, [r2, #-613]!	@ 0xfffffd9b
    1088:	2e007470 	mcrcs	4, 0, r7, cr0, cr0, {3}
            vTaskInternalSetTimeOutState( pxTimeOut );
    108c:	72462f2e 	subvc	r2, r6, #46, 30	@ 0xb8
            xReturn = pdFALSE;
    1090:	54526565 	ldrbpl	r6, [r2], #-1381	@ 0xfffffa9b
    1094:	4b2d534f 	blmi	b55dd8 <_etext+0xb53908>
            *pxTicksToWait = ( TickType_t ) 0;
    1098:	656e7265 	strbvs	r7, [lr, #-613]!	@ 0xfffffd9b
            xReturn = pdTRUE;
    109c:	6f702f6c 	svcvs	0x00702f6c
    taskEXIT_CRITICAL();
    10a0:	62617472 	rsbvs	r7, r1, #1912602624	@ 0x72000000
    return xReturn;
    10a4:	472f656c 	strmi	r6, [pc, -ip, ror #10]!
}
    10a8:	412f4343 			@ <UNDEFINED> instruction: 0x412f4343
    10ac:	435f4d52 	cmpmi	pc, #5248	@ 0x1480
    10b0:	702f334d 	eorvc	r3, pc, sp, asr #6
    10b4:	2e74726f 	cdpcs	2, 7, cr7, cr4, cr15, {3}
{
    10b8:	78700063 	ldmdavc	r0!, {r0, r1, r5, r6}^
    xYieldPendings[ portGET_CORE_ID() ] = pdTRUE;
    10bc:	74636556 	strbtvc	r6, [r3], #-1366	@ 0xfffffaaa
    10c0:	6154726f 	cmpvs	r4, pc, ror #4
}
    10c4:	00656c62 	rsbeq	r6, r5, r2, ror #24
    10c8:	74726f70 	ldrbtvc	r6, [r2], #-3952	@ 0xfffff090
    10cc:	5f525349 	svcpl	0x00525349
{
    10d0:	50760074 	rsbspl	r0, r6, r4, ror r0
    10d4:	5374726f 	cmnpl	r4, #-268435450	@ 0xf0000006
        prvCheckTasksWaitingTermination();
    10d8:	61484356 	cmpvs	r8, r6, asr r3
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) configNUMBER_OF_CORES )
    10dc:	656c646e 	strbvs	r6, [ip, #-1134]!	@ 0xfffffb92
    10e0:	72700072 	rsbsvc	r0, r0, #114	@ 0x72
                taskYIELD();
    10e4:	726f5076 	rsbvc	r5, pc, #118	@ 0x76
    10e8:	61745374 	cmnvs	r4, r4, ror r3
    10ec:	69467472 	stmdbvs	r6, {r1, r4, r5, r6, sl, ip, sp, lr}^
    10f0:	54747372 	ldrbtpl	r7, [r4], #-882	@ 0xfffffc8e
        prvCheckTasksWaitingTermination();
    10f4:	006b7361 	rsbeq	r7, fp, r1, ror #6

Disassembly of section .debug_frame:

00000000 <.debug_frame>:
   0:	0000000c 	andeq	r0, r0, ip
   4:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
   8:	7c020001 	stcvc	0, cr0, [r2], {1}
   c:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  10:	00000018 	andeq	r0, r0, r8, lsl r0
  14:	00000000 	andeq	r0, r0, r0
  18:	0000021c 	andeq	r0, r0, ip, lsl r2
  1c:	00000014 	andeq	r0, r0, r4, lsl r0
  20:	87040e41 	strhi	r0, [r4, -r1, asr #28]
  24:	180e4101 	stmdane	lr, {r0, r8, lr}
  28:	00070d41 	andeq	r0, r7, r1, asr #26
  2c:	00000018 	andeq	r0, r0, r8, lsl r0
  30:	00000000 	andeq	r0, r0, r0
  34:	00000230 	andeq	r0, r0, r0, lsr r2
  38:	00000014 	andeq	r0, r0, r4, lsl r0
  3c:	87040e41 	strhi	r0, [r4, -r1, asr #28]
  40:	180e4101 	stmdane	lr, {r0, r8, lr}
  44:	00070d41 	andeq	r0, r7, r1, asr #26
  48:	00000020 	andeq	r0, r0, r0, lsr #32
  4c:	00000000 	andeq	r0, r0, r0
  50:	00000244 	andeq	r0, r0, r4, asr #4
  54:	000000a0 	andeq	r0, r0, r0, lsr #1
  58:	87080e41 	strhi	r0, [r8, -r1, asr #28]
  5c:	41018e02 	tstmi	r1, r2, lsl #28
  60:	0c41200e 	mcrreq	0, 0, r2, r1, cr14
  64:	0e791807 	cdpeq	8, 7, cr1, cr9, cr7, {0}
  68:	0d0d4108 	stfeqs	f4, [sp, #-32]	@ 0xffffffe0
  6c:	0000000c 	andeq	r0, r0, ip
  70:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
  74:	7c020001 	stcvc	0, cr0, [r2], {1}
  78:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  7c:	00000024 	andeq	r0, r0, r4, lsr #32
  80:	0000006c 	andeq	r0, r0, ip, rrx
  84:	000002e4 	andeq	r0, r0, r4, ror #5
  88:	0000003e 	andeq	r0, r0, lr, lsr r0
  8c:	87040e41 	strhi	r0, [r4, -r1, asr #28]
  90:	280e4101 	stmdacs	lr, {r0, r8, lr}
  94:	59070d41 	stmdbpl	r7, {r0, r6, r8, sl, fp}
  98:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
  9c:	0ec7410d 	poleqs	f4, f7, #5.0
  a0:	00000000 	andeq	r0, r0, r0
  a4:	0000000c 	andeq	r0, r0, ip
  a8:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
  ac:	7c020001 	stcvc	0, cr0, [r2], {1}
  b0:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  b4:	00000020 	andeq	r0, r0, r0, lsr #32
  b8:	000000a4 	andeq	r0, r0, r4, lsr #1
  bc:	00000324 	andeq	r0, r0, r4, lsr #6
  c0:	00000078 	andeq	r0, r0, r8, ror r0
  c4:	87080e41 	strhi	r0, [r8, -r1, asr #28]
  c8:	41018e02 	tstmi	r1, r2, lsl #28
  cc:	0c41300e 	mcrreq	0, 0, r3, r1, cr14
  d0:	0e772007 	cdpeq	0, 7, cr2, cr7, cr7, {0}
  d4:	0d0d4108 	stfeqs	f4, [sp, #-32]	@ 0xffffffe0
  d8:	00000020 	andeq	r0, r0, r0, lsr #32
  dc:	000000a4 	andeq	r0, r0, r4, lsr #1
  e0:	0000039c 	muleq	r0, ip, r3
  e4:	00000046 	andeq	r0, r0, r6, asr #32
  e8:	87080e41 	strhi	r0, [r8, -r1, asr #28]
  ec:	41018e02 	tstmi	r1, r2, lsl #28
  f0:	0c41280e 	mcrreq	8, 0, r2, r1, cr14
  f4:	0e5e2007 	cdpeq	0, 5, cr2, cr14, cr7, {0}
  f8:	0d0d4108 	stfeqs	f4, [sp, #-32]	@ 0xffffffe0
  fc:	00000020 	andeq	r0, r0, r0, lsr #32
 100:	000000a4 	andeq	r0, r0, r4, lsr #1
 104:	000003e2 	andeq	r0, r0, r2, ror #7
 108:	000000ca 	andeq	r0, r0, sl, asr #1
 10c:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 110:	41018e02 	tstmi	r1, r2, lsl #28
 114:	0d41200e 	stcleq	0, cr2, [r1, #-56]	@ 0xffffffc8
 118:	0e600207 	cdpeq	2, 6, cr0, cr0, cr7, {0}
 11c:	0d0d4108 	stfeqs	f4, [sp, #-32]	@ 0xffffffe0
 120:	00000020 	andeq	r0, r0, r0, lsr #32
 124:	000000a4 	andeq	r0, r0, r4, lsr #1
 128:	000004ac 	andeq	r0, r0, ip, lsr #9
 12c:	00000128 	andeq	r0, r0, r8, lsr #2
 130:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 134:	41018e02 	tstmi	r1, r2, lsl #28
 138:	0d41180e 	stcleq	8, cr1, [r1, #-56]	@ 0xffffffc8
 13c:	0e810207 	cdpeq	2, 8, cr0, cr1, cr7, {0}
 140:	0d0d4108 	stfeqs	f4, [sp, #-32]	@ 0xffffffe0
 144:	00000024 	andeq	r0, r0, r4, lsr #32
 148:	000000a4 	andeq	r0, r0, r4, lsr #1
 14c:	000005d4 	ldrdeq	r0, [r0], -r4
 150:	000000ac 	andeq	r0, r0, ip, lsr #1
 154:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 158:	41018e02 	tstmi	r1, r2, lsl #28
 15c:	0c41300e 	mcrreq	0, 0, r3, r1, cr14
 160:	4b022807 	blmi	8a184 <_etext+0x87cb4>
 164:	0d41080e 	stcleq	8, cr0, [r1, #-56]	@ 0xffffffc8
 168:	0000000d 	andeq	r0, r0, sp
 16c:	00000020 	andeq	r0, r0, r0, lsr #32
 170:	000000a4 	andeq	r0, r0, r4, lsr #1
 174:	00000680 	andeq	r0, r0, r0, lsl #13
 178:	0000005c 	andeq	r0, r0, ip, asr r0
 17c:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 180:	41018e02 	tstmi	r1, r2, lsl #28
 184:	0d41100e 	stcleq	0, cr1, [r1, #-56]	@ 0xffffffc8
 188:	080e6007 	stmdaeq	lr, {r0, r1, r2, sp, lr}
 18c:	000d0d41 	andeq	r0, sp, r1, asr #26
 190:	00000020 	andeq	r0, r0, r0, lsr #32
 194:	000000a4 	andeq	r0, r0, r4, lsr #1
 198:	000006dc 	ldrdeq	r0, [r0], -ip
 19c:	00000030 	andeq	r0, r0, r0, lsr r0
 1a0:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 1a4:	41018e02 	tstmi	r1, r2, lsl #28
 1a8:	0d41100e 	stcleq	0, cr1, [r1, #-56]	@ 0xffffffc8
 1ac:	080e5107 	stmdaeq	lr, {r0, r1, r2, r8, ip, lr}
 1b0:	000d0d41 	andeq	r0, sp, r1, asr #26
 1b4:	0000001c 	andeq	r0, r0, ip, lsl r0
 1b8:	000000a4 	andeq	r0, r0, r4, lsr #1
 1bc:	0000070c 	andeq	r0, r0, ip, lsl #14
 1c0:	0000001c 	andeq	r0, r0, ip, lsl r0
 1c4:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 1c8:	070d4101 	streq	r4, [sp, -r1, lsl #2]
 1cc:	410d0d47 	tstmi	sp, r7, asr #26
    ldr r0, =_sidata            /* Address of init values in flash */
 1d0:	00000ec7 	andeq	r0, r0, r7, asr #29
    ldr r2, =_edata             /* End of .data in RAM */
 1d4:	00000020 	andeq	r0, r0, r0, lsr #32
    bcs zero_bss
 1d8:	000000a4 	andeq	r0, r0, r4, lsr #1
    ldr r3, [r0], #4
 1dc:	00000728 	andeq	r0, r0, r8, lsr #14
    str r3, [r1], #4
 1e0:	000001f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
    ldr r0, =_sbss              /* Start of .bss */
 1e4:	87080e41 	strhi	r0, [r8, -r1, asr #28]
    cmp r0, r1
 1e8:	41018e02 	tstmi	r1, r2, lsl #28
    movs r2, #0
 1ec:	0d41280e 	stcleq	8, cr2, [r1, #-56]	@ 0xffffffc8
    str r2, [r0], #4
 1f0:	0ee10207 	cdpeq	2, 14, cr0, cr1, cr7, {0}
    bl start                    /* Call main/start function */
 1f4:	0d0d4108 	stfeqs	f4, [sp, #-32]	@ 0xffffffe0
    b hang                      /* If it returns, hang forever */
 1f8:	00000024 	andeq	r0, r0, r4, lsr #32
    b .
 1fc:	000000a4 	andeq	r0, r0, r4, lsr #1
    b .
 200:	00000918 	andeq	r0, r0, r8, lsl r9
    b .
 204:	0000001c 	andeq	r0, r0, ip, lsl r0
    ldr r0, =_sidata            /* Address of init values in flash */
 208:	87040e41 	strhi	r0, [r4, -r1, asr #28]
    ldr r1, =_sdata             /* Start of .data in RAM */
 20c:	100e4101 	andne	r4, lr, r1, lsl #2
    ldr r2, =_edata             /* End of .data in RAM */
 210:	46070d41 	strmi	r0, [r7], -r1, asr #26
    ldr r0, =_sbss              /* Start of .bss */
 214:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
    ldr r1, =_ebss              /* End of .bss */
 218:	0ec7410d 	poleqs	f4, f7, #5.0
static void vTask1(void *pvParameters){
 21c:	00000000 	andeq	r0, r0, r0
 220:	00000024 	andeq	r0, r0, r4, lsr #32
    volatile int a =0;
 224:	000000a4 	andeq	r0, r0, r4, lsr #1
        a++;
 228:	00000934 	andeq	r0, r0, r4, lsr r9
 22c:	00000020 	andeq	r0, r0, r0, lsr #32
static void vTask2(void *pvParameters){
 230:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 234:	100e4101 	andne	r4, lr, r1, lsl #2
    volatile int b =0;
 238:	48070d41 	stmdami	r7, {r0, r6, r8, sl, fp}
        b++;
 23c:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
 240:	0ec7410d 	poleqs	f4, f7, #5.0
void start(){
 244:	00000000 	andeq	r0, r0, r0
 248:	0000001c 	andeq	r0, r0, ip, lsl r0
    uint32_t *src = &_sidata;//Source flash
 24c:	000000a4 	andeq	r0, r0, r4, lsr #1
    uint32_t *dst = &_sdata;//Destination RAM
 250:	00000954 	andeq	r0, r0, r4, asr r9
        *dst++ = *src++; //copy word and increment pointer
 254:	00000014 	andeq	r0, r0, r4, lsl r0
 258:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 25c:	070d4101 	streq	r4, [sp, -r1, lsl #2]
 260:	410d0d44 	tstmi	sp, r4, asr #26
    while(dst < &_edata){
 264:	00000ec7 	andeq	r0, r0, r7, asr #29
 268:	00000024 	andeq	r0, r0, r4, lsr #32
    dst = &_sbss;
 26c:	000000a4 	andeq	r0, r0, r4, lsr #1
    while(dst < &_ebss){
 270:	00000968 	andeq	r0, r0, r8, ror #18
        *dst++ = 0; //zero word and increment pointer
 274:	0000002c 	andeq	r0, r0, ip, lsr #32
 278:	87040e41 	strhi	r0, [r4, -r1, asr #28]
    while(dst < &_ebss){
 27c:	180e4101 	stmdane	lr, {r0, r8, lr}
 280:	4d070d41 	stcmi	13, cr0, [r7, #-260]	@ 0xfffffefc
    xReturn = xTaskCreate(vTask1,"T1",configMINIMAL_STACK_SIZE,NULL,1,NULL);  // 256*4 = 1k stack size
 284:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
 288:	0ec7410d 	poleqs	f4, f7, #5.0
 28c:	00000000 	andeq	r0, r0, r0
 290:	00000020 	andeq	r0, r0, r0, lsr #32
 294:	000000a4 	andeq	r0, r0, r4, lsr #1
 298:	00000994 	muleq	r0, r4, r9
    xReturn = xTaskCreate(vTask2,"T2",configMINIMAL_STACK_SIZE,NULL,1,NULL);
 29c:	00000034 	andeq	r0, r0, r4, lsr r0
 2a0:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 2a4:	41018e02 	tstmi	r1, r2, lsl #28
 2a8:	0d41180e 	stcleq	8, cr1, [r1, #-56]	@ 0xffffffc8
 2ac:	080e5307 	stmdaeq	lr, {r0, r1, r2, r8, r9, ip, lr}
 2b0:	000d0d41 	andeq	r0, sp, r1, asr #26
    xPortStartScheduler();
 2b4:	00000020 	andeq	r0, r0, r0, lsr #32
    return;
 2b8:	000000a4 	andeq	r0, r0, r4, lsr #1
 2bc:	000009c8 	andeq	r0, r0, r8, asr #19
 2c0:	00000210 	andeq	r0, r0, r0, lsl r2
 2c4:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 2c8:	41018e02 	tstmi	r1, r2, lsl #28
 2cc:	0d41280e 	stcleq	8, cr2, [r1, #-56]	@ 0xffffffc8
 2d0:	0eed0207 	cdpeq	2, 14, cr0, cr13, cr7, {0}
 2d4:	0d0d4108 	stfeqs	f4, [sp, #-32]	@ 0xffffffe0
 2d8:	00000024 	andeq	r0, r0, r4, lsr #32
 2dc:	000000a4 	andeq	r0, r0, r4, lsr #1
 2e0:	00000bd8 	ldrdeq	r0, [r0], -r8
void *memset(void *dest, int c, size_t count) {
 2e4:	0000008c 	andeq	r0, r0, ip, lsl #1
 2e8:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 2ec:	180e4101 	stmdane	lr, {r0, r8, lr}
    unsigned char *ptr = (unsigned char *)dest;
 2f0:	76070d41 	strvc	r0, [r7], -r1, asr #26
    unsigned char value = (unsigned char)c;
 2f4:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
    for (size_t i = 0; i < count; i++) {
 2f8:	0ec7410d 	poleqs	f4, f7, #5.0
 2fc:	00000000 	andeq	r0, r0, r0
        ptr[i] = value;
 300:	00000020 	andeq	r0, r0, r0, lsr #32
 304:	000000a4 	andeq	r0, r0, r4, lsr #1
    for (size_t i = 0; i < count; i++) {
 308:	00000c64 	andeq	r0, r0, r4, ror #24
 30c:	0000002c 	andeq	r0, r0, ip, lsr #32
 310:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 314:	41018e02 	tstmi	r1, r2, lsl #28
 318:	0d41100e 	stcleq	0, cr1, [r1, #-56]	@ 0xffffffc8
 31c:	080e4f07 	stmdaeq	lr, {r0, r1, r2, r8, r9, sl, fp, lr}
 320:	000d0d41 	andeq	r0, sp, r1, asr #26
    {
 324:	00000020 	andeq	r0, r0, r0, lsr #32
 328:	000000a4 	andeq	r0, r0, r4, lsr #1
 32c:	00000c90 	muleq	r0, r0, ip
 330:	00000070 	andeq	r0, r0, r0, ror r0
            pxStack = pvPortMallocStack( ( ( ( size_t ) uxStackDepth ) * sizeof( StackType_t ) ) );
 334:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 338:	41018e02 	tstmi	r1, r2, lsl #28
 33c:	0d41200e 	stcleq	0, cr2, [r1, #-56]	@ 0xffffffc8
            if( pxStack != NULL )
 340:	080e7007 	stmdaeq	lr, {r0, r1, r2, ip, sp, lr}
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 344:	000d0d41 	andeq	r0, sp, r1, asr #26
 348:	00000024 	andeq	r0, r0, r4, lsr #32
                if( pxNewTCB != NULL )
 34c:	000000a4 	andeq	r0, r0, r4, lsr #1
 350:	00000d00 	andeq	r0, r0, r0, lsl #26
                    ( void ) memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
 354:	00000194 	muleq	r0, r4, r1
 358:	87040e41 	strhi	r0, [r4, -r1, asr #28]
                    pxNewTCB->pxStack = pxStack;
 35c:	280e4101 	stmdacs	lr, {r0, r8, lr}
 360:	02070d41 	andeq	r0, r7, #4160	@ 0x1040
                    vPortFreeStack( pxStack );
 364:	41040eb7 			@ <UNDEFINED> instruction: 0x41040eb7
 368:	c7410d0d 	strbgt	r0, [r1, -sp, lsl #26]
                pxNewTCB = NULL;
 36c:	0000000e 	andeq	r0, r0, lr
        if( pxNewTCB != NULL )
 370:	00000024 	andeq	r0, r0, r4, lsr #32
 374:	000000a4 	andeq	r0, r0, r4, lsr #1
            prvInitialiseNewTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 378:	00000e94 	muleq	r0, r4, lr
 37c:	00000144 	andeq	r0, r0, r4, asr #2
 380:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 384:	200e4101 	andcs	r4, lr, r1, lsl #2
 388:	02070d41 	andeq	r0, r7, #4160	@ 0x1040
 38c:	41040e94 			@ <UNDEFINED> instruction: 0x41040e94
 390:	c7410d0d 	strbgt	r0, [r1, -sp, lsl #26]
    }
 394:	0000000e 	andeq	r0, r0, lr
 398:	00000020 	andeq	r0, r0, r0, lsr #32
    {
 39c:	000000a4 	andeq	r0, r0, r4, lsr #1
 3a0:	00000fd8 	ldrdeq	r0, [r0], -r8
 3a4:	00000030 	andeq	r0, r0, r0, lsr r0
 3a8:	87080e41 	strhi	r0, [r8, -r1, asr #28]
        pxNewTCB = prvCreateTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask );
 3ac:	41018e02 	tstmi	r1, r2, lsl #28
 3b0:	0d41100e 	stcleq	0, cr1, [r1, #-56]	@ 0xffffffc8
 3b4:	080e4f07 	stmdaeq	lr, {r0, r1, r2, r8, r9, sl, fp, lr}
 3b8:	000d0d41 	andeq	r0, sp, r1, asr #26
 3bc:	00000024 	andeq	r0, r0, r4, lsr #32
        if( pxNewTCB != NULL )
 3c0:	000000a4 	andeq	r0, r0, r4, lsr #1
 3c4:	00001008 	andeq	r1, r0, r8
            prvAddNewTaskToReadyList( pxNewTCB );
 3c8:	0000002c 	andeq	r0, r0, ip, lsr #32
            xReturn = pdPASS;
 3cc:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 3d0:	100e4101 	andne	r4, lr, r1, lsl #2
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 3d4:	4b070d41 	blmi	1c38e0 <_etext+0x1c1410>
        return xReturn;
 3d8:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
    }
 3dc:	0ec7410d 	poleqs	f4, f7, #5.0
 3e0:	00000000 	andeq	r0, r0, r0
{
 3e4:	00000020 	andeq	r0, r0, r0, lsr #32
 3e8:	000000a4 	andeq	r0, r0, r4, lsr #1
 3ec:	00001034 	andeq	r1, r0, r4, lsr r0
        pxTopOfStack = &( pxNewTCB->pxStack[ uxStackDepth - ( configSTACK_DEPTH_TYPE ) 1 ] );
 3f0:	00000084 	andeq	r0, r0, r4, lsl #1
 3f4:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 3f8:	41018e02 	tstmi	r1, r2, lsl #28
 3fc:	0d41200e 	stcleq	0, cr2, [r1, #-56]	@ 0xffffffc8
 400:	080e7807 	stmdaeq	lr, {r0, r1, r2, fp, ip, sp, lr}
        pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 404:	000d0d41 	andeq	r0, sp, r1, asr #26
 408:	0000001c 	andeq	r0, r0, ip, lsl r0
    if( pcName != NULL )
 40c:	000000a4 	andeq	r0, r0, r4, lsr #1
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 410:	000010b8 	strheq	r1, [r0], -r8
 414:	00000018 	andeq	r0, r0, r8, lsl r0
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 418:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 41c:	070d4101 	streq	r4, [sp, -r1, lsl #2]
 420:	410d0d45 	tstmi	sp, r5, asr #26
 424:	00000ec7 	andeq	r0, r0, r7, asr #29
 428:	0000001c 	andeq	r0, r0, ip, lsl r0
            if( pcName[ x ] == ( char ) 0x00 )
 42c:	000000a4 	andeq	r0, r0, r4, lsr #1
 430:	000010d0 	ldrdeq	r1, [r0], -r0
 434:	00000030 	andeq	r0, r0, r0, lsr r0
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 438:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 43c:	41018e02 	tstmi	r1, r2, lsl #28
 440:	0d41100e 	stcleq	0, cr1, [r1, #-56]	@ 0xffffffc8
                break;
 444:	00000007 	andeq	r0, r0, r7
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1U ] = '\0';
 448:	00000020 	andeq	r0, r0, r0, lsr #32
 44c:	000000a4 	andeq	r0, r0, r4, lsr #1
    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 450:	00001100 	andeq	r1, r0, r0, lsl #2
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 454:	0000006c 	andeq	r0, r0, ip, rrx
    pxNewTCB->uxPriority = uxPriority;
 458:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 45c:	41018e02 	tstmi	r1, r2, lsl #28
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 460:	0d41100e 	stcleq	0, cr1, [r1, #-56]	@ 0xffffffc8
 464:	080e6407 	stmdaeq	lr, {r0, r1, r2, sl, sp, lr}
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 468:	000d0d41 	andeq	r0, sp, r1, asr #26
 46c:	0000001c 	andeq	r0, r0, ip, lsl r0
 470:	000000a4 	andeq	r0, r0, r4, lsr #1
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 474:	0000116c 	andeq	r1, r0, ip, ror #2
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority );
 478:	0000000c 	andeq	r0, r0, ip
 47c:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 480:	070d4101 	streq	r4, [sp, -r1, lsl #2]
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 484:	410d0d42 	tstmi	sp, r2, asr #26
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 488:	00000ec7 	andeq	r0, r0, r7, asr #29
 48c:	0000001c 	andeq	r0, r0, ip, lsl r0
 490:	000000a4 	andeq	r0, r0, r4, lsr #1
 494:	00001178 	andeq	r1, r0, r8, ror r1
    if( pxCreatedTask != NULL )
 498:	00000034 	andeq	r0, r0, r4, lsr r0
 49c:	87040e41 	strhi	r0, [r4, -r1, asr #28]
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 4a0:	070d4101 	streq	r4, [sp, -r1, lsl #2]
}
 4a4:	410d0d52 	tstmi	sp, r2, asr sp
 4a8:	00000ec7 	andeq	r0, r0, r7, asr #29
    {
 4ac:	00000024 	andeq	r0, r0, r4, lsr #32
 4b0:	000000a4 	andeq	r0, r0, r4, lsr #1
        taskENTER_CRITICAL();
 4b4:	000011ac 	andeq	r1, r0, ip, lsr #3
            uxCurrentNumberOfTasks = ( UBaseType_t ) ( uxCurrentNumberOfTasks + 1U );
 4b8:	0000001c 	andeq	r0, r0, ip, lsl r0
 4bc:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 4c0:	100e4101 	andne	r4, lr, r1, lsl #2
            if( pxCurrentTCB == NULL )
 4c4:	46070d41 	strmi	r0, [r7], -r1, asr #26
 4c8:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
                pxCurrentTCB = pxNewTCB;
 4cc:	0ec7410d 	poleqs	f4, f7, #5.0
                if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 4d0:	00000000 	andeq	r0, r0, r0
 4d4:	00000024 	andeq	r0, r0, r4, lsr #32
                    prvInitialiseTaskLists();
 4d8:	000000a4 	andeq	r0, r0, r4, lsr #1
 4dc:	000011c8 	andeq	r1, r0, r8, asr #3
                if( xSchedulerRunning == pdFALSE )
 4e0:	00000030 	andeq	r0, r0, r0, lsr r0
 4e4:	87040e41 	strhi	r0, [r4, -r1, asr #28]
                    if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 4e8:	180e4101 	stmdane	lr, {r0, r8, lr}
 4ec:	4f070d41 	svcmi	0x00070d41
 4f0:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
                        pxCurrentTCB = pxNewTCB;
 4f4:	0ec7410d 	poleqs	f4, f7, #5.0
 4f8:	00000000 	andeq	r0, r0, r0
            uxTaskNumber++;
 4fc:	00000024 	andeq	r0, r0, r4, lsr #32
 500:	000000a4 	andeq	r0, r0, r4, lsr #1
            prvAddTaskToReadyList( pxNewTCB );
 504:	000011f8 	strdeq	r1, [r0], -r8
 508:	00000030 	andeq	r0, r0, r0, lsr r0
 50c:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 510:	100e4101 	andne	r4, lr, r1, lsl #2
 514:	4f070d41 	svcmi	0x00070d41
 518:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
 51c:	0ec7410d 	poleqs	f4, f7, #5.0
 520:	00000000 	andeq	r0, r0, r0
 524:	00000020 	andeq	r0, r0, r0, lsr #32
 528:	000000a4 	andeq	r0, r0, r4, lsr #1
 52c:	00001228 	andeq	r1, r0, r8, lsr #4
 530:	000000f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
 534:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 538:	41018e02 	tstmi	r1, r2, lsl #28
 53c:	0d41280e 	stcleq	8, cr2, [r1, #-56]	@ 0xffffffc8
 540:	0e6f0207 	cdpeq	2, 6, cr0, cr15, cr7, {0}
 544:	0d0d4108 	stfeqs	f4, [sp, #-32]	@ 0xffffffe0
 548:	00000020 	andeq	r0, r0, r0, lsr #32
 54c:	000000a4 	andeq	r0, r0, r4, lsr #1
 550:	00001318 	andeq	r1, r0, r8, lsl r3
 554:	00000124 	andeq	r0, r0, r4, lsr #2
 558:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 55c:	41018e02 	tstmi	r1, r2, lsl #28
 560:	0d41280e 	stcleq	8, cr2, [r1, #-56]	@ 0xffffffc8
 564:	0e880207 	cdpeq	2, 8, cr0, cr8, cr7, {0}
 568:	0d0d4108 	stfeqs	f4, [sp, #-32]	@ 0xffffffe0
 56c:	00000020 	andeq	r0, r0, r0, lsr #32
 570:	000000a4 	andeq	r0, r0, r4, lsr #1
 574:	0000143c 	andeq	r1, r0, ip, lsr r4
 578:	000001d4 	ldrdeq	r0, [r0], -r4
 57c:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 580:	41018e02 	tstmi	r1, r2, lsl #28
 584:	0d41300e 	stcleq	0, cr3, [r1, #-56]	@ 0xffffffc8
        taskEXIT_CRITICAL();
 588:	0edc0207 	cdpeq	2, 13, cr0, cr12, cr7, {0}
        if( xSchedulerRunning != pdFALSE )
 58c:	0d0d4108 	stfeqs	f4, [sp, #-32]	@ 0xffffffe0
 590:	00000024 	andeq	r0, r0, r4, lsr #32
            taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxNewTCB );
 594:	000000a4 	andeq	r0, r0, r4, lsr #1
 598:	00001610 	andeq	r1, r0, r0, lsl r6
 59c:	0000024c 	andeq	r0, r0, ip, asr #4
 5a0:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 5a4:	400e4101 	andmi	r4, lr, r1, lsl #2
 5a8:	03070d41 	movweq	r0, #32065	@ 0x7d41
 5ac:	040e0113 	streq	r0, [lr], #-275	@ 0xfffffeed
    }
 5b0:	410d0d41 	tstmi	sp, r1, asr #26
 5b4:	00000ec7 	andeq	r0, r0, r7, asr #29
 5b8:	00000024 	andeq	r0, r0, r4, lsr #32
 5bc:	000000a4 	andeq	r0, r0, r4, lsr #1
 5c0:	0000185c 	andeq	r1, r0, ip, asr r8
 5c4:	000001bc 			@ <UNDEFINED> instruction: 0x000001bc
 5c8:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 5cc:	400e4101 	andmi	r4, lr, r1, lsl #2
 5d0:	02070d41 	andeq	r0, r7, #4160	@ 0x1040
{
 5d4:	41040ecb 	smlabtmi	r4, fp, lr, r0
 5d8:	c7410d0d 	strbgt	r0, [r1, -sp, lsl #26]
    BaseType_t xReturn = pdPASS;
 5dc:	0000000e 	andeq	r0, r0, lr
    char cIdleName[ configMAX_TASK_NAME_LEN ] = { 0 };
 5e0:	00000020 	andeq	r0, r0, r0, lsr #32
 5e4:	000000a4 	andeq	r0, r0, r4, lsr #1
 5e8:	00001a18 	andeq	r1, r0, r8, lsl sl
    TaskFunction_t pxIdleTaskFunction = NULL;
 5ec:	00000058 	andeq	r0, r0, r8, asr r0
    for( xIdleTaskNameIndex = 0U; xIdleTaskNameIndex < ( configMAX_TASK_NAME_LEN - taskRESERVED_TASK_NAME_LENGTH ); xIdleTaskNameIndex++ )
 5f0:	87080e41 	strhi	r0, [r8, -r1, asr #28]
        cIdleName[ xIdleTaskNameIndex ] = configIDLE_TASK_NAME[ xIdleTaskNameIndex ];
 5f4:	41018e02 	tstmi	r1, r2, lsl #28
 5f8:	0d41180e 	stcleq	8, cr1, [r1, #-56]	@ 0xffffffc8
 5fc:	080e6407 	stmdaeq	lr, {r0, r1, r2, sl, sp, lr}
 600:	000d0d41 	andeq	r0, sp, r1, asr #26
 604:	00000020 	andeq	r0, r0, r0, lsr #32
        if( cIdleName[ xIdleTaskNameIndex ] == ( char ) 0x00 )
 608:	000000a4 	andeq	r0, r0, r4, lsr #1
 60c:	00001a70 	andeq	r1, r0, r0, ror sl
 610:	00000060 	andeq	r0, r0, r0, rrx
    for( xIdleTaskNameIndex = 0U; xIdleTaskNameIndex < ( configMAX_TASK_NAME_LEN - taskRESERVED_TASK_NAME_LENGTH ); xIdleTaskNameIndex++ )
 614:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 618:	41018e02 	tstmi	r1, r2, lsl #28
 61c:	0d41200e 	stcleq	0, cr2, [r1, #-56]	@ 0xffffffc8
            break;
 620:	080e6807 	stmdaeq	lr, {r0, r1, r2, fp, sp, lr}
    cIdleName[ xIdleTaskNameIndex ] = '\0';
 624:	000d0d41 	andeq	r0, sp, r1, asr #26
 628:	00000020 	andeq	r0, r0, r0, lsr #32
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
 62c:	000000a4 	andeq	r0, r0, r4, lsr #1
 630:	00001ad0 	ldrdeq	r1, [r0], -r0
            pxIdleTaskFunction = &prvIdleTask;
 634:	000000ac 	andeq	r0, r0, ip, lsr #1
            xReturn = xTaskCreate( pxIdleTaskFunction,
 638:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 63c:	41018e02 	tstmi	r1, r2, lsl #28
 640:	0d41200e 	stcleq	0, cr2, [r1, #-56]	@ 0xffffffc8
 644:	0e450207 	cdpeq	2, 4, cr0, cr5, cr7, {0}
 648:	0d0d4108 	stfeqs	f4, [sp, #-32]	@ 0xffffffe0
 64c:	00000024 	andeq	r0, r0, r4, lsr #32
 650:	000000a4 	andeq	r0, r0, r4, lsr #1
        if( xReturn != pdPASS )
 654:	00001b7c 	andeq	r1, r0, ip, ror fp
 658:	00000094 	muleq	r0, r4, r0
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
 65c:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 660:	100e4101 	andne	r4, lr, r1, lsl #2
 664:	6e070d41 	cdpvs	13, 0, cr0, cr7, cr1, {2}
            break;
 668:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
}
 66c:	0ec7410d 	poleqs	f4, f7, #5.0
 670:	00000000 	andeq	r0, r0, r0
 674:	0000000c 	andeq	r0, r0, ip
 678:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 67c:	7c020001 	stcvc	0, cr0, [r2], {1}
{
 680:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 684:	00000024 	andeq	r0, r0, r4, lsr #32
    xReturn = prvCreateIdleTasks();
 688:	00000674 	andeq	r0, r0, r4, ror r6
    if( xReturn == pdPASS )
 68c:	00001c10 	andeq	r1, r0, r0, lsl ip
 690:	0000003e 	andeq	r0, r0, lr, lsr r0
    __asm volatile
 694:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 698:	100e4101 	andne	r4, lr, r1, lsl #2
 69c:	59070d41 	stmdbpl	r7, {r0, r6, r8, sl, fp}
 6a0:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
}
 6a4:	0ec7410d 	poleqs	f4, f7, #5.0
        xNextTaskUnblockTime = portMAX_DELAY;
 6a8:	00000000 	andeq	r0, r0, r0
 6ac:	00000024 	andeq	r0, r0, r4, lsr #32
        xSchedulerRunning = pdTRUE;
 6b0:	00000674 	andeq	r0, r0, r4, ror r6
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 6b4:	00001c4e 	andeq	r1, r0, lr, asr #24
 6b8:	00000018 	andeq	r0, r0, r8, lsl r0
        ( void ) xPortStartScheduler();
 6bc:	87040e41 	strhi	r0, [r4, -r1, asr #28]
    ( void ) uxTopUsedPriority;
 6c0:	100e4101 	andne	r4, lr, r1, lsl #2
}
 6c4:	46070d41 	strmi	r0, [r7], -r1, asr #26
 6c8:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
 6cc:	0ec7410d 	poleqs	f4, f7, #5.0
 6d0:	00000000 	andeq	r0, r0, r0
 6d4:	00000024 	andeq	r0, r0, r4, lsr #32
 6d8:	00000674 	andeq	r0, r0, r4, ror r6
{
 6dc:	00001c66 	andeq	r1, r0, r6, ror #24
 6e0:	00000046 	andeq	r0, r0, r6, asr #32
    __asm volatile
 6e4:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 6e8:	180e4101 	stmdane	lr, {r0, r8, lr}
 6ec:	5d070d41 	stcpl	13, cr0, [r7, #-260]	@ 0xfffffefc
 6f0:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
}
 6f4:	0ec7410d 	poleqs	f4, f7, #5.0
    xSchedulerRunning = pdFALSE;
 6f8:	00000000 	andeq	r0, r0, r0
    vPortEndScheduler();
 6fc:	00000024 	andeq	r0, r0, r4, lsr #32
}
 700:	00000674 	andeq	r0, r0, r4, ror r6
 704:	00001cac 	andeq	r1, r0, ip, lsr #25
 708:	00000070 	andeq	r0, r0, r0, ror r0
{
 70c:	87040e41 	strhi	r0, [r4, -r1, asr #28]
        uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended + 1U );
 710:	180e4101 	stmdane	lr, {r0, r8, lr}
 714:	72070d41 	andvc	r0, r7, #4160	@ 0x1040
 718:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
}
 71c:	0ec7410d 	poleqs	f4, f7, #5.0
 720:	00000000 	andeq	r0, r0, r0
 724:	00000024 	andeq	r0, r0, r4, lsr #32
{
 728:	00000674 	andeq	r0, r0, r4, ror r6
 72c:	00001d1c 	andeq	r1, r0, ip, lsl sp
    TCB_t * pxTCB = NULL;
 730:	00000052 	andeq	r0, r0, r2, asr r0
    BaseType_t xAlreadyYielded = pdFALSE;
 734:	87040e41 	strhi	r0, [r4, -r1, asr #28]
        taskENTER_CRITICAL();
 738:	180e4101 	stmdane	lr, {r0, r8, lr}
            const BaseType_t xCoreID = ( BaseType_t ) portGET_CORE_ID();
 73c:	63070d41 	movwvs	r0, #32065	@ 0x7d41
            uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended - 1U );
 740:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
 744:	0ec7410d 	poleqs	f4, f7, #5.0
            if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 748:	00000000 	andeq	r0, r0, r0
 74c:	0000000c 	andeq	r0, r0, ip
 750:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
                if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 754:	7c020001 	stcvc	0, cr0, [r2], {1}
 758:	000d0c0e 	andeq	r0, sp, lr, lsl #24
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 75c:	00000020 	andeq	r0, r0, r0, lsr #32
                        pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 760:	0000074c 	andeq	r0, r0, ip, asr #14
 764:	00001d70 	andeq	r1, r0, r0, ror sp
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 768:	00000164 	andeq	r0, r0, r4, ror #2
 76c:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 770:	41018e02 	tstmi	r1, r2, lsl #28
 774:	0d41280e 	stcleq	8, cr2, [r1, #-56]	@ 0xffffffc8
 778:	0ea30207 	cdpeq	2, 10, cr0, cr3, cr7, {0}
 77c:	0d0d4108 	stfeqs	f4, [sp, #-32]	@ 0xffffffe0
 780:	00000020 	andeq	r0, r0, r0, lsr #32
 784:	0000074c 	andeq	r0, r0, ip, asr #14
 788:	00001ed4 	ldrdeq	r1, [r0], -r4
 78c:	00000074 	andeq	r0, r0, r4, ror r0
 790:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 794:	41018e02 	tstmi	r1, r2, lsl #28
 798:	0d41180e 	stcleq	8, cr1, [r1, #-56]	@ 0xffffffc8
 79c:	080e7007 	stmdaeq	lr, {r0, r1, r2, ip, sp, lr}
 7a0:	000d0d41 	andeq	r0, sp, r1, asr #26
                        listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 7a4:	0000001c 	andeq	r0, r0, ip, lsl r0
 7a8:	0000074c 	andeq	r0, r0, ip, asr #14
 7ac:	00001f48 	andeq	r1, r0, r8, asr #30
 7b0:	00000014 	andeq	r0, r0, r4, lsl r0
 7b4:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 7b8:	070d4101 	streq	r4, [sp, -r1, lsl #2]
 7bc:	410d0d44 	tstmi	sp, r4, asr #26
 7c0:	00000ec7 	andeq	r0, r0, r7, asr #29
 7c4:	0000001c 	andeq	r0, r0, ip, lsl r0
 7c8:	0000074c 	andeq	r0, r0, ip, asr #14
 7cc:	00001f5c 	andeq	r1, r0, ip, asr pc
 7d0:	00000014 	andeq	r0, r0, r4, lsl r0
 7d4:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 7d8:	070d4101 	streq	r4, [sp, -r1, lsl #2]
 7dc:	410d0d44 	tstmi	sp, r4, asr #26
 7e0:	00000ec7 	andeq	r0, r0, r7, asr #29
                        prvAddTaskToReadyList( pxTCB );
 7e4:	0000001c 	andeq	r0, r0, ip, lsl r0
 7e8:	0000074c 	andeq	r0, r0, ip, asr #14
 7ec:	00001f70 	andeq	r1, r0, r0, ror pc
 7f0:	0000001c 	andeq	r0, r0, ip, lsl r0
 7f4:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 7f8:	070d4101 	streq	r4, [sp, -r1, lsl #2]
 7fc:	410d0d46 	tstmi	sp, r6, asr #26
 800:	00000ec7 	andeq	r0, r0, r7, asr #29
 804:	0000001c 	andeq	r0, r0, ip, lsl r0
 808:	0000074c 	andeq	r0, r0, ip, asr #14
 80c:	00001f8c 	andeq	r1, r0, ip, lsl #31
 810:	0000000c 	andeq	r0, r0, ip
 814:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 818:	070d4101 	streq	r4, [sp, -r1, lsl #2]
 81c:	410d0d42 	tstmi	sp, r2, asr #26
 820:	00000ec7 	andeq	r0, r0, r7, asr #29
 824:	00000020 	andeq	r0, r0, r0, lsr #32
 828:	0000074c 	andeq	r0, r0, ip, asr #14
 82c:	00001f98 	muleq	r0, r8, pc	@ <UNPREDICTABLE>
 830:	00000060 	andeq	r0, r0, r0, rrx
 834:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 838:	41018e02 	tstmi	r1, r2, lsl #28
 83c:	0d41180e 	stcleq	8, cr1, [r1, #-56]	@ 0xffffffc8
 840:	080e6b07 	stmdaeq	lr, {r0, r1, r2, r8, r9, fp, sp, lr}
 844:	000d0d41 	andeq	r0, sp, r1, asr #26
 848:	00000024 	andeq	r0, r0, r4, lsr #32
 84c:	0000074c 	andeq	r0, r0, ip, asr #14
 850:	00001ff8 	strdeq	r1, [r0], -r8
 854:	000000b4 	strheq	r0, [r0], -r4
 858:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 85c:	180e4101 	stmdane	lr, {r0, r8, lr}
 860:	02070d41 	andeq	r0, r7, #4160	@ 0x1040
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 864:	41040e49 	tstmi	r4, r9, asr #28
 868:	c7410d0d 	strbgt	r0, [r1, -sp, lsl #26]
 86c:	0000000e 	andeq	r0, r0, lr
 870:	00000024 	andeq	r0, r0, r4, lsr #32
                                xYieldPendings[ xCoreID ] = pdTRUE;
 874:	0000074c 	andeq	r0, r0, ip, asr #14
 878:	000020ac 	andeq	r2, r0, ip, lsr #1
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 87c:	000000b0 	strheq	r0, [r0], -r0	@ <UNPREDICTABLE>
 880:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 884:	180e4101 	stmdane	lr, {r0, r8, lr}
                    if( pxTCB != NULL )
 888:	02070d41 	andeq	r0, r7, #4160	@ 0x1040
                        prvResetNextTaskUnblockTime();
 88c:	41040e4e 	tstmi	r4, lr, asr #28
                        TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 890:	c7410d0d 	strbgt	r0, [r1, -sp, lsl #26]
 894:	0000000e 	andeq	r0, r0, lr
                        if( xPendedCounts > ( TickType_t ) 0U )
 898:	00000020 	andeq	r0, r0, r0, lsr #32
                                if( xTaskIncrementTick() != pdFALSE )
 89c:	0000074c 	andeq	r0, r0, ip, asr #14
 8a0:	0000215c 	andeq	r2, r0, ip, asr r1
 8a4:	000000bc 	strheq	r0, [r0], -ip
                                    xYieldPendings[ xCoreID ] = pdTRUE;
 8a8:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 8ac:	41018e02 	tstmi	r1, r2, lsl #28
                                --xPendedCounts;
 8b0:	0d41200e 	stcleq	0, cr2, [r1, #-56]	@ 0xffffffc8
 8b4:	0e4d0207 	cdpeq	2, 4, cr0, cr13, cr7, {0}
                            } while( xPendedCounts > ( TickType_t ) 0U );
 8b8:	0d0d4108 	stfeqs	f4, [sp, #-32]	@ 0xffffffe0
                            xPendedTicks = 0;
 8bc:	0000001c 	andeq	r0, r0, ip, lsl r0
 8c0:	0000074c 	andeq	r0, r0, ip, asr #14
                    if( xYieldPendings[ xCoreID ] != pdFALSE )
 8c4:	00002218 	andeq	r2, r0, r8, lsl r2
 8c8:	00000040 	andeq	r0, r0, r0, asr #32
 8cc:	87040e41 	strhi	r0, [r4, -r1, asr #28]
                            xAlreadyYielded = pdTRUE;
 8d0:	070d4101 	streq	r4, [sp, -r1, lsl #2]
                            taskYIELD_TASK_CORE_IF_USING_PREEMPTION( pxCurrentTCB );
 8d4:	410d0d51 	tstmi	sp, r1, asr sp
 8d8:	00000ec7 	andeq	r0, r0, r7, asr #29
 8dc:	0000000c 	andeq	r0, r0, ip
 8e0:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 8e4:	7c020001 	stcvc	0, cr0, [r2], {1}
        taskEXIT_CRITICAL();
 8e8:	000d0c0e 	andeq	r0, sp, lr, lsl #24
}
 8ec:	00000024 	andeq	r0, r0, r4, lsr #32
 8f0:	000008dc 	ldrdeq	r0, [r0], -ip
 8f4:	00002258 	andeq	r2, r0, r8, asr r2
 8f8:	00000058 	andeq	r0, r0, r8, asr r0
 8fc:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 900:	180e4101 	stmdane	lr, {r0, r8, lr}
 904:	64070d41 	strvs	r0, [r7], #-3393	@ 0xfffff2bf
 908:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
 90c:	0ec7410d 	poleqs	f4, f7, #5.0
 910:	00000000 	andeq	r0, r0, r0
 914:	00000024 	andeq	r0, r0, r4, lsr #32
{
 918:	000008dc 	ldrdeq	r0, [r0], -ip
 91c:	000022b0 			@ <UNDEFINED> instruction: 0x000022b0
        xTicks = xTickCount;
 920:	00000032 	andeq	r0, r0, r2, lsr r0
    return xTicks;
 924:	87040e41 	strhi	r0, [r4, -r1, asr #28]
}
 928:	100e4101 	andne	r4, lr, r1, lsl #2
 92c:	53070d41 	movwpl	r0, #32065	@ 0x7d41
 930:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
{
 934:	0ec7410d 	poleqs	f4, f7, #5.0
 938:	00000000 	andeq	r0, r0, r0
    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
 93c:	0000000c 	andeq	r0, r0, ip
        xReturn = xTickCount;
 940:	000008dc 	ldrdeq	r0, [r0], -ip
    return xReturn;
 944:	000022e2 	andeq	r2, r0, r2, ror #5
}
 948:	00000028 	andeq	r0, r0, r8, lsr #32
 94c:	0000000c 	andeq	r0, r0, ip
 950:	000008dc 	ldrdeq	r0, [r0], -ip
{
 954:	0000230a 	andeq	r2, r0, sl, lsl #6
    return uxCurrentNumberOfTasks;
 958:	00000020 	andeq	r0, r0, r0, lsr #32
}
 95c:	00000020 	andeq	r0, r0, r0, lsr #32
 960:	000008dc 	ldrdeq	r0, [r0], -ip
 964:	0000232a 	andeq	r2, r0, sl, lsr #6
{
 968:	0000005a 	andeq	r0, r0, sl, asr r0
 96c:	87080e41 	strhi	r0, [r8, -r1, asr #28]
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 970:	41018e02 	tstmi	r1, r2, lsl #28
 974:	0d41100e 	stcleq	0, cr1, [r1, #-56]	@ 0xffffffc8
 978:	080e6007 	stmdaeq	lr, {r0, r1, r2, sp, lr}
 97c:	000d0d41 	andeq	r0, sp, r1, asr #26
    return &( pxTCB->pcTaskName[ 0 ] );
 980:	0000001c 	andeq	r0, r0, ip, lsl r0
}
 984:	000008dc 	ldrdeq	r0, [r0], -ip
 988:	00002384 	andeq	r2, r0, r4, lsl #7
 98c:	0000000c 	andeq	r0, r0, ip
 990:	87040e41 	strhi	r0, [r4, -r1, asr #28]
{
 994:	070d4101 	streq	r4, [sp, -r1, lsl #2]
 998:	410d0d42 	tstmi	sp, r2, asr #26
    vTaskSuspendAll();
 99c:	00000ec7 	andeq	r0, r0, r7, asr #29
    taskENTER_CRITICAL();
 9a0:	00000024 	andeq	r0, r0, r4, lsr #32
        xPendedTicks += xTicksToCatchUp;
 9a4:	000008dc 	ldrdeq	r0, [r0], -ip
 9a8:	00002390 	muleq	r0, r0, r3
 9ac:	00000034 	andeq	r0, r0, r4, lsr r0
    taskEXIT_CRITICAL();
 9b0:	87040e41 	strhi	r0, [r4, -r1, asr #28]
    xYieldOccurred = xTaskResumeAll();
 9b4:	100e4101 	andne	r4, lr, r1, lsl #2
 9b8:	51070d41 	tstpl	r7, r1, asr #26
}
 9bc:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
 9c0:	0ec7410d 	poleqs	f4, f7, #5.0
 9c4:	00000000 	andeq	r0, r0, r0
{
 9c8:	00000024 	andeq	r0, r0, r4, lsr #32
 9cc:	000008dc 	ldrdeq	r0, [r0], -ip
    BaseType_t xSwitchRequired = pdFALSE;
 9d0:	000023c4 	andeq	r2, r0, r4, asr #7
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 9d4:	00000034 	andeq	r0, r0, r4, lsr r0
 9d8:	87040e41 	strhi	r0, [r4, -r1, asr #28]
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 9dc:	100e4101 	andne	r4, lr, r1, lsl #2
 9e0:	51070d41 	tstpl	r7, r1, asr #26
        xTickCount = xConstTickCount;
 9e4:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
 9e8:	0ec7410d 	poleqs	f4, f7, #5.0
        if( xConstTickCount == ( TickType_t ) 0U )
 9ec:	00000000 	andeq	r0, r0, r0
            taskSWITCH_DELAYED_LISTS();
 9f0:	0000000c 	andeq	r0, r0, ip
 9f4:	000008dc 	ldrdeq	r0, [r0], -ip
 9f8:	000023f8 	strdeq	r2, [r0], -r8
 9fc:	00000046 	andeq	r0, r0, r6, asr #32
 a00:	00000020 	andeq	r0, r0, r0, lsr #32
 a04:	000008dc 	ldrdeq	r0, [r0], -ip
 a08:	0000243e 	andeq	r2, r0, lr, lsr r4
 a0c:	00000046 	andeq	r0, r0, r6, asr #32
 a10:	87080e41 	strhi	r0, [r8, -r1, asr #28]
        if( xConstTickCount >= xNextTaskUnblockTime )
 a14:	41018e02 	tstmi	r1, r2, lsl #28
 a18:	0d41100e 	stcleq	0, cr1, [r1, #-56]	@ 0xffffffc8
 a1c:	080e5b07 	stmdaeq	lr, {r0, r1, r2, r8, r9, fp, ip, lr}
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 a20:	000d0d41 	andeq	r0, sp, r1, asr #26
 a24:	0000001c 	andeq	r0, r0, ip, lsl r0
                    xNextTaskUnblockTime = portMAX_DELAY;
 a28:	000008dc 	ldrdeq	r0, [r0], -ip
 a2c:	00002484 	andeq	r2, r0, r4, lsl #9
                    break;
 a30:	00000034 	andeq	r0, r0, r4, lsr r0
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 a34:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 a38:	070d4101 	streq	r4, [sp, -r1, lsl #2]
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 a3c:	410d0d4e 	tstmi	sp, lr, asr #26
 a40:	00000ec7 	andeq	r0, r0, r7, asr #29
